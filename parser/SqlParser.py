# Generated from SqlParser.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u03d4")
        buf.write("\u03fd\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\3\2\5\2\u0090\n\2\3\2\3\2\3\3\3\3")
        buf.write("\5\3\u0096\n\3\3\3\3\3\3\3\7\3\u009b\n\3\f\3\16\3\u009e")
        buf.write("\13\3\3\3\3\3\5\3\u00a2\n\3\3\3\5\3\u00a5\n\3\3\3\5\3")
        buf.write("\u00a8\n\3\3\4\3\4\3\5\3\5\3\6\3\6\3\7\3\7\3\7\3\7\5\7")
        buf.write("\u00b4\n\7\3\b\3\b\3\b\3\b\5\b\u00ba\n\b\3\b\3\b\3\t\3")
        buf.write("\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\5\t\u00cb")
        buf.write("\n\t\3\n\3\n\3\n\3\13\3\13\5\13\u00d2\n\13\3\f\3\f\3\f")
        buf.write("\3\f\3\f\7\f\u00d9\n\f\f\f\16\f\u00dc\13\f\3\r\3\r\5\r")
        buf.write("\u00e0\n\r\3\16\3\16\3\16\7\16\u00e5\n\16\f\16\16\16\u00e8")
        buf.write("\13\16\3\17\3\17\7\17\u00ec\n\17\f\17\16\17\u00ef\13\17")
        buf.write("\3\17\3\17\3\17\3\17\5\17\u00f5\n\17\3\20\3\20\5\20\u00f9")
        buf.write("\n\20\3\20\5\20\u00fc\n\20\3\20\3\20\3\20\3\20\3\20\5")
        buf.write("\20\u0103\n\20\3\20\5\20\u0106\n\20\3\20\3\20\5\20\u010a")
        buf.write("\n\20\3\21\5\21\u010d\n\21\3\21\3\21\3\21\3\21\5\21\u0113")
        buf.write("\n\21\3\21\3\21\3\21\3\21\5\21\u0119\n\21\3\21\3\21\5")
        buf.write("\21\u011d\n\21\3\21\3\21\3\21\3\21\3\21\5\21\u0124\n\21")
        buf.write("\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u012e\n")
        buf.write("\22\3\23\3\23\5\23\u0132\n\23\3\23\3\23\5\23\u0136\n\23")
        buf.write("\3\23\5\23\u0139\n\23\3\23\5\23\u013c\n\23\3\24\3\24\3")
        buf.write("\25\3\25\5\25\u0142\n\25\3\25\3\25\7\25\u0146\n\25\f\25")
        buf.write("\16\25\u0149\13\25\3\26\3\26\3\26\3\26\3\26\3\26\5\26")
        buf.write("\u0151\n\26\3\26\5\26\u0154\n\26\3\26\3\26\5\26\u0158")
        buf.write("\n\26\3\26\5\26\u015b\n\26\3\26\3\26\5\26\u015f\n\26\3")
        buf.write("\26\3\26\5\26\u0163\n\26\3\26\5\26\u0166\n\26\5\26\u0168")
        buf.write("\n\26\3\27\3\27\3\27\3\27\5\27\u016e\n\27\3\27\3\27\3")
        buf.write("\27\3\27\3\27\7\27\u0175\n\27\f\27\16\27\u0178\13\27\5")
        buf.write("\27\u017a\n\27\3\27\3\27\5\27\u017e\n\27\3\30\3\30\5\30")
        buf.write("\u0182\n\30\3\31\3\31\3\31\3\31\5\31\u0188\n\31\3\31\3")
        buf.write("\31\3\31\3\31\3\31\5\31\u018f\n\31\3\32\3\32\3\32\3\32")
        buf.write("\5\32\u0195\n\32\3\33\3\33\3\34\3\34\3\34\5\34\u019c\n")
        buf.write("\34\5\34\u019e\n\34\3\35\3\35\3\36\3\36\3\36\5\36\u01a5")
        buf.write("\n\36\3\37\3\37\3\37\3\37\3\37\5\37\u01ac\n\37\3 \3 \3")
        buf.write(" \5 \u01b1\n \3!\3!\3\"\6\"\u01b6\n\"\r\"\16\"\u01b7\3")
        buf.write("#\3#\3$\3$\3%\5%\u01bf\n%\3%\3%\3&\3&\3&\3&\3&\3&\3&\5")
        buf.write("&\u01ca\n&\3&\5&\u01cd\n&\3\'\3\'\5\'\u01d1\n\'\3(\3(")
        buf.write("\3(\3(\5(\u01d7\n(\5(\u01d9\n(\3)\3)\3)\7)\u01de\n)\f")
        buf.write(")\16)\u01e1\13)\3*\3*\3*\7*\u01e6\n*\f*\16*\u01e9\13*")
        buf.write("\3+\3+\3+\7+\u01ee\n+\f+\16+\u01f1\13+\3,\3,\3,\7,\u01f6")
        buf.write("\n,\f,\16,\u01f9\13,\3-\3-\3-\7-\u01fe\n-\f-\16-\u0201")
        buf.write("\13-\3.\3.\3.\7.\u0206\n.\f.\16.\u0209\13.\3/\3/\3/\7")
        buf.write("/\u020e\n/\f/\16/\u0211\13/\3\60\3\60\3\60\3\60\3\60\3")
        buf.write("\60\5\60\u0219\n\60\5\60\u021b\n\60\3\61\3\61\3\61\5\61")
        buf.write("\u0220\n\61\3\61\5\61\u0223\n\61\3\61\3\61\3\61\5\61\u0228")
        buf.write("\n\61\3\61\5\61\u022b\n\61\3\62\3\62\5\62\u022f\n\62\3")
        buf.write("\63\3\63\3\63\3\64\3\64\3\64\3\64\3\65\3\65\3\65\3\65")
        buf.write("\3\65\5\65\u023d\n\65\3\65\3\65\3\65\3\65\3\65\5\65\u0244")
        buf.write("\n\65\3\65\3\65\5\65\u0248\n\65\3\66\3\66\3\66\3\66\3")
        buf.write("\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66")
        buf.write("\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66")
        buf.write("\3\66\3\66\6\66\u0266\n\66\r\66\16\66\u0267\3\66\3\66")
        buf.write("\5\66\u026c\n\66\3\66\3\66\3\66\3\66\6\66\u0272\n\66\r")
        buf.write("\66\16\66\u0273\3\66\3\66\5\66\u0278\n\66\3\66\3\66\3")
        buf.write("\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\5\66\u0285")
        buf.write("\n\66\3\66\3\66\3\66\5\66\u028a\n\66\3\66\3\66\3\66\3")
        buf.write("\66\3\66\3\66\5\66\u0292\n\66\3\66\3\66\3\66\5\66\u0297")
        buf.write("\n\66\3\66\3\66\3\66\5\66\u029c\n\66\5\66\u029e\n\66\3")
        buf.write("\66\3\66\3\66\3\66\3\66\3\66\3\66\5\66\u02a7\n\66\3\66")
        buf.write("\3\66\3\66\5\66\u02ac\n\66\3\66\3\66\3\66\3\66\3\66\3")
        buf.write("\66\5\66\u02b4\n\66\3\66\3\66\3\66\5\66\u02b9\n\66\3\66")
        buf.write("\3\66\3\66\3\66\3\66\3\66\5\66\u02c1\n\66\3\66\3\66\3")
        buf.write("\66\3\66\3\66\3\66\5\66\u02c9\n\66\3\66\3\66\3\66\3\66")
        buf.write("\3\66\3\66\3\66\3\66\5\66\u02d3\n\66\3\66\3\66\3\66\3")
        buf.write("\66\3\66\3\66\3\66\3\66\3\66\5\66\u02de\n\66\3\67\3\67")
        buf.write("\3\67\3\67\3\67\38\38\38\58\u02e8\n8\38\38\38\38\38\3")
        buf.write("8\38\58\u02f1\n8\38\58\u02f4\n8\38\38\38\38\38\38\38\3")
        buf.write("8\38\38\58\u0300\n8\38\38\38\38\38\38\58\u0308\n8\38\3")
        buf.write("8\38\38\38\38\78\u0310\n8\f8\168\u0313\138\58\u0315\n")
        buf.write("8\38\38\58\u0319\n8\38\38\58\u031d\n8\39\39\39\39\39\3")
        buf.write("9\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\39\5")
        buf.write("9\u0336\n9\3:\3:\3:\7:\u033b\n:\f:\16:\u033e\13:\3;\3")
        buf.write(";\3;\3;\5;\u0344\n;\3<\3<\3<\3<\3<\3<\5<\u034c\n<\3<\3")
        buf.write("<\3<\5<\u0351\n<\3<\3<\3<\3<\7<\u0357\n<\f<\16<\u035a")
        buf.write("\13<\3=\3=\3=\5=\u035f\n=\3=\3=\3=\3=\3=\3=\3=\3=\5=\u0369")
        buf.write("\n=\3=\3=\3=\3=\3=\3=\3=\3=\3=\3=\3=\5=\u0376\n=\3=\3")
        buf.write("=\3=\3=\5=\u037c\n=\3=\3=\3=\3=\5=\u0382\n=\3=\3=\3=\3")
        buf.write("=\3=\3=\3=\3=\3=\3=\3=\3=\3=\3=\5=\u0392\n=\3=\3=\3=\3")
        buf.write("=\5=\u0398\n=\7=\u039a\n=\f=\16=\u039d\13=\3>\3>\3>\3")
        buf.write(">\3>\3>\3>\3>\3>\3>\3>\3>\3>\7>\u03ac\n>\f>\16>\u03af")
        buf.write("\13>\3>\3>\3>\3>\3>\3>\3>\3>\3>\3>\3>\3>\3>\3>\3>\5>\u03c0")
        buf.write("\n>\3>\3>\3>\3>\3>\3>\3>\3>\7>\u03ca\n>\f>\16>\u03cd\13")
        buf.write(">\3?\3?\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\5@\u03df")
        buf.write("\n@\3A\3A\3A\3A\3A\3A\3A\5A\u03e8\nA\3B\3B\3B\3B\3B\3")
        buf.write("B\3B\5B\u03f1\nB\3C\3C\3D\3D\3E\3E\3F\3F\3G\3G\3G\2\5")
        buf.write("vxzH\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60")
        buf.write("\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082")
        buf.write("\u0084\u0086\u0088\u008a\u008c\2\37\4\2\16\16**\4\2!!")
        buf.write("II\4\2VV\u0082\u0082\4\2\b\b-.\3\2\u03d2\u03d3\4\2\u03bd")
        buf.write("\u03bf\u03c8\u03c8\4\288\u009b\u009b\6\2\u00b8\u00b8\u00c1")
        buf.write("\u00c4\u00ca\u00ca\u0109\u010a\3\2\u0275\u027b\4\2\u00b8")
        buf.write("\u00b9\u00bb\u00bb\4\2\u00a0\u00a0\u01e8\u01e8\4\2\u00e8")
        buf.write("\u00e9\u00ef\u00ef\4\2\"\"\u00e6\u00e9\3\2\u00f2\u00f3")
        buf.write("\5\2\21\21TT\u0099\u0099\4\2\u00bd\u00bd\u00bf\u00bf\5")
        buf.write("\2\u00d6\u00d6\u00dc\u00dd\u00e2\u00e2\4\2\b\b--\5\2\u00d7")
        buf.write("\u00d9\u00de\u00e1\u00e3\u00e5\4\2ee\u03b2\u03b2\5\28")
        buf.write("8\u009b\u009b\u0215\u0215\4\2yy\u0083\u0083\5\2\b\b\u00fe")
        buf.write("\u00fe\u01ee\u01ee\6\2ee\u03aa\u03aa\u03ac\u03ac\u03b2")
        buf.write("\u03b3\3\2\u03a7\u03ae\3\2\u022d\u0234\5\2\u00b8\u00bc")
        buf.write("\u00c6\u00c6\u00c9\u00c9\7\2\u00ca\u00ca\u00f9\u0200\u0202")
        buf.write("\u021e\u0220\u0227\u026b\u026b\13\2$$VV\u0082\u0082\u00b8")
        buf.write("\u00ba\u00bc\u00bc\u00da\u00da\u00f1\u00f1\u022d\u0234")
        buf.write("\u0275\u039d\2\u0494\2\u008f\3\2\2\2\4\u009c\3\2\2\2\6")
        buf.write("\u00a9\3\2\2\2\b\u00ab\3\2\2\2\n\u00ad\3\2\2\2\f\u00b3")
        buf.write("\3\2\2\2\16\u00b5\3\2\2\2\20\u00ca\3\2\2\2\22\u00cc\3")
        buf.write("\2\2\2\24\u00d1\3\2\2\2\26\u00d3\3\2\2\2\30\u00dd\3\2")
        buf.write("\2\2\32\u00e1\3\2\2\2\34\u00f4\3\2\2\2\36\u0109\3\2\2")
        buf.write("\2 \u0123\3\2\2\2\"\u012d\3\2\2\2$\u012f\3\2\2\2&\u013d")
        buf.write("\3\2\2\2(\u0141\3\2\2\2*\u0167\3\2\2\2,\u0169\3\2\2\2")
        buf.write(".\u017f\3\2\2\2\60\u0183\3\2\2\2\62\u0190\3\2\2\2\64\u0196")
        buf.write("\3\2\2\2\66\u0198\3\2\2\28\u019f\3\2\2\2:\u01a4\3\2\2")
        buf.write("\2<\u01ab\3\2\2\2>\u01b0\3\2\2\2@\u01b2\3\2\2\2B\u01b5")
        buf.write("\3\2\2\2D\u01b9\3\2\2\2F\u01bb\3\2\2\2H\u01be\3\2\2\2")
        buf.write("J\u01cc\3\2\2\2L\u01d0\3\2\2\2N\u01d8\3\2\2\2P\u01da\3")
        buf.write("\2\2\2R\u01e2\3\2\2\2T\u01ea\3\2\2\2V\u01f2\3\2\2\2X\u01fa")
        buf.write("\3\2\2\2Z\u0202\3\2\2\2\\\u020a\3\2\2\2^\u021a\3\2\2\2")
        buf.write("`\u022a\3\2\2\2b\u022e\3\2\2\2d\u0230\3\2\2\2f\u0233\3")
        buf.write("\2\2\2h\u0247\3\2\2\2j\u02dd\3\2\2\2l\u02df\3\2\2\2n\u031c")
        buf.write("\3\2\2\2p\u0335\3\2\2\2r\u0337\3\2\2\2t\u0343\3\2\2\2")
        buf.write("v\u0350\3\2\2\2x\u035b\3\2\2\2z\u03bf\3\2\2\2|\u03ce\3")
        buf.write("\2\2\2~\u03de\3\2\2\2\u0080\u03e7\3\2\2\2\u0082\u03f0")
        buf.write("\3\2\2\2\u0084\u03f2\3\2\2\2\u0086\u03f4\3\2\2\2\u0088")
        buf.write("\u03f6\3\2\2\2\u008a\u03f8\3\2\2\2\u008c\u03fa\3\2\2\2")
        buf.write("\u008e\u0090\5\4\3\2\u008f\u008e\3\2\2\2\u008f\u0090\3")
        buf.write("\2\2\2\u0090\u0091\3\2\2\2\u0091\u0092\7\2\2\3\u0092\3")
        buf.write("\3\2\2\2\u0093\u0095\5\6\4\2\u0094\u0096\7\u03ab\2\2\u0095")
        buf.write("\u0094\3\2\2\2\u0095\u0096\3\2\2\2\u0096\u0097\3\2\2\2")
        buf.write("\u0097\u0098\7\u03bb\2\2\u0098\u009b\3\2\2\2\u0099\u009b")
        buf.write("\5\b\5\2\u009a\u0093\3\2\2\2\u009a\u0099\3\2\2\2\u009b")
        buf.write("\u009e\3\2\2\2\u009c\u009a\3\2\2\2\u009c\u009d\3\2\2\2")
        buf.write("\u009d\u00a7\3\2\2\2\u009e\u009c\3\2\2\2\u009f\u00a4\5")
        buf.write("\6\4\2\u00a0\u00a2\7\u03ab\2\2\u00a1\u00a0\3\2\2\2\u00a1")
        buf.write("\u00a2\3\2\2\2\u00a2\u00a3\3\2\2\2\u00a3\u00a5\7\u03bb")
        buf.write("\2\2\u00a4\u00a1\3\2\2\2\u00a4\u00a5\3\2\2\2\u00a5\u00a8")
        buf.write("\3\2\2\2\u00a6\u00a8\5\b\5\2\u00a7\u009f\3\2\2\2\u00a7")
        buf.write("\u00a6\3\2\2\2\u00a8\5\3\2\2\2\u00a9\u00aa\5\n\6\2\u00aa")
        buf.write("\7\3\2\2\2\u00ab\u00ac\7\u03bb\2\2\u00ac\t\3\2\2\2\u00ad")
        buf.write("\u00ae\5\24\13\2\u00ae\13\3\2\2\2\u00af\u00b4\7\u00e8")
        buf.write("\2\2\u00b0\u00b4\5B\"\2\u00b1\u00b4\5@!\2\u00b2\u00b4")
        buf.write("\5v<\2\u00b3\u00af\3\2\2\2\u00b3\u00b0\3\2\2\2\u00b3\u00b1")
        buf.write("\3\2\2\2\u00b3\u00b2\3\2\2\2\u00b4\r\3\2\2\2\u00b5\u00b6")
        buf.write("\7\u03aa\2\2\u00b6\u00b9\7L\2\2\u00b7\u00ba\5@!\2\u00b8")
        buf.write("\u00ba\5v<\2\u00b9\u00b7\3\2\2\2\u00b9\u00b8\3\2\2\2\u00ba")
        buf.write("\u00bb\3\2\2\2\u00bb\u00bc\5\20\t\2\u00bc\17\3\2\2\2\u00bd")
        buf.write("\u00cb\5\u0086D\2\u00be\u00cb\7\u00bc\2\2\u00bf\u00cb")
        buf.write("\7\u00cb\2\2\u00c0\u00cb\7\u00cc\2\2\u00c1\u00cb\7\u00cd")
        buf.write("\2\2\u00c2\u00cb\7\u00ce\2\2\u00c3\u00cb\7\u00cf\2\2\u00c4")
        buf.write("\u00cb\7\u00d0\2\2\u00c5\u00cb\7\u00d1\2\2\u00c6\u00cb")
        buf.write("\7\u00d2\2\2\u00c7\u00cb\7\u00d3\2\2\u00c8\u00cb\7\u00d4")
        buf.write("\2\2\u00c9\u00cb\7\u00d5\2\2\u00ca\u00bd\3\2\2\2\u00ca")
        buf.write("\u00be\3\2\2\2\u00ca\u00bf\3\2\2\2\u00ca\u00c0\3\2\2\2")
        buf.write("\u00ca\u00c1\3\2\2\2\u00ca\u00c2\3\2\2\2\u00ca\u00c3\3")
        buf.write("\2\2\2\u00ca\u00c4\3\2\2\2\u00ca\u00c5\3\2\2\2\u00ca\u00c6")
        buf.write("\3\2\2\2\u00ca\u00c7\3\2\2\2\u00ca\u00c8\3\2\2\2\u00ca")
        buf.write("\u00c9\3\2\2\2\u00cb\21\3\2\2\2\u00cc\u00cd\5:\36\2\u00cd")
        buf.write("\u00ce\5L\'\2\u00ce\23\3\2\2\2\u00cf\u00d2\5$\23\2\u00d0")
        buf.write("\u00d2\5\"\22\2\u00d1\u00cf\3\2\2\2\u00d1\u00d0\3\2\2")
        buf.write("\2\u00d2\25\3\2\2\2\u00d3\u00d4\7m\2\2\u00d4\u00d5\7\22")
        buf.write("\2\2\u00d5\u00da\5\30\r\2\u00d6\u00d7\7\u03ba\2\2\u00d7")
        buf.write("\u00d9\5\30\r\2\u00d8\u00d6\3\2\2\2\u00d9\u00dc\3\2\2")
        buf.write("\2\u00da\u00d8\3\2\2\2\u00da\u00db\3\2\2\2\u00db\27\3")
        buf.write("\2\2\2\u00dc\u00da\3\2\2\2\u00dd\u00df\5v<\2\u00de\u00e0")
        buf.write("\t\2\2\2\u00df\u00de\3\2\2\2\u00df\u00e0\3\2\2\2\u00e0")
        buf.write("\31\3\2\2\2\u00e1\u00e6\5\34\17\2\u00e2\u00e3\7\u03ba")
        buf.write("\2\2\u00e3\u00e5\5\34\17\2\u00e4\u00e2\3\2\2\2\u00e5\u00e8")
        buf.write("\3\2\2\2\u00e6\u00e4\3\2\2\2\u00e6\u00e7\3\2\2\2\u00e7")
        buf.write("\33\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e9\u00ed\5\36\20\2")
        buf.write("\u00ea\u00ec\5 \21\2\u00eb\u00ea\3\2\2\2\u00ec\u00ef\3")
        buf.write("\2\2\2\u00ed\u00eb\3\2\2\2\u00ed\u00ee\3\2\2\2\u00ee\u00f5")
        buf.write("\3\2\2\2\u00ef\u00ed\3\2\2\2\u00f0\u00f1\7\u03b8\2\2\u00f1")
        buf.write("\u00f2\5\34\17\2\u00f2\u00f3\7\u03b9\2\2\u00f3\u00f5\3")
        buf.write("\2\2\2\u00f4\u00e9\3\2\2\2\u00f4\u00f0\3\2\2\2\u00f5\35")
        buf.write("\3\2\2\2\u00f6\u00fb\5\64\33\2\u00f7\u00f9\7\r\2\2\u00f8")
        buf.write("\u00f7\3\2\2\2\u00f8\u00f9\3\2\2\2\u00f9\u00fa\3\2\2\2")
        buf.write("\u00fa\u00fc\5:\36\2\u00fb\u00f8\3\2\2\2\u00fb\u00fc\3")
        buf.write("\2\2\2\u00fc\u010a\3\2\2\2\u00fd\u0103\5\24\13\2\u00fe")
        buf.write("\u00ff\7\u03b8\2\2\u00ff\u0100\5\24\13\2\u0100\u0101\7")
        buf.write("\u03b9\2\2\u0101\u0103\3\2\2\2\u0102\u00fd\3\2\2\2\u0102")
        buf.write("\u00fe\3\2\2\2\u0103\u0105\3\2\2\2\u0104\u0106\7\r\2\2")
        buf.write("\u0105\u0104\3\2\2\2\u0105\u0106\3\2\2\2\u0106\u0107\3")
        buf.write("\2\2\2\u0107\u0108\5:\36\2\u0108\u010a\3\2\2\2\u0109\u00f6")
        buf.write("\3\2\2\2\u0109\u0102\3\2\2\2\u010a\37\3\2\2\2\u010b\u010d")
        buf.write("\t\3\2\2\u010c\u010b\3\2\2\2\u010c\u010d\3\2\2\2\u010d")
        buf.write("\u010e\3\2\2\2\u010e\u010f\7P\2\2\u010f\u0112\5\36\20")
        buf.write("\2\u0110\u0111\7h\2\2\u0111\u0113\5v<\2\u0112\u0110\3")
        buf.write("\2\2\2\u0112\u0113\3\2\2\2\u0113\u0124\3\2\2\2\u0114\u0115")
        buf.write("\7\u0094\2\2\u0115\u0118\5\36\20\2\u0116\u0117\7h\2\2")
        buf.write("\u0117\u0119\5v<\2\u0118\u0116\3\2\2\2\u0118\u0119\3\2")
        buf.write("\2\2\u0119\u0124\3\2\2\2\u011a\u011c\t\4\2\2\u011b\u011d")
        buf.write("\7o\2\2\u011c\u011b\3\2\2\2\u011c\u011d\3\2\2\2\u011d")
        buf.write("\u011e\3\2\2\2\u011e\u011f\7P\2\2\u011f\u0120\5\36\20")
        buf.write("\2\u0120\u0121\7h\2\2\u0121\u0122\5v<\2\u0122\u0124\3")
        buf.write("\2\2\2\u0123\u010c\3\2\2\2\u0123\u0114\3\2\2\2\u0123\u011a")
        buf.write("\3\2\2\2\u0124!\3\2\2\2\u0125\u0126\7\u03b8\2\2\u0126")
        buf.write("\u0127\5$\23\2\u0127\u0128\7\u03b9\2\2\u0128\u012e\3\2")
        buf.write("\2\2\u0129\u012a\7\u03b8\2\2\u012a\u012b\5\"\22\2\u012b")
        buf.write("\u012c\7\u03b9\2\2\u012c\u012e\3\2\2\2\u012d\u0125\3\2")
        buf.write("\2\2\u012d\u0129\3\2\2\2\u012e#\3\2\2\2\u012f\u0131\7")
        buf.write("\u0086\2\2\u0130\u0132\5&\24\2\u0131\u0130\3\2\2\2\u0131")
        buf.write("\u0132\3\2\2\2\u0132\u0133\3\2\2\2\u0133\u0135\5(\25\2")
        buf.write("\u0134\u0136\5,\27\2\u0135\u0134\3\2\2\2\u0135\u0136\3")
        buf.write("\2\2\2\u0136\u0138\3\2\2\2\u0137\u0139\5\26\f\2\u0138")
        buf.write("\u0137\3\2\2\2\u0138\u0139\3\2\2\2\u0139\u013b\3\2\2\2")
        buf.write("\u013a\u013c\5\60\31\2\u013b\u013a\3\2\2\2\u013b\u013c")
        buf.write("\3\2\2\2\u013c%\3\2\2\2\u013d\u013e\t\5\2\2\u013e\'\3")
        buf.write("\2\2\2\u013f\u0142\7\u03a7\2\2\u0140\u0142\5*\26\2\u0141")
        buf.write("\u013f\3\2\2\2\u0141\u0140\3\2\2\2\u0142\u0147\3\2\2\2")
        buf.write("\u0143\u0144\7\u03ba\2\2\u0144\u0146\5*\26\2\u0145\u0143")
        buf.write("\3\2\2\2\u0146\u0149\3\2\2\2\u0147\u0145\3\2\2\2\u0147")
        buf.write("\u0148\3\2\2\2\u0148)\3\2\2\2\u0149\u0147\3\2\2\2\u014a")
        buf.write("\u014b\5\62\32\2\u014b\u014c\7\u03b7\2\2\u014c\u014d\7")
        buf.write("\u03a7\2\2\u014d\u0168\3\2\2\2\u014e\u0153\5\66\34\2\u014f")
        buf.write("\u0151\7\r\2\2\u0150\u014f\3\2\2\2\u0150\u0151\3\2\2\2")
        buf.write("\u0151\u0152\3\2\2\2\u0152\u0154\5:\36\2\u0153\u0150\3")
        buf.write("\2\2\2\u0153\u0154\3\2\2\2\u0154\u0168\3\2\2\2\u0155\u015a")
        buf.write("\5h\65\2\u0156\u0158\7\r\2\2\u0157\u0156\3\2\2\2\u0157")
        buf.write("\u0158\3\2\2\2\u0158\u0159\3\2\2\2\u0159\u015b\5:\36\2")
        buf.write("\u015a\u0157\3\2\2\2\u015a\u015b\3\2\2\2\u015b\u0168\3")
        buf.write("\2\2\2\u015c\u015d\7\u03d2\2\2\u015d\u015f\7\u039e\2\2")
        buf.write("\u015e\u015c\3\2\2\2\u015e\u015f\3\2\2\2\u015f\u0160\3")
        buf.write("\2\2\2\u0160\u0165\5v<\2\u0161\u0163\7\r\2\2\u0162\u0161")
        buf.write("\3\2\2\2\u0162\u0163\3\2\2\2\u0163\u0164\3\2\2\2\u0164")
        buf.write("\u0166\5:\36\2\u0165\u0162\3\2\2\2\u0165\u0166\3\2\2\2")
        buf.write("\u0166\u0168\3\2\2\2\u0167\u014a\3\2\2\2\u0167\u014e\3")
        buf.write("\2\2\2\u0167\u0155\3\2\2\2\u0167\u015e\3\2\2\2\u0168+")
        buf.write("\3\2\2\2\u0169\u016a\7=\2\2\u016a\u016d\5\32\16\2\u016b")
        buf.write("\u016c\7\u00a7\2\2\u016c\u016e\5v<\2\u016d\u016b\3\2\2")
        buf.write("\2\u016d\u016e\3\2\2\2\u016e\u0179\3\2\2\2\u016f\u0170")
        buf.write("\7A\2\2\u0170\u0171\7\22\2\2\u0171\u0176\5.\30\2\u0172")
        buf.write("\u0173\7\u03ba\2\2\u0173\u0175\5.\30\2\u0174\u0172\3\2")
        buf.write("\2\2\u0175\u0178\3\2\2\2\u0176\u0174\3\2\2\2\u0176\u0177")
        buf.write("\3\2\2\2\u0177\u017a\3\2\2\2\u0178\u0176\3\2\2\2\u0179")
        buf.write("\u016f\3\2\2\2\u0179\u017a\3\2\2\2\u017a\u017d\3\2\2\2")
        buf.write("\u017b\u017c\7B\2\2\u017c\u017e\5v<\2\u017d\u017b\3\2")
        buf.write("\2\2\u017d\u017e\3\2\2\2\u017e-\3\2\2\2\u017f\u0181\5")
        buf.write("v<\2\u0180\u0182\t\2\2\2\u0181\u0180\3\2\2\2\u0181\u0182")
        buf.write("\3\2\2\2\u0182/\3\2\2\2\u0183\u018e\7X\2\2\u0184\u0185")
        buf.write("\5@!\2\u0185\u0186\7\u03ba\2\2\u0186\u0188\3\2\2\2\u0187")
        buf.write("\u0184\3\2\2\2\u0187\u0188\3\2\2\2\u0188\u0189\3\2\2\2")
        buf.write("\u0189\u018f\5@!\2\u018a\u018b\5@!\2\u018b\u018c\7\u01a5")
        buf.write("\2\2\u018c\u018d\5@!\2\u018d\u018f\3\2\2\2\u018e\u0187")
        buf.write("\3\2\2\2\u018e\u018a\3\2\2\2\u018f\61\3\2\2\2\u0190\u0194")
        buf.write("\5:\36\2\u0191\u0195\7\u03ce\2\2\u0192\u0193\7\u03b7\2")
        buf.write("\2\u0193\u0195\5:\36\2\u0194\u0191\3\2\2\2\u0194\u0192")
        buf.write("\3\2\2\2\u0194\u0195\3\2\2\2\u0195\63\3\2\2\2\u0196\u0197")
        buf.write("\5\62\32\2\u0197\65\3\2\2\2\u0198\u019d\5:\36\2\u0199")
        buf.write("\u019b\5> \2\u019a\u019c\5> \2\u019b\u019a\3\2\2\2\u019b")
        buf.write("\u019c\3\2\2\2\u019c\u019e\3\2\2\2\u019d\u0199\3\2\2\2")
        buf.write("\u019d\u019e\3\2\2\2\u019e\67\3\2\2\2\u019f\u01a0\t\6")
        buf.write("\2\2\u01a09\3\2\2\2\u01a1\u01a5\5<\37\2\u01a2\u01a5\7")
        buf.write("\u03d0\2\2\u01a3\u01a5\7\u03c4\2\2\u01a4\u01a1\3\2\2\2")
        buf.write("\u01a4\u01a2\3\2\2\2\u01a4\u01a3\3\2\2\2\u01a5;\3\2\2")
        buf.write("\2\u01a6\u01ac\7\u03cf\2\2\u01a7\u01ac\5\u0086D\2\u01a8")
        buf.write("\u01ac\5\u0088E\2\u01a9\u01ac\5\u008aF\2\u01aa\u01ac\5")
        buf.write("\u008cG\2\u01ab\u01a6\3\2\2\2\u01ab\u01a7\3\2\2\2\u01ab")
        buf.write("\u01a8\3\2\2\2\u01ab\u01a9\3\2\2\2\u01ab\u01aa\3\2\2\2")
        buf.write("\u01ac=\3\2\2\2\u01ad\u01b1\7\u03ce\2\2\u01ae\u01af\7")
        buf.write("\u03b7\2\2\u01af\u01b1\5:\36\2\u01b0\u01ad\3\2\2\2\u01b0")
        buf.write("\u01ae\3\2\2\2\u01b1?\3\2\2\2\u01b2\u01b3\t\7\2\2\u01b3")
        buf.write("A\3\2\2\2\u01b4\u01b6\7\u03c7\2\2\u01b5\u01b4\3\2\2\2")
        buf.write("\u01b6\u01b7\3\2\2\2\u01b7\u01b5\3\2\2\2\u01b7\u01b8\3")
        buf.write("\2\2\2\u01b8C\3\2\2\2\u01b9\u01ba\t\b\2\2\u01baE\3\2\2")
        buf.write("\2\u01bb\u01bc\7\u03c9\2\2\u01bcG\3\2\2\2\u01bd\u01bf")
        buf.write("\7e\2\2\u01be\u01bd\3\2\2\2\u01be\u01bf\3\2\2\2\u01bf")
        buf.write("\u01c0\3\2\2\2\u01c0\u01c1\7g\2\2\u01c1I\3\2\2\2\u01c2")
        buf.write("\u01cd\5B\"\2\u01c3\u01cd\5@!\2\u01c4\u01c5\7\u03ac\2")
        buf.write("\2\u01c5\u01cd\5@!\2\u01c6\u01cd\5F$\2\u01c7\u01cd\5D")
        buf.write("#\2\u01c8\u01ca\7e\2\2\u01c9\u01c8\3\2\2\2\u01c9\u01ca")
        buf.write("\3\2\2\2\u01ca\u01cb\3\2\2\2\u01cb\u01cd\7g\2\2\u01cc")
        buf.write("\u01c2\3\2\2\2\u01cc\u01c3\3\2\2\2\u01cc\u01c4\3\2\2\2")
        buf.write("\u01cc\u01c6\3\2\2\2\u01cc\u01c7\3\2\2\2\u01cc\u01c9\3")
        buf.write("\2\2\2\u01cdK\3\2\2\2\u01ce\u01d1\t\t\2\2\u01cf\u01d1")
        buf.write("\t\n\2\2\u01d0\u01ce\3\2\2\2\u01d0\u01cf\3\2\2\2\u01d1")
        buf.write("M\3\2\2\2\u01d2\u01d9\3\2\2\2\u01d3\u01d9\t\13\2\2\u01d4")
        buf.write("\u01d6\t\f\2\2\u01d5\u01d7\7\u00b1\2\2\u01d6\u01d5\3\2")
        buf.write("\2\2\u01d6\u01d7\3\2\2\2\u01d7\u01d9\3\2\2\2\u01d8\u01d2")
        buf.write("\3\2\2\2\u01d8\u01d3\3\2\2\2\u01d8\u01d4\3\2\2\2\u01d9")
        buf.write("O\3\2\2\2\u01da\u01df\5:\36\2\u01db\u01dc\7\u03ba\2\2")
        buf.write("\u01dc\u01de\5:\36\2\u01dd\u01db\3\2\2\2\u01de\u01e1\3")
        buf.write("\2\2\2\u01df\u01dd\3\2\2\2\u01df\u01e0\3\2\2\2\u01e0Q")
        buf.write("\3\2\2\2\u01e1\u01df\3\2\2\2\u01e2\u01e7\5\64\33\2\u01e3")
        buf.write("\u01e4\7\u03ba\2\2\u01e4\u01e6\5\64\33\2\u01e5\u01e3\3")
        buf.write("\2\2\2\u01e6\u01e9\3\2\2\2\u01e7\u01e5\3\2\2\2\u01e7\u01e8")
        buf.write("\3\2\2\2\u01e8S\3\2\2\2\u01e9\u01e7\3\2\2\2\u01ea\u01ef")
        buf.write("\5v<\2\u01eb\u01ec\7\u03ba\2\2\u01ec\u01ee\5v<\2\u01ed")
        buf.write("\u01eb\3\2\2\2\u01ee\u01f1\3\2\2\2\u01ef\u01ed\3\2\2\2")
        buf.write("\u01ef\u01f0\3\2\2\2\u01f0U\3\2\2\2\u01f1\u01ef\3\2\2")
        buf.write("\2\u01f2\u01f7\5b\62\2\u01f3\u01f4\7\u03ba\2\2\u01f4\u01f6")
        buf.write("\5b\62\2\u01f5\u01f3\3\2\2\2\u01f6\u01f9\3\2\2\2\u01f7")
        buf.write("\u01f5\3\2\2\2\u01f7\u01f8\3\2\2\2\u01f8W\3\2\2\2\u01f9")
        buf.write("\u01f7\3\2\2\2\u01fa\u01ff\5J&\2\u01fb\u01fc\7\u03ba\2")
        buf.write("\2\u01fc\u01fe\5J&\2\u01fd\u01fb\3\2\2\2\u01fe\u0201\3")
        buf.write("\2\2\2\u01ff\u01fd\3\2\2\2\u01ff\u0200\3\2\2\2\u0200Y")
        buf.write("\3\2\2\2\u0201\u01ff\3\2\2\2\u0202\u0207\7\u03c7\2\2\u0203")
        buf.write("\u0204\7\u03ba\2\2\u0204\u0206\7\u03c7\2\2\u0205\u0203")
        buf.write("\3\2\2\2\u0206\u0209\3\2\2\2\u0207\u0205\3\2\2\2\u0207")
        buf.write("\u0208\3\2\2\2\u0208[\3\2\2\2\u0209\u0207\3\2\2\2\u020a")
        buf.write("\u020f\7\u03d2\2\2\u020b\u020c\7\u03ba\2\2\u020c\u020e")
        buf.write("\7\u03d2\2\2\u020d\u020b\3\2\2\2\u020e\u0211\3\2\2\2\u020f")
        buf.write("\u020d\3\2\2\2\u020f\u0210\3\2\2\2\u0210]\3\2\2\2\u0211")
        buf.write("\u020f\3\2\2\2\u0212\u021b\7g\2\2\u0213\u021b\5J&\2\u0214")
        buf.write("\u0218\5`\61\2\u0215\u0216\7h\2\2\u0216\u0217\7\u00a1")
        buf.write("\2\2\u0217\u0219\5`\61\2\u0218\u0215\3\2\2\2\u0218\u0219")
        buf.write("\3\2\2\2\u0219\u021b\3\2\2\2\u021a\u0212\3\2\2\2\u021a")
        buf.write("\u0213\3\2\2\2\u021a\u0214\3\2\2\2\u021b_\3\2\2\2\u021c")
        buf.write("\u0222\t\r\2\2\u021d\u021f\7\u03b8\2\2\u021e\u0220\5@")
        buf.write("!\2\u021f\u021e\3\2\2\2\u021f\u0220\3\2\2\2\u0220\u0221")
        buf.write("\3\2\2\2\u0221\u0223\7\u03b9\2\2\u0222\u021d\3\2\2\2\u0222")
        buf.write("\u0223\3\2\2\2\u0223\u022b\3\2\2\2\u0224\u0225\7\u00f0")
        buf.write("\2\2\u0225\u0227\7\u03b8\2\2\u0226\u0228\5@!\2\u0227\u0226")
        buf.write("\3\2\2\2\u0227\u0228\3\2\2\2\u0228\u0229\3\2\2\2\u0229")
        buf.write("\u022b\7\u03b9\2\2\u022a\u021c\3\2\2\2\u022a\u0224\3\2")
        buf.write("\2\2\u022ba\3\2\2\2\u022c\u022f\5v<\2\u022d\u022f\7\'")
        buf.write("\2\2\u022e\u022c\3\2\2\2\u022e\u022d\3\2\2\2\u022fc\3")
        buf.write("\2\2\2\u0230\u0231\7D\2\2\u0231\u0232\7\65\2\2\u0232e")
        buf.write("\3\2\2\2\u0233\u0234\7D\2\2\u0234\u0235\7e\2\2\u0235\u0236")
        buf.write("\7\65\2\2\u0236g\3\2\2\2\u0237\u0248\5j\66\2\u0238\u0248")
        buf.write("\5n8\2\u0239\u023a\5p9\2\u023a\u023c\7\u03b8\2\2\u023b")
        buf.write("\u023d\5r:\2\u023c\u023b\3\2\2\2\u023c\u023d\3\2\2\2\u023d")
        buf.write("\u023e\3\2\2\2\u023e\u023f\7\u03b9\2\2\u023f\u0248\3\2")
        buf.write("\2\2\u0240\u0241\5\62\32\2\u0241\u0243\7\u03b8\2\2\u0242")
        buf.write("\u0244\5r:\2\u0243\u0242\3\2\2\2\u0243\u0244\3\2\2\2\u0244")
        buf.write("\u0245\3\2\2\2\u0245\u0246\7\u03b9\2\2\u0246\u0248\3\2")
        buf.write("\2\2\u0247\u0237\3\2\2\2\u0247\u0238\3\2\2\2\u0247\u0239")
        buf.write("\3\2\2\2\u0247\u0240\3\2\2\2\u0248i\3\2\2\2\u0249\u02de")
        buf.write("\t\16\2\2\u024a\u024b\7\37\2\2\u024b\u024c\7\u03b8\2\2")
        buf.write("\u024c\u024d\5v<\2\u024d\u024e\7\u03ba\2\2\u024e\u024f")
        buf.write("\5N(\2\u024f\u0250\7\u03b9\2\2\u0250\u02de\3\2\2\2\u0251")
        buf.write("\u0252\7\37\2\2\u0252\u0253\7\u03b8\2\2\u0253\u0254\5")
        buf.write("v<\2\u0254\u0255\7\u03b9\2\2\u0255\u02de\3\2\2\2\u0256")
        buf.write("\u0257\7\26\2\2\u0257\u0258\7\u03b8\2\2\u0258\u0259\5")
        buf.write("v<\2\u0259\u025a\7\r\2\2\u025a\u025b\5N(\2\u025b\u025c")
        buf.write("\7\u03b9\2\2\u025c\u02de\3\2\2\2\u025d\u025e\7\u00a5\2")
        buf.write("\2\u025e\u025f\7\u03b8\2\2\u025f\u0260\5\66\34\2\u0260")
        buf.write("\u0261\7\u03b9\2\2\u0261\u02de\3\2\2\2\u0262\u0263\7\25")
        buf.write("\2\2\u0263\u0265\5v<\2\u0264\u0266\5l\67\2\u0265\u0264")
        buf.write("\3\2\2\2\u0266\u0267\3\2\2\2\u0267\u0265\3\2\2\2\u0267")
        buf.write("\u0268\3\2\2\2\u0268\u026b\3\2\2\2\u0269\u026a\7\61\2")
        buf.write("\2\u026a\u026c\5t;\2\u026b\u0269\3\2\2\2\u026b\u026c\3")
        buf.write("\2\2\2\u026c\u026d\3\2\2\2\u026d\u026e\7\u0138\2\2\u026e")
        buf.write("\u02de\3\2\2\2\u026f\u0271\7\25\2\2\u0270\u0272\5l\67")
        buf.write("\2\u0271\u0270\3\2\2\2\u0272\u0273\3\2\2\2\u0273\u0271")
        buf.write("\3\2\2\2\u0273\u0274\3\2\2\2\u0274\u0277\3\2\2\2\u0275")
        buf.write("\u0276\7\61\2\2\u0276\u0278\5t;\2\u0277\u0275\3\2\2\2")
        buf.write("\u0277\u0278\3\2\2\2\u0278\u0279\3\2\2\2\u0279\u027a\7")
        buf.write("\u0138\2\2\u027a\u02de\3\2\2\2\u027b\u027c\7\u00bd\2\2")
        buf.write("\u027c\u027d\7\u03b8\2\2\u027d\u027e\5r:\2\u027e\u027f")
        buf.write("\7\u03b9\2\2\u027f\u02de\3\2\2\2\u0280\u0281\7\u00f1\2")
        buf.write("\2\u0281\u0284\7\u03b8\2\2\u0282\u0285\5B\"\2\u0283\u0285")
        buf.write("\5v<\2\u0284\u0282\3\2\2\2\u0284\u0283\3\2\2\2\u0285\u0286")
        buf.write("\3\2\2\2\u0286\u0289\7F\2\2\u0287\u028a\5B\"\2\u0288\u028a")
        buf.write("\5v<\2\u0289\u0287\3\2\2\2\u0289\u0288\3\2\2\2\u028a\u028b")
        buf.write("\3\2\2\2\u028b\u028c\7\u03b9\2\2\u028c\u02de\3\2\2\2\u028d")
        buf.write("\u028e\t\17\2\2\u028e\u0291\7\u03b8\2\2\u028f\u0292\5")
        buf.write("B\"\2\u0290\u0292\5v<\2\u0291\u028f\3\2\2\2\u0291\u0290")
        buf.write("\3\2\2\2\u0292\u0293\3\2\2\2\u0293\u0296\7=\2\2\u0294")
        buf.write("\u0297\5@!\2\u0295\u0297\5v<\2\u0296\u0294\3\2\2\2\u0296")
        buf.write("\u0295\3\2\2\2\u0297\u029d\3\2\2\2\u0298\u029b\7:\2\2")
        buf.write("\u0299\u029c\5@!\2\u029a\u029c\5v<\2\u029b\u0299\3\2\2")
        buf.write("\2\u029b\u029a\3\2\2\2\u029c\u029e\3\2\2\2\u029d\u0298")
        buf.write("\3\2\2\2\u029d\u029e\3\2\2\2\u029e\u029f\3\2\2\2\u029f")
        buf.write("\u02a0\7\u03b9\2\2\u02a0\u02de\3\2\2\2\u02a1\u02a2\7\u00f5")
        buf.write("\2\2\u02a2\u02a3\7\u03b8\2\2\u02a3\u02a6\t\20\2\2\u02a4")
        buf.write("\u02a7\5B\"\2\u02a5\u02a7\5v<\2\u02a6\u02a4\3\2\2\2\u02a6")
        buf.write("\u02a5\3\2\2\2\u02a6\u02a7\3\2\2\2\u02a7\u02a8\3\2\2\2")
        buf.write("\u02a8\u02ab\7=\2\2\u02a9\u02ac\5B\"\2\u02aa\u02ac\5v")
        buf.write("<\2\u02ab\u02a9\3\2\2\2\u02ab\u02aa\3\2\2\2\u02ac\u02ad")
        buf.write("\3\2\2\2\u02ad\u02ae\7\u03b9\2\2\u02ae\u02de\3\2\2\2\u02af")
        buf.write("\u02b0\7\u00f5\2\2\u02b0\u02b3\7\u03b8\2\2\u02b1\u02b4")
        buf.write("\5B\"\2\u02b2\u02b4\5v<\2\u02b3\u02b1\3\2\2\2\u02b3\u02b2")
        buf.write("\3\2\2\2\u02b4\u02b5\3\2\2\2\u02b5\u02b8\7=\2\2\u02b6")
        buf.write("\u02b9\5B\"\2\u02b7\u02b9\5v<\2\u02b8\u02b6\3\2\2\2\u02b8")
        buf.write("\u02b7\3\2\2\2\u02b9\u02ba\3\2\2\2\u02ba\u02bb\7\u03b9")
        buf.write("\2\2\u02bb\u02de\3\2\2\2\u02bc\u02bd\7\u0399\2\2\u02bd")
        buf.write("\u02c0\7\u03b8\2\2\u02be\u02c1\5B\"\2\u02bf\u02c1\5v<")
        buf.write("\2\u02c0\u02be\3\2\2\2\u02c0\u02bf\3\2\2\2\u02c1\u02c8")
        buf.write("\3\2\2\2\u02c2\u02c3\7\r\2\2\u02c3\u02c4\t\21\2\2\u02c4")
        buf.write("\u02c5\7\u03b8\2\2\u02c5\u02c6\5@!\2\u02c6\u02c7\7\u03b9")
        buf.write("\2\2\u02c7\u02c9\3\2\2\2\u02c8\u02c2\3\2\2\2\u02c8\u02c9")
        buf.write("\3\2\2\2\u02c9\u02ca\3\2\2\2\u02ca\u02cb\7\u03b9\2\2\u02cb")
        buf.write("\u02de\3\2\2\2\u02cc\u02cd\7\u00ee\2\2\u02cd\u02ce\7\u03b8")
        buf.write("\2\2\u02ce\u02cf\5\20\t\2\u02cf\u02d2\7=\2\2\u02d0\u02d3")
        buf.write("\5B\"\2\u02d1\u02d3\5v<\2\u02d2\u02d0\3\2\2\2\u02d2\u02d1")
        buf.write("\3\2\2\2\u02d3\u02d4\3\2\2\2\u02d4\u02d5\7\u03b9\2\2\u02d5")
        buf.write("\u02de\3\2\2\2\u02d6\u02d7\7\u02d2\2\2\u02d7\u02d8\7\u03b8")
        buf.write("\2\2\u02d8\u02d9\t\13\2\2\u02d9\u02da\7\u03ba\2\2\u02da")
        buf.write("\u02db\5B\"\2\u02db\u02dc\7\u03b9\2\2\u02dc\u02de\3\2")
        buf.write("\2\2\u02dd\u0249\3\2\2\2\u02dd\u024a\3\2\2\2\u02dd\u0251")
        buf.write("\3\2\2\2\u02dd\u0256\3\2\2\2\u02dd\u025d\3\2\2\2\u02dd")
        buf.write("\u0262\3\2\2\2\u02dd\u026f\3\2\2\2\u02dd\u027b\3\2\2\2")
        buf.write("\u02dd\u0280\3\2\2\2\u02dd\u028d\3\2\2\2\u02dd\u02a1\3")
        buf.write("\2\2\2\u02dd\u02af\3\2\2\2\u02dd\u02bc\3\2\2\2\u02dd\u02cc")
        buf.write("\3\2\2\2\u02dd\u02d6\3\2\2\2\u02dek\3\2\2\2\u02df\u02e0")
        buf.write("\7\u00a6\2\2\u02e0\u02e1\5t;\2\u02e1\u02e2\7\u0097\2\2")
        buf.write("\u02e2\u02e3\5t;\2\u02e3m\3\2\2\2\u02e4\u02e5\t\22\2\2")
        buf.write("\u02e5\u02e7\7\u03b8\2\2\u02e6\u02e8\t\23\2\2\u02e7\u02e6")
        buf.write("\3\2\2\2\u02e7\u02e8\3\2\2\2\u02e8\u02e9\3\2\2\2\u02e9")
        buf.write("\u02ea\5t;\2\u02ea\u02eb\7\u03b9\2\2\u02eb\u031d\3\2\2")
        buf.write("\2\u02ec\u02ed\7\u00da\2\2\u02ed\u02f3\7\u03b8\2\2\u02ee")
        buf.write("\u02f4\7\u03a7\2\2\u02ef\u02f1\7\b\2\2\u02f0\u02ef\3\2")
        buf.write("\2\2\u02f0\u02f1\3\2\2\2\u02f1\u02f2\3\2\2\2\u02f2\u02f4")
        buf.write("\5t;\2\u02f3\u02ee\3\2\2\2\u02f3\u02f0\3\2\2\2\u02f4\u02f5")
        buf.write("\3\2\2\2\u02f5\u031d\7\u03b9\2\2\u02f6\u02f7\7\u00da\2")
        buf.write("\2\u02f7\u02f8\7\u03b8\2\2\u02f8\u02f9\7-\2\2\u02f9\u02fa")
        buf.write("\5r:\2\u02fa\u02fb\7\u03b9\2\2\u02fb\u031d\3\2\2\2\u02fc")
        buf.write("\u02fd\t\24\2\2\u02fd\u02ff\7\u03b8\2\2\u02fe\u0300\7")
        buf.write("\b\2\2\u02ff\u02fe\3\2\2\2\u02ff\u0300\3\2\2\2\u0300\u0301")
        buf.write("\3\2\2\2\u0301\u0302\5t;\2\u0302\u0303\7\u03b9\2\2\u0303")
        buf.write("\u031d\3\2\2\2\u0304\u0305\7\u00db\2\2\u0305\u0307\7\u03b8")
        buf.write("\2\2\u0306\u0308\7-\2\2\u0307\u0306\3\2\2\2\u0307\u0308")
        buf.write("\3\2\2\2\u0308\u0309\3\2\2\2\u0309\u0314\5r:\2\u030a\u030b")
        buf.write("\7m\2\2\u030b\u030c\7\22\2\2\u030c\u0311\5\30\r\2\u030d")
        buf.write("\u030e\7\u03ba\2\2\u030e\u0310\5\30\r\2\u030f\u030d\3")
        buf.write("\2\2\2\u0310\u0313\3\2\2\2\u0311\u030f\3\2\2\2\u0311\u0312")
        buf.write("\3\2\2\2\u0312\u0315\3\2\2\2\u0313\u0311\3\2\2\2\u0314")
        buf.write("\u030a\3\2\2\2\u0314\u0315\3\2\2\2\u0315\u0318\3\2\2\2")
        buf.write("\u0316\u0317\7\u0088\2\2\u0317\u0319\7\u03c7\2\2\u0318")
        buf.write("\u0316\3\2\2\2\u0318\u0319\3\2\2\2\u0319\u031a\3\2\2\2")
        buf.write("\u031a\u031b\7\u03b9\2\2\u031b\u031d\3\2\2\2\u031c\u02e4")
        buf.write("\3\2\2\2\u031c\u02ec\3\2\2\2\u031c\u02f6\3\2\2\2\u031c")
        buf.write("\u02fc\3\2\2\2\u031c\u0304\3\2\2\2\u031do\3\2\2\2\u031e")
        buf.write("\u0336\5\u008cG\2\u031f\u0336\7\u023f\2\2\u0320\u0336")
        buf.write("\7\u00ea\2\2\u0321\u0336\7\u00e6\2\2\u0322\u0336\7\u00e7")
        buf.write("\2\2\u0323\u0336\7\u00e8\2\2\u0324\u0336\7\u00eb\2\2\u0325")
        buf.write("\u0336\7\u00ec\2\2\u0326\u0336\7\u00ed\2\2\u0327\u0336")
        buf.write("\7D\2\2\u0328\u0336\7K\2\2\u0329\u0336\7\u00e9\2\2\u032a")
        buf.write("\u0336\7\u00ef\2\2\u032b\u0336\7\u0195\2\2\u032c\u0336")
        buf.write("\7\u00f0\2\2\u032d\u0336\7}\2\2\u032e\u0336\7\u00f2\2")
        buf.write("\2\u032f\u0336\7\u00f3\2\2\u0330\u0336\7\u00f4\2\2\u0331")
        buf.write("\u0336\7\u00f5\2\2\u0332\u0336\7\u00f6\2\2\u0333\u0336")
        buf.write("\7\u00f7\2\2\u0334\u0336\7\u00f8\2\2\u0335\u031e\3\2\2")
        buf.write("\2\u0335\u031f\3\2\2\2\u0335\u0320\3\2\2\2\u0335\u0321")
        buf.write("\3\2\2\2\u0335\u0322\3\2\2\2\u0335\u0323\3\2\2\2\u0335")
        buf.write("\u0324\3\2\2\2\u0335\u0325\3\2\2\2\u0335\u0326\3\2\2\2")
        buf.write("\u0335\u0327\3\2\2\2\u0335\u0328\3\2\2\2\u0335\u0329\3")
        buf.write("\2\2\2\u0335\u032a\3\2\2\2\u0335\u032b\3\2\2\2\u0335\u032c")
        buf.write("\3\2\2\2\u0335\u032d\3\2\2\2\u0335\u032e\3\2\2\2\u0335")
        buf.write("\u032f\3\2\2\2\u0335\u0330\3\2\2\2\u0335\u0331\3\2\2\2")
        buf.write("\u0335\u0332\3\2\2\2\u0335\u0333\3\2\2\2\u0335\u0334\3")
        buf.write("\2\2\2\u0336q\3\2\2\2\u0337\u033c\5t;\2\u0338\u0339\7")
        buf.write("\u03ba\2\2\u0339\u033b\5t;\2\u033a\u0338\3\2\2\2\u033b")
        buf.write("\u033e\3\2\2\2\u033c\u033a\3\2\2\2\u033c\u033d\3\2\2\2")
        buf.write("\u033ds\3\2\2\2\u033e\u033c\3\2\2\2\u033f\u0344\5J&\2")
        buf.write("\u0340\u0344\5\66\34\2\u0341\u0344\5h\65\2\u0342\u0344")
        buf.write("\5v<\2\u0343\u033f\3\2\2\2\u0343\u0340\3\2\2\2\u0343\u0341")
        buf.write("\3\2\2\2\u0343\u0342\3\2\2\2\u0344u\3\2\2\2\u0345\u0346")
        buf.write("\b<\1\2\u0346\u0347\t\25\2\2\u0347\u0351\5v<\6\u0348\u0349")
        buf.write("\5x=\2\u0349\u034b\7N\2\2\u034a\u034c\7e\2\2\u034b\u034a")
        buf.write("\3\2\2\2\u034b\u034c\3\2\2\2\u034c\u034d\3\2\2\2\u034d")
        buf.write("\u034e\t\26\2\2\u034e\u0351\3\2\2\2\u034f\u0351\5x=\2")
        buf.write("\u0350\u0345\3\2\2\2\u0350\u0348\3\2\2\2\u0350\u034f\3")
        buf.write("\2\2\2\u0351\u0358\3\2\2\2\u0352\u0353\f\5\2\2\u0353\u0354")
        buf.write("\5\u0080A\2\u0354\u0355\5v<\6\u0355\u0357\3\2\2\2\u0356")
        buf.write("\u0352\3\2\2\2\u0357\u035a\3\2\2\2\u0358\u0356\3\2\2\2")
        buf.write("\u0358\u0359\3\2\2\2\u0359w\3\2\2\2\u035a\u0358\3\2\2")
        buf.write("\2\u035b\u035e\b=\1\2\u035c\u035d\7\u03d2\2\2\u035d\u035f")
        buf.write("\7\u039e\2\2\u035e\u035c\3\2\2\2\u035e\u035f\3\2\2\2\u035f")
        buf.write("\u0360\3\2\2\2\u0360\u0361\5z>\2\u0361\u039b\3\2\2\2\u0362")
        buf.write("\u0363\f\t\2\2\u0363\u0364\5~@\2\u0364\u0365\5x=\n\u0365")
        buf.write("\u039a\3\2\2\2\u0366\u0368\f\7\2\2\u0367\u0369\7e\2\2")
        buf.write("\u0368\u0367\3\2\2\2\u0368\u0369\3\2\2\2\u0369\u036a\3")
        buf.write("\2\2\2\u036a\u036b\7\20\2\2\u036b\u036c\5x=\2\u036c\u036d")
        buf.write("\7\f\2\2\u036d\u036e\5x=\b\u036e\u039a\3\2\2\2\u036f\u0370")
        buf.write("\f\6\2\2\u0370\u0371\7\u01f0\2\2\u0371\u0372\7W\2\2\u0372")
        buf.write("\u039a\5x=\7\u0373\u0375\f\4\2\2\u0374\u0376\7e\2\2\u0375")
        buf.write("\u0374\3\2\2\2\u0375\u0376\3\2\2\2\u0376\u0377\3\2\2\2")
        buf.write("\u0377\u0378\t\27\2\2\u0378\u039a\5x=\5\u0379\u037b\f")
        buf.write("\13\2\2\u037a\u037c\7e\2\2\u037b\u037a\3\2\2\2\u037b\u037c")
        buf.write("\3\2\2\2\u037c\u037d\3\2\2\2\u037d\u037e\7F\2\2\u037e")
        buf.write("\u0381\7\u03b8\2\2\u037f\u0382\5\24\13\2\u0380\u0382\5")
        buf.write("T+\2\u0381\u037f\3\2\2\2\u0381\u0380\3\2\2\2\u0382\u0383")
        buf.write("\3\2\2\2\u0383\u0384\7\u03b9\2\2\u0384\u039a\3\2\2\2\u0385")
        buf.write("\u0386\f\n\2\2\u0386\u0387\7N\2\2\u0387\u039a\5H%\2\u0388")
        buf.write("\u0389\f\b\2\2\u0389\u038a\5~@\2\u038a\u038b\t\30\2\2")
        buf.write("\u038b\u038c\7\u03b8\2\2\u038c\u038d\5\24\13\2\u038d\u038e")
        buf.write("\7\u03b9\2\2\u038e\u039a\3\2\2\2\u038f\u0391\f\5\2\2\u0390")
        buf.write("\u0392\7e\2\2\u0391\u0390\3\2\2\2\u0391\u0392\3\2\2\2")
        buf.write("\u0392\u0393\3\2\2\2\u0393\u0394\7W\2\2\u0394\u0397\5")
        buf.write("x=\2\u0395\u0396\7\u013e\2\2\u0396\u0398\7\u03c7\2\2\u0397")
        buf.write("\u0395\3\2\2\2\u0397\u0398\3\2\2\2\u0398\u039a\3\2\2\2")
        buf.write("\u0399\u0362\3\2\2\2\u0399\u0366\3\2\2\2\u0399\u036f\3")
        buf.write("\2\2\2\u0399\u0373\3\2\2\2\u0399\u0379\3\2\2\2\u0399\u0385")
        buf.write("\3\2\2\2\u0399\u0388\3\2\2\2\u0399\u038f\3\2\2\2\u039a")
        buf.write("\u039d\3\2\2\2\u039b\u0399\3\2\2\2\u039b\u039c\3\2\2\2")
        buf.write("\u039cy\3\2\2\2\u039d\u039b\3\2\2\2\u039e\u039f\b>\1\2")
        buf.write("\u039f\u03c0\5J&\2\u03a0\u03c0\5\66\34\2\u03a1\u03c0\5")
        buf.write("h\65\2\u03a2\u03a3\5|?\2\u03a3\u03a4\5z>\n\u03a4\u03c0")
        buf.write("\3\2\2\2\u03a5\u03a6\7\u00bf\2\2\u03a6\u03c0\5z>\t\u03a7")
        buf.write("\u03a8\7\u03b8\2\2\u03a8\u03ad\5v<\2\u03a9\u03aa\7\u03ba")
        buf.write("\2\2\u03aa\u03ac\5v<\2\u03ab\u03a9\3\2\2\2\u03ac\u03af")
        buf.write("\3\2\2\2\u03ad\u03ab\3\2\2\2\u03ad\u03ae\3\2\2\2\u03ae")
        buf.write("\u03b0\3\2\2\2\u03af\u03ad\3\2\2\2\u03b0\u03b1\7\u03b9")
        buf.write("\2\2\u03b1\u03c0\3\2\2\2\u03b2\u03b3\7\65\2\2\u03b3\u03b4")
        buf.write("\7\u03b8\2\2\u03b4\u03b5\5\24\13\2\u03b5\u03b6\7\u03b9")
        buf.write("\2\2\u03b6\u03c0\3\2\2\2\u03b7\u03b8\7\u03b8\2\2\u03b8")
        buf.write("\u03b9\5\24\13\2\u03b9\u03ba\7\u03b9\2\2\u03ba\u03c0\3")
        buf.write("\2\2\2\u03bb\u03bc\7L\2\2\u03bc\u03bd\5v<\2\u03bd\u03be")
        buf.write("\5\20\t\2\u03be\u03c0\3\2\2\2\u03bf\u039e\3\2\2\2\u03bf")
        buf.write("\u03a0\3\2\2\2\u03bf\u03a1\3\2\2\2\u03bf\u03a2\3\2\2\2")
        buf.write("\u03bf\u03a5\3\2\2\2\u03bf\u03a7\3\2\2\2\u03bf\u03b2\3")
        buf.write("\2\2\2\u03bf\u03b7\3\2\2\2\u03bf\u03bb\3\2\2\2\u03c0\u03cb")
        buf.write("\3\2\2\2\u03c1\u03c2\f\4\2\2\u03c2\u03c3\5\u0082B\2\u03c3")
        buf.write("\u03c4\5z>\5\u03c4\u03ca\3\2\2\2\u03c5\u03c6\f\3\2\2\u03c6")
        buf.write("\u03c7\5\u0084C\2\u03c7\u03c8\5z>\4\u03c8\u03ca\3\2\2")
        buf.write("\2\u03c9\u03c1\3\2\2\2\u03c9\u03c5\3\2\2\2\u03ca\u03cd")
        buf.write("\3\2\2\2\u03cb\u03c9\3\2\2\2\u03cb\u03cc\3\2\2\2\u03cc")
        buf.write("{\3\2\2\2\u03cd\u03cb\3\2\2\2\u03ce\u03cf\t\31\2\2\u03cf")
        buf.write("}\3\2\2\2\u03d0\u03df\7\u03af\2\2\u03d1\u03df\7\u03b0")
        buf.write("\2\2\u03d2\u03df\7\u03b1\2\2\u03d3\u03d4\7\u03b1\2\2\u03d4")
        buf.write("\u03df\7\u03af\2\2\u03d5\u03d6\7\u03b0\2\2\u03d6\u03df")
        buf.write("\7\u03af\2\2\u03d7\u03d8\7\u03b1\2\2\u03d8\u03df\7\u03b0")
        buf.write("\2\2\u03d9\u03da\7\u03b2\2\2\u03da\u03df\7\u03af\2\2\u03db")
        buf.write("\u03dc\7\u03b1\2\2\u03dc\u03dd\7\u03af\2\2\u03dd\u03df")
        buf.write("\7\u03b0\2\2\u03de\u03d0\3\2\2\2\u03de\u03d1\3\2\2\2\u03de")
        buf.write("\u03d2\3\2\2\2\u03de\u03d3\3\2\2\2\u03de\u03d5\3\2\2\2")
        buf.write("\u03de\u03d7\3\2\2\2\u03de\u03d9\3\2\2\2\u03de\u03db\3")
        buf.write("\2\2\2\u03df\177\3\2\2\2\u03e0\u03e8\7\f\2\2\u03e1\u03e2")
        buf.write("\7\u03b5\2\2\u03e2\u03e8\7\u03b5\2\2\u03e3\u03e8\7\u00ab")
        buf.write("\2\2\u03e4\u03e8\7l\2\2\u03e5\u03e6\7\u03b4\2\2\u03e6")
        buf.write("\u03e8\7\u03b4\2\2\u03e7\u03e0\3\2\2\2\u03e7\u03e1\3\2")
        buf.write("\2\2\u03e7\u03e3\3\2\2\2\u03e7\u03e4\3\2\2\2\u03e7\u03e5")
        buf.write("\3\2\2\2\u03e8\u0081\3\2\2\2\u03e9\u03ea\7\u03b1\2\2\u03ea")
        buf.write("\u03f1\7\u03b1\2\2\u03eb\u03ec\7\u03b0\2\2\u03ec\u03f1")
        buf.write("\7\u03b0\2\2\u03ed\u03f1\7\u03b5\2\2\u03ee\u03f1\7\u03b6")
        buf.write("\2\2\u03ef\u03f1\7\u03b4\2\2\u03f0\u03e9\3\2\2\2\u03f0")
        buf.write("\u03eb\3\2\2\2\u03f0\u03ed\3\2\2\2\u03f0\u03ee\3\2\2\2")
        buf.write("\u03f0\u03ef\3\2\2\2\u03f1\u0083\3\2\2\2\u03f2\u03f3\t")
        buf.write("\32\2\2\u03f3\u0085\3\2\2\2\u03f4\u03f5\t\33\2\2\u03f5")
        buf.write("\u0087\3\2\2\2\u03f6\u03f7\t\34\2\2\u03f7\u0089\3\2\2")
        buf.write("\2\u03f8\u03f9\t\35\2\2\u03f9\u008b\3\2\2\2\u03fa\u03fb")
        buf.write("\t\36\2\2\u03fb\u008d\3\2\2\2\u0081\u008f\u0095\u009a")
        buf.write("\u009c\u00a1\u00a4\u00a7\u00b3\u00b9\u00ca\u00d1\u00da")
        buf.write("\u00df\u00e6\u00ed\u00f4\u00f8\u00fb\u0102\u0105\u0109")
        buf.write("\u010c\u0112\u0118\u011c\u0123\u012d\u0131\u0135\u0138")
        buf.write("\u013b\u0141\u0147\u0150\u0153\u0157\u015a\u015e\u0162")
        buf.write("\u0165\u0167\u016d\u0176\u0179\u017d\u0181\u0187\u018e")
        buf.write("\u0194\u019b\u019d\u01a4\u01ab\u01b0\u01b7\u01be\u01c9")
        buf.write("\u01cc\u01d0\u01d6\u01d8\u01df\u01e7\u01ef\u01f7\u01ff")
        buf.write("\u0207\u020f\u0218\u021a\u021f\u0222\u0227\u022a\u022e")
        buf.write("\u023c\u0243\u0247\u0267\u026b\u0273\u0277\u0284\u0289")
        buf.write("\u0291\u0296\u029b\u029d\u02a6\u02ab\u02b3\u02b8\u02c0")
        buf.write("\u02c8\u02d2\u02dd\u02e7\u02f0\u02f3\u02ff\u0307\u0311")
        buf.write("\u0314\u0318\u031c\u0335\u033c\u0343\u034b\u0350\u0358")
        buf.write("\u035e\u0368\u0375\u037b\u0381\u0391\u0397\u0399\u039b")
        buf.write("\u03ad\u03bf\u03c9\u03cb\u03de\u03e7\u03f0")
        return buf.getvalue()


class SqlParser ( Parser ):

    grammarFileName = "SqlParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'ADD'", "<INVALID>", "'ALTER'", "'ALWAYS'", 
                     "'ANALYZE'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'BEFORE'", "<INVALID>", "'BOTH'", "<INVALID>", "'CALL'", 
                     "'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'", "'CHARACTER'", 
                     "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'", 
                     "'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", 
                     "<INVALID>", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", 
                     "'DATABASES'", "<INVALID>", "<INVALID>", "'DELAYED'", 
                     "'DELETE'", "<INVALID>", "'DESCRIBE'", "'DETERMINISTIC'", 
                     "<INVALID>", "<INVALID>", "'DROP'", "'EACH'", "<INVALID>", 
                     "<INVALID>", "'ENCLOSED'", "'ESCAPED'", "<INVALID>", 
                     "'EXIT'", "'EXPLAIN'", "<INVALID>", "'FETCH'", "'FOR'", 
                     "'FORCE'", "'FOREIGN'", "<INVALID>", "'FULLTEXT'", 
                     "'GENERATED'", "'GRANT'", "<INVALID>", "<INVALID>", 
                     "'HIGH_PRIORITY'", "<INVALID>", "'IGNORE'", "<INVALID>", 
                     "'INDEX'", "'INFILE'", "<INVALID>", "'INOUT'", "'INSERT'", 
                     "<INVALID>", "'INTO'", "'IS'", "'ITERATE'", "<INVALID>", 
                     "'KEY'", "'KEYS'", "'KILL'", "'LEADING'", "'LEAVE'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'LINEAR'", 
                     "'LINES'", "'LOAD'", "'LOCK'", "'LOOP'", "'LOW_PRIORITY'", 
                     "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'", 
                     "'MATCH'", "'MAXVALUE'", "'MODIFIES'", "'NATURAL'", 
                     "<INVALID>", "'NO_WRITE_TO_BINLOG'", "<INVALID>", "<INVALID>", 
                     "'OPTIMIZE'", "'OPTION'", "'OPTIONALLY'", "<INVALID>", 
                     "<INVALID>", "'OUT'", "<INVALID>", "'OUTFILE'", "'PARTITION'", 
                     "'PRIMARY'", "'PROCEDURE'", "'PURGE'", "'RANGE'", "'READ'", 
                     "'READS'", "'REFERENCES'", "<INVALID>", "'RELEASE'", 
                     "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESTRICT'", 
                     "'RETURN'", "'REVOKE'", "<INVALID>", "'RLIKE'", "'SCHEMA'", 
                     "'SCHEMAS'", "<INVALID>", "'SET'", "'SEPARATOR'", "'SHOW'", 
                     "'SPATIAL'", "'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'", 
                     "'SQLWARNING'", "'SQL_BIG_RESULT'", "'SQL_CALC_FOUND_ROWS'", 
                     "'SQL_SMALL_RESULT'", "'SSL'", "'STARTING'", "'STRAIGHT_JOIN'", 
                     "'TABLE'", "'TERMINATED'", "<INVALID>", "'TO'", "'TRAILING'", 
                     "'TRIGGER'", "<INVALID>", "'UNDO'", "'UNION'", "'UNIQUE'", 
                     "'UNLOCK'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'", 
                     "'USING'", "<INVALID>", "<INVALID>", "<INVALID>", "'WHILE'", 
                     "<INVALID>", "'WRITE'", "<INVALID>", "<INVALID>", "'TINYINT'", 
                     "'SMALLINT'", "'MEDIUMINT'", "'INT'", "'INTEGER'", 
                     "'BIGINT'", "'REAL'", "'DOUBLE'", "'FLOAT'", "'DECIMAL'", 
                     "'NUMERIC'", "'DATE'", "'TIME'", "'TIMESTAMP'", "'DATETIME'", 
                     "'YEAR'", "'CHAR'", "'VARCHAR'", "'BINARY'", "'VARBINARY'", 
                     "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", "'LONGBLOB'", 
                     "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'", 
                     "'ENUM'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", 
                     "'DAY_MINUTE'", "'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", 
                     "'MINUTE_SECOND'", "'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", 
                     "'HOUR_MICROSECOND'", "'DAY_MICROSECOND'", "'AVG'", 
                     "'BIT_AND'", "'BIT_OR'", "'BIT_XOR'", "<INVALID>", 
                     "'GROUP_CONCAT'", "'MAX'", "'MIN'", "'STD'", "'STDDEV'", 
                     "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", 
                     "'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", "'CURRENT_TIME'", 
                     "'CURRENT_TIMESTAMP'", "'LOCALTIME'", "'CURDATE'", 
                     "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", 
                     "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'", 
                     "'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", 
                     "'UTC_TIME'", "'UTC_TIMESTAMP'", "'ACCOUNT'", "'ACTION'", 
                     "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "<INVALID>", 
                     "'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", 
                     "'AUTO_INCREMENT'", "'AVG_ROW_LENGTH'", "'BEGIN'", 
                     "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'", "'BOOLEAN'", 
                     "'BTREE'", "'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'", 
                     "'CHANNEL'", "'CHECKSUM'", "'CIPHER'", "'CLIENT'", 
                     "'CLOSE'", "'COALESCE'", "'CODE'", "'COLUMNS'", "'COLUMN_FORMAT'", 
                     "'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPLETION'", 
                     "'COMPRESSED'", "'COMPRESSION'", "'CONCURRENT'", "'CONNECTION'", 
                     "'CONSISTENT'", "'CONTAINS'", "'CONTEXT'", "'CONTRIBUTORS'", 
                     "'COPY'", "'CPU'", "'DATA'", "'DATAFILE'", "'DEALLOCATE'", 
                     "'DEFAULT_AUTH'", "'DEFINER'", "'DELAY_KEY_WRITE'", 
                     "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'", "'DISCARD'", 
                     "'DISK'", "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'", 
                     "'ENABLE'", "'ENCRYPTION'", "<INVALID>", "'ENDS'", 
                     "'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'", 
                     "'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", 
                     "'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'", "'EXTENDED'", 
                     "'EXTENT_SIZE'", "'FAST'", "'FAULTS'", "'FIELDS'", 
                     "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'", "'FIXED'", 
                     "'FLUSH'", "'FOLLOWS'", "'FOUND'", "'FULL'", "'FUNCTION'", 
                     "'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'", 
                     "'HANDLER'", "'HASH'", "'HELP'", "'HOST'", "'HOSTS'", 
                     "'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'", 
                     "'INDEXES'", "'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", 
                     "'INSTALL'", "'INSTANCE'", "'INVOKER'", "'IO'", "'IO_THREAD'", 
                     "'IPC'", "'ISOLATION'", "'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", 
                     "'LANGUAGE'", "'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'", 
                     "'LIST'", "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'", 
                     "'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'", 
                     "'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", 
                     "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'", "'MASTER_PASSWORD'", 
                     "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'", 
                     "'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", 
                     "'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", 
                     "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'", "'MASTER_USER'", 
                     "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'", 
                     "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", 
                     "'MAX_USER_CONNECTIONS'", "'MEDIUM'", "'MERGE'", "'MID'", 
                     "'MIGRATE'", "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", 
                     "'MYSQL'", "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", 
                     "'NEXT'", "'NO'", "'NODEGROUP'", "'NONE'", "'OFFLINE'", 
                     "<INVALID>", "'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", 
                     "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'", "'OPTIONS'", 
                     "'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PARSER'", "'PARTIAL'", 
                     "'PARTITIONING'", "'PARTITIONS'", "'PASSWORD'", "'PHASE'", 
                     "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", 
                     "'PRECEDES'", "'PREPARE'", "'PRESERVE'", "'PREV'", 
                     "'PROCESSLIST'", "'PROFILE'", "'PROFILES'", "'PROXY'", 
                     "'QUERY'", "'QUICK'", "'REBUILD'", "'RECOVER'", "'REDO_BUFFER_SIZE'", 
                     "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'", "'RELAY_LOG_POS'", 
                     "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'", 
                     "'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'", 
                     "'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", 
                     "'REPLICATE_WILD_DO_TABLE'", "'REPLICATE_WILD_IGNORE_TABLE'", 
                     "'REPLICATION'", "'RESET'", "'RESUME'", "'RETURNS'", 
                     "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", 
                     "'ROW_FORMAT'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", 
                     "'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", 
                     "'SIMPLE'", "'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", 
                     "<INVALID>", "'SONAME'", "'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", 
                     "'SQL_AFTER_MTS_GAPS'", "'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", 
                     "'SQL_CACHE'", "'SQL_NO_CACHE'", "'SQL_THREAD'", "'START'", 
                     "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'", 
                     "'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", 
                     "'STORED'", "'STRING'", "'SUBJECT'", "'SUBPARTITION'", 
                     "'SUBPARTITIONS'", "'SUSPEND'", "'SWAPS'", "'SWITCHES'", 
                     "'TABLESPACE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", 
                     "'TRADITIONAL'", "'TRANSACTION'", "'TRIGGERS'", "'TRUNCATE'", 
                     "'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", 
                     "'UNINSTALL'", "'UNKNOWN'", "'UNTIL'", "'UPGRADE'", 
                     "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'", 
                     "'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'WAIT'", 
                     "'WARNINGS'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'", 
                     "'XA'", "'XML'", "'EUR'", "'USA'", "'JIS'", "'ISO'", 
                     "'INTERNAL'", "'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", 
                     "'MINUTE'", "'WEEK'", "'SECOND'", "'MICROSECOND'", 
                     "'TABLES'", "'ROUTINE'", "'EXECUTE'", "'FILE'", "'PROCESS'", 
                     "'RELOAD'", "'SHUTDOWN'", "'SUPER'", "'PRIVILEGES'", 
                     "'ARMSCII8'", "'ASCII'", "'BIG5'", "'CP1250'", "'CP1251'", 
                     "'CP1256'", "'CP1257'", "'CP850'", "'CP852'", "'CP866'", 
                     "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB2312'", 
                     "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", 
                     "'KEYBCS2'", "'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", 
                     "'LATIN5'", "'LATIN7'", "'MACCE'", "'MACROMAN'", "'SJIS'", 
                     "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'", "'UTF16'", 
                     "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'", 
                     "'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", 
                     "'INNODB'", "'MEMORY'", "'MRG_MYISAM'", "'MYISAM'", 
                     "'NDB'", "'NDBCLUSTER'", "'PERFOMANCE_SCHEMA'", "'REPEATABLE'", 
                     "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", "'GEOMETRYCOLLECTION'", 
                     "'LINESTRING'", "'MULTILINESTRING'", "'MULTIPOINT'", 
                     "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", "'ABS'", 
                     "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", 
                     "'AES_ENCRYPT'", "'AREA'", "'ASBINARY'", "'ASIN'", 
                     "'ASTEXT'", "'ASWKB'", "'ASWKT'", "'ASYMMETRIC_DECRYPT'", 
                     "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'", "'ASYMMETRIC_SIGN'", 
                     "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'", 
                     "'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", 
                     "'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", 
                     "'CHARSET'", "'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", 
                     "'COMPRESS'", "'CONCAT'", "'CONCAT_WS'", "'CONNECTION_ID'", 
                     "'CONV'", "'CONVERT_TZ'", "'COS'", "'COT'", "'CRC32'", 
                     "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'", 
                     "'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", 
                     "'DATEDIFF'", "'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", 
                     "'DAYOFWEEK'", "'DAYOFYEAR'", "'DECODE'", "'DEGREES'", 
                     "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'", "'DISJOINT'", 
                     "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENVELOPE'", 
                     "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", 
                     "'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", 
                     "'FORMAT'", "'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", 
                     "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'", "'GEOMCOLLFROMWKB'", 
                     "'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'", 
                     "'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", "'GEOMETRYN'", 
                     "'GEOMETRYTYPE'", "'GEOMFROMTEXT'", "'GEOMFROMWKB'", 
                     "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", "'GREATEST'", 
                     "'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", 
                     "'INET6_ATON'", "'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", 
                     "'INSTR'", "'INTERIORRINGN'", "'INTERSECTS'", "'ISCLOSED'", 
                     "'ISEMPTY'", "'ISNULL'", "'ISSIMPLE'", "'IS_FREE_LOCK'", 
                     "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'", 
                     "'IS_IPV6'", "'IS_USED_LOCK'", "'LAST_INSERT_ID'", 
                     "'LCASE'", "'LEAST'", "'LENGTH'", "'LINEFROMTEXT'", 
                     "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'", "'LINESTRINGFROMWKB'", 
                     "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'", 
                     "'LOG2'", "'LOWER'", "'LPAD'", "'LTRIM'", "'MAKEDATE'", 
                     "'MAKETIME'", "'MAKE_SET'", "'MASTER_POS_WAIT'", "'MBRCONTAINS'", 
                     "'MBRDISJOINT'", "'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", 
                     "'MBRTOUCHES'", "'MBRWITHIN'", "'MD5'", "'MLINEFROMTEXT'", 
                     "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'", 
                     "'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", 
                     "'MULTILINESTRINGFROMTEXT'", "'MULTILINESTRINGFROMWKB'", 
                     "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'", "'MULTIPOLYGONFROMTEXT'", 
                     "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'", 
                     "'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", 
                     "'OCT'", "'OCTET_LENGTH'", "'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", 
                     "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'", "'POINTFROMWKB'", 
                     "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'", 
                     "'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", 
                     "'RADIANS'", "'RAND'", "'RANDOM_BYTES'", "'RELEASE_LOCK'", 
                     "'REVERSE'", "'ROUND'", "'ROW_COUNT'", "'RPAD'", "'RTRIM'", 
                     "'SEC_TO_TIME'", "'SESSION_USER'", "'SHA'", "'SHA1'", 
                     "'SHA2'", "'SIGN'", "'SIN'", "'SLEEP'", "'SOUNDEX'", 
                     "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'", "'SRID'", 
                     "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'", 
                     "'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", 
                     "'ST_BUFFER'", "'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", 
                     "'ST_DIFFERENCE'", "'ST_DIMENSION'", "'ST_DISJOINT'", 
                     "'ST_DISTANCE'", "'ST_ENDPOINT'", "'ST_ENVELOPE'", 
                     "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'", 
                     "'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'", 
                     "'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'", 
                     "'ST_GEOMETRYFROMWKB'", "'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", 
                     "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'", "'ST_INTERIORRINGN'", 
                     "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'", 
                     "'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", 
                     "'ST_LINEFROMWKB'", "'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", 
                     "'ST_NUMGEOMETRIES'", "'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", 
                     "'ST_NUMPOINTS'", "'ST_OVERLAPS'", "'ST_POINTFROMTEXT'", 
                     "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'", 
                     "'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", 
                     "'ST_SRID'", "'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", 
                     "'ST_TOUCHES'", "'ST_UNION'", "'ST_WITHIN'", "'ST_X'", 
                     "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'", "'SUBTIME'", 
                     "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'", 
                     "'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", 
                     "'TOUCHES'", "'TO_BASE64'", "'TO_DAYS'", "'TO_SECONDS'", 
                     "'UCASE'", "'UNCOMPRESS'", "'UNCOMPRESSED_LENGTH'", 
                     "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", "'UPPER'", 
                     "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'", 
                     "'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", 
                     "'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'", "'WITHIN'", 
                     "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='", "'-='", 
                     "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'", 
                     "'/'", "'%'", "'+'", "'--'", "'-'", "'DIV'", "'MOD'", 
                     "'='", "'>'", "'<'", "'!'", "'~'", "'|'", "'&'", "'^'", 
                     "'.'", "'('", "')'", "','", "';'", "'@'", "'0'", "'1'", 
                     "'2'", "'''", "'\"'", "'`'", "':'" ]

    symbolicNames = [ "<INVALID>", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", 
                      "LINE_COMMENT", "ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", 
                      "AND", "AS", "ASC", "BEFORE", "BETWEEN", "BOTH", "BY", 
                      "CALL", "CASCADE", "CASE", "CAST", "CHANGE", "CHARACTER", 
                      "CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", 
                      "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT_USER", 
                      "CURSOR", "DATABASE", "DATABASES", "DECLARE", "DEFAULT", 
                      "DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC", 
                      "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", 
                      "ELSEIF", "ENCLOSED", "ESCAPED", "EXISTS", "EXIT", 
                      "EXPLAIN", "FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", 
                      "FROM", "FULLTEXT", "GENERATED", "GRANT", "GROUP", 
                      "HAVING", "HIGH_PRIORITY", "IF", "IGNORE", "IN", "INDEX", 
                      "INFILE", "INNER", "INOUT", "INSERT", "INTERVAL", 
                      "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", 
                      "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", 
                      "LINES", "LOAD", "LOCK", "LOOP", "LOW_PRIORITY", "MASTER_BIND", 
                      "MASTER_SSL_VERIFY_SERVER_CERT", "MATCH", "MAXVALUE", 
                      "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", 
                      "NULL_LITERAL", "ON", "OPTIMIZE", "OPTION", "OPTIONALLY", 
                      "OR", "ORDER", "OUT", "OUTER", "OUTFILE", "PARTITION", 
                      "PRIMARY", "PROCEDURE", "PURGE", "RANGE", "READ", 
                      "READS", "REFERENCES", "REGEXP", "RELEASE", "RENAME", 
                      "REPEAT", "REPLACE", "REQUIRE", "RESTRICT", "RETURN", 
                      "REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS", "SELECT", 
                      "SET", "SEPARATOR", "SHOW", "SPATIAL", "SQL", "SQLEXCEPTION", 
                      "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", 
                      "SQL_SMALL_RESULT", "SSL", "STARTING", "STRAIGHT_JOIN", 
                      "TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", 
                      "TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", 
                      "UPDATE", "USAGE", "USE", "USING", "VALUES", "WHEN", 
                      "WHERE", "WHILE", "WITH", "WRITE", "XOR", "ZEROFILL", 
                      "TINYINT", "SMALLINT", "MEDIUMINT", "INT", "INTEGER", 
                      "BIGINT", "REAL", "DOUBLE", "FLOAT", "DECIMAL", "NUMERIC", 
                      "DATE", "TIME", "TIMESTAMP", "DATETIME", "YEAR", "CHAR", 
                      "VARCHAR", "BINARY", "VARBINARY", "TINYBLOB", "BLOB", 
                      "MEDIUMBLOB", "LONGBLOB", "TINYTEXT", "TEXT", "MEDIUMTEXT", 
                      "LONGTEXT", "ENUM", "SERIAL", "YEAR_MONTH", "DAY_HOUR", 
                      "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND", 
                      "MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND", 
                      "HOUR_MICROSECOND", "DAY_MICROSECOND", "AVG", "BIT_AND", 
                      "BIT_OR", "BIT_XOR", "COUNT", "GROUP_CONCAT", "MAX", 
                      "MIN", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", 
                      "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "CURRENT_DATE", 
                      "CURRENT_TIME", "CURRENT_TIMESTAMP", "LOCALTIME", 
                      "CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", 
                      "LOCALTIMESTAMP", "NOW", "POSITION", "SUBSTR", "SUBSTRING", 
                      "SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", 
                      "ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM", 
                      "ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", 
                      "AUTO_INCREMENT", "AVG_ROW_LENGTH", "BEGIN", "BINLOG", 
                      "BIT", "BLOCK", "BOOL", "BOOLEAN", "BTREE", "CACHE", 
                      "CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM", 
                      "CIPHER", "CLIENT", "CLOSE", "COALESCE", "CODE", "COLUMNS", 
                      "COLUMN_FORMAT", "COMMENT", "COMMIT", "COMPACT", "COMPLETION", 
                      "COMPRESSED", "COMPRESSION", "CONCURRENT", "CONNECTION", 
                      "CONSISTENT", "CONTAINS", "CONTEXT", "CONTRIBUTORS", 
                      "COPY", "CPU", "DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", 
                      "DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", 
                      "DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", 
                      "DYNAMIC", "ENABLE", "ENCRYPTION", "END", "ENDS", 
                      "ENGINE", "ENGINES", "ERROR", "ERRORS", "ESCAPE", 
                      "EVEN", "EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUSIVE", 
                      "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE", "FAST", 
                      "FAULTS", "FIELDS", "FILE_BLOCK_SIZE", "FILTER", "FIRST", 
                      "FIXED", "FLUSH", "FOLLOWS", "FOUND", "FULL", "FUNCTION", 
                      "GENERAL", "GLOBAL", "GRANTS", "GROUP_REPLICATION", 
                      "HANDLER", "HASH", "HELP", "HOST", "HOSTS", "IDENTIFIED", 
                      "IGNORE_SERVER_IDS", "IMPORT", "INDEXES", "INITIAL_SIZE", 
                      "INPLACE", "INSERT_METHOD", "INSTALL", "INSTANCE", 
                      "INVOKER", "IO", "IO_THREAD", "IPC", "ISOLATION", 
                      "ISSUER", "JSON", "KEY_BLOCK_SIZE", "LANGUAGE", "LAST", 
                      "LEAVES", "LESS", "LEVEL", "LIST", "LOCAL", "LOGFILE", 
                      "LOGS", "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY", 
                      "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", 
                      "MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", 
                      "MASTER_PORT", "MASTER_RETRY_COUNT", "MASTER_SSL", 
                      "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT", 
                      "MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", 
                      "MASTER_SSL_KEY", "MASTER_TLS_VERSION", "MASTER_USER", 
                      "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR", 
                      "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", 
                      "MEDIUM", "MERGE", "MID", "MIGRATE", "MIN_ROWS", "MODE", 
                      "MODIFY", "MUTEX", "MYSQL", "NAME", "NAMES", "NCHAR", 
                      "NEVER", "NEXT", "NO", "NODEGROUP", "NONE", "OFFLINE", 
                      "OFFSET", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", 
                      "OPEN", "OPTIMIZER_COSTS", "OPTIONS", "OWNER", "PACK_KEYS", 
                      "PAGE", "PARSER", "PARTIAL", "PARTITIONING", "PARTITIONS", 
                      "PASSWORD", "PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS", 
                      "PORT", "PRECEDES", "PREPARE", "PRESERVE", "PREV", 
                      "PROCESSLIST", "PROFILE", "PROFILES", "PROXY", "QUERY", 
                      "QUICK", "REBUILD", "RECOVER", "REDO_BUFFER_SIZE", 
                      "REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", 
                      "RELAYLOG", "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", 
                      "REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", 
                      "REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", 
                      "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION", "RESET", 
                      "RESUME", "RETURNS", "ROLLBACK", "ROLLUP", "ROTATE", 
                      "ROW", "ROWS", "ROW_FORMAT", "SAVEPOINT", "SCHEDULE", 
                      "SECURITY", "SERVER", "SESSION", "SHARE", "SHARED", 
                      "SIGNED", "SIMPLE", "SLAVE", "SLOW", "SNAPSHOT", "SOCKET", 
                      "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", 
                      "SQL_AFTER_MTS_GAPS", "SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", 
                      "SQL_CACHE", "SQL_NO_CACHE", "SQL_THREAD", "START", 
                      "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT", 
                      "STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", 
                      "STORED", "STRING", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", 
                      "SUSPEND", "SWAPS", "SWITCHES", "TABLESPACE", "TEMPORARY", 
                      "TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", 
                      "TRIGGERS", "TRUNCATE", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE", 
                      "UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", 
                      "USE_FRM", "USER_RESOURCES", "VALIDATION", "VALUE", 
                      "VARIABLES", "VIEW", "VIRTUAL", "WAIT", "WARNINGS", 
                      "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML", 
                      "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", 
                      "MONTH", "DAY", "HOUR", "MINUTE", "WEEK", "SECOND", 
                      "MICROSECOND", "TABLES", "ROUTINE", "EXECUTE", "FILE", 
                      "PROCESS", "RELOAD", "SHUTDOWN", "SUPER", "PRIVILEGES", 
                      "ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", 
                      "CP1257", "CP850", "CP852", "CP866", "CP932", "DEC8", 
                      "EUCJPMS", "EUCKR", "GB2312", "GBK", "GEOSTD8", "GREEK", 
                      "HEBREW", "HP8", "KEYBCS2", "KOI8R", "KOI8U", "LATIN1", 
                      "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN", 
                      "SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", 
                      "UTF16LE", "UTF32", "UTF8", "UTF8MB3", "UTF8MB4", 
                      "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED", "INNODB", 
                      "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", 
                      "PERFOMANCE_SCHEMA", "REPEATABLE", "COMMITTED", "UNCOMMITTED", 
                      "SERIALIZABLE", "GEOMETRYCOLLECTION", "LINESTRING", 
                      "MULTILINESTRING", "MULTIPOINT", "MULTIPOLYGON", "POINT", 
                      "POLYGON", "ABS", "ACOS", "ADDDATE", "ADDTIME", "AES_DECRYPT", 
                      "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN", "ASTEXT", 
                      "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE", 
                      "ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", 
                      "ATAN", "ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", 
                      "BIT_LENGTH", "BUFFER", "CEIL", "CEILING", "CENTROID", 
                      "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH", "COERCIBILITY", 
                      "COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", 
                      "CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY", 
                      "CREATE_ASYMMETRIC_PUB_KEY", "CREATE_DH_PARAMETERS", 
                      "CREATE_DIGEST", "CROSSES", "DATEDIFF", "DATE_FORMAT", 
                      "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", 
                      "DECODE", "DEGREES", "DES_DECRYPT", "DES_ENCRYPT", 
                      "DIMENSION", "DISJOINT", "ELT", "ENCODE", "ENCRYPT", 
                      "ENDPOINT", "ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", 
                      "EXTERIORRING", "EXTRACTVALUE", "FIELD", "FIND_IN_SET", 
                      "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64", "FROM_DAYS", 
                      "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB", 
                      "GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", 
                      "GEOMETRYFROMTEXT", "GEOMETRYFROMWKB", "GEOMETRYN", 
                      "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB", "GET_FORMAT", 
                      "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", 
                      "GTID_SUBTRACT", "HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", 
                      "INET_ATON", "INET_NTOA", "INSTR", "INTERIORRINGN", 
                      "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL", "ISSIMPLE", 
                      "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", 
                      "IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", 
                      "LEAST", "LENGTH", "LINEFROMTEXT", "LINEFROMWKB", 
                      "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB", "LN", "LOAD_FILE", 
                      "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", 
                      "LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", 
                      "MBRCONTAINS", "MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", 
                      "MBROVERLAPS", "MBRTOUCHES", "MBRWITHIN", "MD5", "MLINEFROMTEXT", 
                      "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT", "MPOINTFROMWKB", 
                      "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT", 
                      "MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB", 
                      "MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", "NAME_CONST", 
                      "NULLIF", "NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", 
                      "OCT", "OCTET_LENGTH", "ORD", "OVERLAPS", "PERIOD_ADD", 
                      "PERIOD_DIFF", "PI", "POINTFROMTEXT", "POINTFROMWKB", 
                      "POINTN", "POLYFROMTEXT", "POLYFROMWKB", "POLYGONFROMTEXT", 
                      "POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", 
                      "RAND", "RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", 
                      "ROUND", "ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME", 
                      "SESSION_USER", "SHA", "SHA1", "SHA2", "SIGN", "SIN", 
                      "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS", 
                      "SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", 
                      "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_ASWKB", 
                      "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", 
                      "ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", 
                      "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", 
                      "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", "ST_GEOMCOLLFROMTXT", 
                      "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", 
                      "ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", 
                      "ST_GEOMETRYFROMWKB", "ST_GEOMETRYN", "ST_GEOMETRYTYPE", 
                      "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", "ST_INTERIORRINGN", 
                      "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", 
                      "ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", 
                      "ST_LINESTRINGFROMTEXT", "ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", 
                      "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", "ST_NUMPOINTS", 
                      "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB", 
                      "ST_POINTN", "ST_POLYFROMTEXT", "ST_POLYFROMWKB", 
                      "ST_POLYGONFROMTEXT", "ST_POLYGONFROMWKB", "ST_SRID", 
                      "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", 
                      "ST_UNION", "ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", 
                      "SUBSTRING_INDEX", "SUBTIME", "SYSTEM_USER", "TAN", 
                      "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIME_FORMAT", 
                      "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", 
                      "TO_SECONDS", "UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", 
                      "UNHEX", "UNIX_TIMESTAMP", "UPDATEXML", "UPPER", "UUID", 
                      "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH", "VERSION", 
                      "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR", 
                      "WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", 
                      "X_FUNCTION", "VAR_ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN", 
                      "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", 
                      "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE", 
                      "PLUS", "MINUSMINUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", 
                      "GREATER_SYMBOL", "LESS_SYMBOL", "EXCLAMATION_SYMBOL", 
                      "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP", 
                      "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", 
                      "AT_SIGN", "ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL", 
                      "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB", "REVERSE_QUOTE_SYMB", 
                      "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING", "FILESIZE_LITERAL", 
                      "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL", 
                      "DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", 
                      "NULL_SPEC_LITERAL", "BIT_STRING", "STRING_CHARSET_NAME", 
                      "DOT_ID", "ID", "REVERSE_QUOTE_ID", "STRING_USER_NAME", 
                      "LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION" ]

    RULE_root = 0
    RULE_sqlStatements = 1
    RULE_sqlStatement = 2
    RULE_emptyStatement = 3
    RULE_dmlStatement = 4
    RULE_timestampValue = 5
    RULE_intervalExpr = 6
    RULE_intervalType = 7
    RULE_functionParameter = 8
    RULE_selectStatement = 9
    RULE_orderByClause = 10
    RULE_orderByExpression = 11
    RULE_tableSources = 12
    RULE_tableSource = 13
    RULE_tableSourceItem = 14
    RULE_joinPart = 15
    RULE_queryExpression = 16
    RULE_querySpecification = 17
    RULE_selectSpec = 18
    RULE_selectElements = 19
    RULE_selectElement = 20
    RULE_fromClause = 21
    RULE_groupByItem = 22
    RULE_limitClause = 23
    RULE_fullId = 24
    RULE_tableName = 25
    RULE_fullColumnName = 26
    RULE_mysqlVariable = 27
    RULE_uid = 28
    RULE_simpleId = 29
    RULE_dottedId = 30
    RULE_decimalLiteral = 31
    RULE_stringLiteral = 32
    RULE_booleanLiteral = 33
    RULE_hexadecimalLiteral = 34
    RULE_nullNotnull = 35
    RULE_constant = 36
    RULE_dataType = 37
    RULE_convertedDataType = 38
    RULE_uidList = 39
    RULE_tables = 40
    RULE_expressions = 41
    RULE_expressionsWithDefaults = 42
    RULE_constants = 43
    RULE_simpleStrings = 44
    RULE_userVariables = 45
    RULE_defaultValue = 46
    RULE_currentTimestamp = 47
    RULE_expressionOrDefault = 48
    RULE_ifExists = 49
    RULE_ifNotExists = 50
    RULE_functionCall = 51
    RULE_specificFunction = 52
    RULE_caseFuncAlternative = 53
    RULE_aggregateWindowedFunction = 54
    RULE_scalarFunctionName = 55
    RULE_functionArgs = 56
    RULE_functionArg = 57
    RULE_expression = 58
    RULE_predicate = 59
    RULE_expressionAtom = 60
    RULE_unaryOperator = 61
    RULE_comparisonOperator = 62
    RULE_logicalOperator = 63
    RULE_bitOperator = 64
    RULE_mathOperator = 65
    RULE_intervalTypeBase = 66
    RULE_dataTypeBase = 67
    RULE_keywordsCanBeId = 68
    RULE_functionNameBase = 69

    ruleNames =  [ "root", "sqlStatements", "sqlStatement", "emptyStatement", 
                   "dmlStatement", "timestampValue", "intervalExpr", "intervalType", 
                   "functionParameter", "selectStatement", "orderByClause", 
                   "orderByExpression", "tableSources", "tableSource", "tableSourceItem", 
                   "joinPart", "queryExpression", "querySpecification", 
                   "selectSpec", "selectElements", "selectElement", "fromClause", 
                   "groupByItem", "limitClause", "fullId", "tableName", 
                   "fullColumnName", "mysqlVariable", "uid", "simpleId", 
                   "dottedId", "decimalLiteral", "stringLiteral", "booleanLiteral", 
                   "hexadecimalLiteral", "nullNotnull", "constant", "dataType", 
                   "convertedDataType", "uidList", "tables", "expressions", 
                   "expressionsWithDefaults", "constants", "simpleStrings", 
                   "userVariables", "defaultValue", "currentTimestamp", 
                   "expressionOrDefault", "ifExists", "ifNotExists", "functionCall", 
                   "specificFunction", "caseFuncAlternative", "aggregateWindowedFunction", 
                   "scalarFunctionName", "functionArgs", "functionArg", 
                   "expression", "predicate", "expressionAtom", "unaryOperator", 
                   "comparisonOperator", "logicalOperator", "bitOperator", 
                   "mathOperator", "intervalTypeBase", "dataTypeBase", "keywordsCanBeId", 
                   "functionNameBase" ]

    EOF = Token.EOF
    SPACE=1
    SPEC_MYSQL_COMMENT=2
    COMMENT_INPUT=3
    LINE_COMMENT=4
    ADD=5
    ALL=6
    ALTER=7
    ALWAYS=8
    ANALYZE=9
    AND=10
    AS=11
    ASC=12
    BEFORE=13
    BETWEEN=14
    BOTH=15
    BY=16
    CALL=17
    CASCADE=18
    CASE=19
    CAST=20
    CHANGE=21
    CHARACTER=22
    CHECK=23
    COLLATE=24
    COLUMN=25
    CONDITION=26
    CONSTRAINT=27
    CONTINUE=28
    CONVERT=29
    CREATE=30
    CROSS=31
    CURRENT_USER=32
    CURSOR=33
    DATABASE=34
    DATABASES=35
    DECLARE=36
    DEFAULT=37
    DELAYED=38
    DELETE=39
    DESC=40
    DESCRIBE=41
    DETERMINISTIC=42
    DISTINCT=43
    DISTINCTROW=44
    DROP=45
    EACH=46
    ELSE=47
    ELSEIF=48
    ENCLOSED=49
    ESCAPED=50
    EXISTS=51
    EXIT=52
    EXPLAIN=53
    FALSE=54
    FETCH=55
    FOR=56
    FORCE=57
    FOREIGN=58
    FROM=59
    FULLTEXT=60
    GENERATED=61
    GRANT=62
    GROUP=63
    HAVING=64
    HIGH_PRIORITY=65
    IF=66
    IGNORE=67
    IN=68
    INDEX=69
    INFILE=70
    INNER=71
    INOUT=72
    INSERT=73
    INTERVAL=74
    INTO=75
    IS=76
    ITERATE=77
    JOIN=78
    KEY=79
    KEYS=80
    KILL=81
    LEADING=82
    LEAVE=83
    LEFT=84
    LIKE=85
    LIMIT=86
    LINEAR=87
    LINES=88
    LOAD=89
    LOCK=90
    LOOP=91
    LOW_PRIORITY=92
    MASTER_BIND=93
    MASTER_SSL_VERIFY_SERVER_CERT=94
    MATCH=95
    MAXVALUE=96
    MODIFIES=97
    NATURAL=98
    NOT=99
    NO_WRITE_TO_BINLOG=100
    NULL_LITERAL=101
    ON=102
    OPTIMIZE=103
    OPTION=104
    OPTIONALLY=105
    OR=106
    ORDER=107
    OUT=108
    OUTER=109
    OUTFILE=110
    PARTITION=111
    PRIMARY=112
    PROCEDURE=113
    PURGE=114
    RANGE=115
    READ=116
    READS=117
    REFERENCES=118
    REGEXP=119
    RELEASE=120
    RENAME=121
    REPEAT=122
    REPLACE=123
    REQUIRE=124
    RESTRICT=125
    RETURN=126
    REVOKE=127
    RIGHT=128
    RLIKE=129
    SCHEMA=130
    SCHEMAS=131
    SELECT=132
    SET=133
    SEPARATOR=134
    SHOW=135
    SPATIAL=136
    SQL=137
    SQLEXCEPTION=138
    SQLSTATE=139
    SQLWARNING=140
    SQL_BIG_RESULT=141
    SQL_CALC_FOUND_ROWS=142
    SQL_SMALL_RESULT=143
    SSL=144
    STARTING=145
    STRAIGHT_JOIN=146
    TABLE=147
    TERMINATED=148
    THEN=149
    TO=150
    TRAILING=151
    TRIGGER=152
    TRUE=153
    UNDO=154
    UNION=155
    UNIQUE=156
    UNLOCK=157
    UNSIGNED=158
    UPDATE=159
    USAGE=160
    USE=161
    USING=162
    VALUES=163
    WHEN=164
    WHERE=165
    WHILE=166
    WITH=167
    WRITE=168
    XOR=169
    ZEROFILL=170
    TINYINT=171
    SMALLINT=172
    MEDIUMINT=173
    INT=174
    INTEGER=175
    BIGINT=176
    REAL=177
    DOUBLE=178
    FLOAT=179
    DECIMAL=180
    NUMERIC=181
    DATE=182
    TIME=183
    TIMESTAMP=184
    DATETIME=185
    YEAR=186
    CHAR=187
    VARCHAR=188
    BINARY=189
    VARBINARY=190
    TINYBLOB=191
    BLOB=192
    MEDIUMBLOB=193
    LONGBLOB=194
    TINYTEXT=195
    TEXT=196
    MEDIUMTEXT=197
    LONGTEXT=198
    ENUM=199
    SERIAL=200
    YEAR_MONTH=201
    DAY_HOUR=202
    DAY_MINUTE=203
    DAY_SECOND=204
    HOUR_MINUTE=205
    HOUR_SECOND=206
    MINUTE_SECOND=207
    SECOND_MICROSECOND=208
    MINUTE_MICROSECOND=209
    HOUR_MICROSECOND=210
    DAY_MICROSECOND=211
    AVG=212
    BIT_AND=213
    BIT_OR=214
    BIT_XOR=215
    COUNT=216
    GROUP_CONCAT=217
    MAX=218
    MIN=219
    STD=220
    STDDEV=221
    STDDEV_POP=222
    STDDEV_SAMP=223
    SUM=224
    VAR_POP=225
    VAR_SAMP=226
    VARIANCE=227
    CURRENT_DATE=228
    CURRENT_TIME=229
    CURRENT_TIMESTAMP=230
    LOCALTIME=231
    CURDATE=232
    CURTIME=233
    DATE_ADD=234
    DATE_SUB=235
    EXTRACT=236
    LOCALTIMESTAMP=237
    NOW=238
    POSITION=239
    SUBSTR=240
    SUBSTRING=241
    SYSDATE=242
    TRIM=243
    UTC_DATE=244
    UTC_TIME=245
    UTC_TIMESTAMP=246
    ACCOUNT=247
    ACTION=248
    AFTER=249
    AGGREGATE=250
    ALGORITHM=251
    ANY=252
    AT=253
    AUTHORS=254
    AUTOCOMMIT=255
    AUTOEXTEND_SIZE=256
    AUTO_INCREMENT=257
    AVG_ROW_LENGTH=258
    BEGIN=259
    BINLOG=260
    BIT=261
    BLOCK=262
    BOOL=263
    BOOLEAN=264
    BTREE=265
    CACHE=266
    CASCADED=267
    CHAIN=268
    CHANGED=269
    CHANNEL=270
    CHECKSUM=271
    CIPHER=272
    CLIENT=273
    CLOSE=274
    COALESCE=275
    CODE=276
    COLUMNS=277
    COLUMN_FORMAT=278
    COMMENT=279
    COMMIT=280
    COMPACT=281
    COMPLETION=282
    COMPRESSED=283
    COMPRESSION=284
    CONCURRENT=285
    CONNECTION=286
    CONSISTENT=287
    CONTAINS=288
    CONTEXT=289
    CONTRIBUTORS=290
    COPY=291
    CPU=292
    DATA=293
    DATAFILE=294
    DEALLOCATE=295
    DEFAULT_AUTH=296
    DEFINER=297
    DELAY_KEY_WRITE=298
    DES_KEY_FILE=299
    DIRECTORY=300
    DISABLE=301
    DISCARD=302
    DISK=303
    DO=304
    DUMPFILE=305
    DUPLICATE=306
    DYNAMIC=307
    ENABLE=308
    ENCRYPTION=309
    END=310
    ENDS=311
    ENGINE=312
    ENGINES=313
    ERROR=314
    ERRORS=315
    ESCAPE=316
    EVEN=317
    EVENT=318
    EVENTS=319
    EVERY=320
    EXCHANGE=321
    EXCLUSIVE=322
    EXPIRE=323
    EXPORT=324
    EXTENDED=325
    EXTENT_SIZE=326
    FAST=327
    FAULTS=328
    FIELDS=329
    FILE_BLOCK_SIZE=330
    FILTER=331
    FIRST=332
    FIXED=333
    FLUSH=334
    FOLLOWS=335
    FOUND=336
    FULL=337
    FUNCTION=338
    GENERAL=339
    GLOBAL=340
    GRANTS=341
    GROUP_REPLICATION=342
    HANDLER=343
    HASH=344
    HELP=345
    HOST=346
    HOSTS=347
    IDENTIFIED=348
    IGNORE_SERVER_IDS=349
    IMPORT=350
    INDEXES=351
    INITIAL_SIZE=352
    INPLACE=353
    INSERT_METHOD=354
    INSTALL=355
    INSTANCE=356
    INVOKER=357
    IO=358
    IO_THREAD=359
    IPC=360
    ISOLATION=361
    ISSUER=362
    JSON=363
    KEY_BLOCK_SIZE=364
    LANGUAGE=365
    LAST=366
    LEAVES=367
    LESS=368
    LEVEL=369
    LIST=370
    LOCAL=371
    LOGFILE=372
    LOGS=373
    MASTER=374
    MASTER_AUTO_POSITION=375
    MASTER_CONNECT_RETRY=376
    MASTER_DELAY=377
    MASTER_HEARTBEAT_PERIOD=378
    MASTER_HOST=379
    MASTER_LOG_FILE=380
    MASTER_LOG_POS=381
    MASTER_PASSWORD=382
    MASTER_PORT=383
    MASTER_RETRY_COUNT=384
    MASTER_SSL=385
    MASTER_SSL_CA=386
    MASTER_SSL_CAPATH=387
    MASTER_SSL_CERT=388
    MASTER_SSL_CIPHER=389
    MASTER_SSL_CRL=390
    MASTER_SSL_CRLPATH=391
    MASTER_SSL_KEY=392
    MASTER_TLS_VERSION=393
    MASTER_USER=394
    MAX_CONNECTIONS_PER_HOUR=395
    MAX_QUERIES_PER_HOUR=396
    MAX_ROWS=397
    MAX_SIZE=398
    MAX_UPDATES_PER_HOUR=399
    MAX_USER_CONNECTIONS=400
    MEDIUM=401
    MERGE=402
    MID=403
    MIGRATE=404
    MIN_ROWS=405
    MODE=406
    MODIFY=407
    MUTEX=408
    MYSQL=409
    NAME=410
    NAMES=411
    NCHAR=412
    NEVER=413
    NEXT=414
    NO=415
    NODEGROUP=416
    NONE=417
    OFFLINE=418
    OFFSET=419
    OJ=420
    OLD_PASSWORD=421
    ONE=422
    ONLINE=423
    ONLY=424
    OPEN=425
    OPTIMIZER_COSTS=426
    OPTIONS=427
    OWNER=428
    PACK_KEYS=429
    PAGE=430
    PARSER=431
    PARTIAL=432
    PARTITIONING=433
    PARTITIONS=434
    PASSWORD=435
    PHASE=436
    PLUGIN=437
    PLUGIN_DIR=438
    PLUGINS=439
    PORT=440
    PRECEDES=441
    PREPARE=442
    PRESERVE=443
    PREV=444
    PROCESSLIST=445
    PROFILE=446
    PROFILES=447
    PROXY=448
    QUERY=449
    QUICK=450
    REBUILD=451
    RECOVER=452
    REDO_BUFFER_SIZE=453
    REDUNDANT=454
    RELAY=455
    RELAY_LOG_FILE=456
    RELAY_LOG_POS=457
    RELAYLOG=458
    REMOVE=459
    REORGANIZE=460
    REPAIR=461
    REPLICATE_DO_DB=462
    REPLICATE_DO_TABLE=463
    REPLICATE_IGNORE_DB=464
    REPLICATE_IGNORE_TABLE=465
    REPLICATE_REWRITE_DB=466
    REPLICATE_WILD_DO_TABLE=467
    REPLICATE_WILD_IGNORE_TABLE=468
    REPLICATION=469
    RESET=470
    RESUME=471
    RETURNS=472
    ROLLBACK=473
    ROLLUP=474
    ROTATE=475
    ROW=476
    ROWS=477
    ROW_FORMAT=478
    SAVEPOINT=479
    SCHEDULE=480
    SECURITY=481
    SERVER=482
    SESSION=483
    SHARE=484
    SHARED=485
    SIGNED=486
    SIMPLE=487
    SLAVE=488
    SLOW=489
    SNAPSHOT=490
    SOCKET=491
    SOME=492
    SONAME=493
    SOUNDS=494
    SOURCE=495
    SQL_AFTER_GTIDS=496
    SQL_AFTER_MTS_GAPS=497
    SQL_BEFORE_GTIDS=498
    SQL_BUFFER_RESULT=499
    SQL_CACHE=500
    SQL_NO_CACHE=501
    SQL_THREAD=502
    START=503
    STARTS=504
    STATS_AUTO_RECALC=505
    STATS_PERSISTENT=506
    STATS_SAMPLE_PAGES=507
    STATUS=508
    STOP=509
    STORAGE=510
    STORED=511
    STRING=512
    SUBJECT=513
    SUBPARTITION=514
    SUBPARTITIONS=515
    SUSPEND=516
    SWAPS=517
    SWITCHES=518
    TABLESPACE=519
    TEMPORARY=520
    TEMPTABLE=521
    THAN=522
    TRADITIONAL=523
    TRANSACTION=524
    TRIGGERS=525
    TRUNCATE=526
    UNDEFINED=527
    UNDOFILE=528
    UNDO_BUFFER_SIZE=529
    UNINSTALL=530
    UNKNOWN=531
    UNTIL=532
    UPGRADE=533
    USER=534
    USE_FRM=535
    USER_RESOURCES=536
    VALIDATION=537
    VALUE=538
    VARIABLES=539
    VIEW=540
    VIRTUAL=541
    WAIT=542
    WARNINGS=543
    WITHOUT=544
    WORK=545
    WRAPPER=546
    X509=547
    XA=548
    XML=549
    EUR=550
    USA=551
    JIS=552
    ISO=553
    INTERNAL=554
    QUARTER=555
    MONTH=556
    DAY=557
    HOUR=558
    MINUTE=559
    WEEK=560
    SECOND=561
    MICROSECOND=562
    TABLES=563
    ROUTINE=564
    EXECUTE=565
    FILE=566
    PROCESS=567
    RELOAD=568
    SHUTDOWN=569
    SUPER=570
    PRIVILEGES=571
    ARMSCII8=572
    ASCII=573
    BIG5=574
    CP1250=575
    CP1251=576
    CP1256=577
    CP1257=578
    CP850=579
    CP852=580
    CP866=581
    CP932=582
    DEC8=583
    EUCJPMS=584
    EUCKR=585
    GB2312=586
    GBK=587
    GEOSTD8=588
    GREEK=589
    HEBREW=590
    HP8=591
    KEYBCS2=592
    KOI8R=593
    KOI8U=594
    LATIN1=595
    LATIN2=596
    LATIN5=597
    LATIN7=598
    MACCE=599
    MACROMAN=600
    SJIS=601
    SWE7=602
    TIS620=603
    UCS2=604
    UJIS=605
    UTF16=606
    UTF16LE=607
    UTF32=608
    UTF8=609
    UTF8MB3=610
    UTF8MB4=611
    ARCHIVE=612
    BLACKHOLE=613
    CSV=614
    FEDERATED=615
    INNODB=616
    MEMORY=617
    MRG_MYISAM=618
    MYISAM=619
    NDB=620
    NDBCLUSTER=621
    PERFOMANCE_SCHEMA=622
    REPEATABLE=623
    COMMITTED=624
    UNCOMMITTED=625
    SERIALIZABLE=626
    GEOMETRYCOLLECTION=627
    LINESTRING=628
    MULTILINESTRING=629
    MULTIPOINT=630
    MULTIPOLYGON=631
    POINT=632
    POLYGON=633
    ABS=634
    ACOS=635
    ADDDATE=636
    ADDTIME=637
    AES_DECRYPT=638
    AES_ENCRYPT=639
    AREA=640
    ASBINARY=641
    ASIN=642
    ASTEXT=643
    ASWKB=644
    ASWKT=645
    ASYMMETRIC_DECRYPT=646
    ASYMMETRIC_DERIVE=647
    ASYMMETRIC_ENCRYPT=648
    ASYMMETRIC_SIGN=649
    ASYMMETRIC_VERIFY=650
    ATAN=651
    ATAN2=652
    BENCHMARK=653
    BIN=654
    BIT_COUNT=655
    BIT_LENGTH=656
    BUFFER=657
    CEIL=658
    CEILING=659
    CENTROID=660
    CHARACTER_LENGTH=661
    CHARSET=662
    CHAR_LENGTH=663
    COERCIBILITY=664
    COLLATION=665
    COMPRESS=666
    CONCAT=667
    CONCAT_WS=668
    CONNECTION_ID=669
    CONV=670
    CONVERT_TZ=671
    COS=672
    COT=673
    CRC32=674
    CREATE_ASYMMETRIC_PRIV_KEY=675
    CREATE_ASYMMETRIC_PUB_KEY=676
    CREATE_DH_PARAMETERS=677
    CREATE_DIGEST=678
    CROSSES=679
    DATEDIFF=680
    DATE_FORMAT=681
    DAYNAME=682
    DAYOFMONTH=683
    DAYOFWEEK=684
    DAYOFYEAR=685
    DECODE=686
    DEGREES=687
    DES_DECRYPT=688
    DES_ENCRYPT=689
    DIMENSION=690
    DISJOINT=691
    ELT=692
    ENCODE=693
    ENCRYPT=694
    ENDPOINT=695
    ENVELOPE=696
    EQUALS=697
    EXP=698
    EXPORT_SET=699
    EXTERIORRING=700
    EXTRACTVALUE=701
    FIELD=702
    FIND_IN_SET=703
    FLOOR=704
    FORMAT=705
    FOUND_ROWS=706
    FROM_BASE64=707
    FROM_DAYS=708
    FROM_UNIXTIME=709
    GEOMCOLLFROMTEXT=710
    GEOMCOLLFROMWKB=711
    GEOMETRYCOLLECTIONFROMTEXT=712
    GEOMETRYCOLLECTIONFROMWKB=713
    GEOMETRYFROMTEXT=714
    GEOMETRYFROMWKB=715
    GEOMETRYN=716
    GEOMETRYTYPE=717
    GEOMFROMTEXT=718
    GEOMFROMWKB=719
    GET_FORMAT=720
    GET_LOCK=721
    GLENGTH=722
    GREATEST=723
    GTID_SUBSET=724
    GTID_SUBTRACT=725
    HEX=726
    IFNULL=727
    INET6_ATON=728
    INET6_NTOA=729
    INET_ATON=730
    INET_NTOA=731
    INSTR=732
    INTERIORRINGN=733
    INTERSECTS=734
    ISCLOSED=735
    ISEMPTY=736
    ISNULL=737
    ISSIMPLE=738
    IS_FREE_LOCK=739
    IS_IPV4=740
    IS_IPV4_COMPAT=741
    IS_IPV4_MAPPED=742
    IS_IPV6=743
    IS_USED_LOCK=744
    LAST_INSERT_ID=745
    LCASE=746
    LEAST=747
    LENGTH=748
    LINEFROMTEXT=749
    LINEFROMWKB=750
    LINESTRINGFROMTEXT=751
    LINESTRINGFROMWKB=752
    LN=753
    LOAD_FILE=754
    LOCATE=755
    LOG=756
    LOG10=757
    LOG2=758
    LOWER=759
    LPAD=760
    LTRIM=761
    MAKEDATE=762
    MAKETIME=763
    MAKE_SET=764
    MASTER_POS_WAIT=765
    MBRCONTAINS=766
    MBRDISJOINT=767
    MBREQUAL=768
    MBRINTERSECTS=769
    MBROVERLAPS=770
    MBRTOUCHES=771
    MBRWITHIN=772
    MD5=773
    MLINEFROMTEXT=774
    MLINEFROMWKB=775
    MONTHNAME=776
    MPOINTFROMTEXT=777
    MPOINTFROMWKB=778
    MPOLYFROMTEXT=779
    MPOLYFROMWKB=780
    MULTILINESTRINGFROMTEXT=781
    MULTILINESTRINGFROMWKB=782
    MULTIPOINTFROMTEXT=783
    MULTIPOINTFROMWKB=784
    MULTIPOLYGONFROMTEXT=785
    MULTIPOLYGONFROMWKB=786
    NAME_CONST=787
    NULLIF=788
    NUMGEOMETRIES=789
    NUMINTERIORRINGS=790
    NUMPOINTS=791
    OCT=792
    OCTET_LENGTH=793
    ORD=794
    OVERLAPS=795
    PERIOD_ADD=796
    PERIOD_DIFF=797
    PI=798
    POINTFROMTEXT=799
    POINTFROMWKB=800
    POINTN=801
    POLYFROMTEXT=802
    POLYFROMWKB=803
    POLYGONFROMTEXT=804
    POLYGONFROMWKB=805
    POW=806
    POWER=807
    QUOTE=808
    RADIANS=809
    RAND=810
    RANDOM_BYTES=811
    RELEASE_LOCK=812
    REVERSE=813
    ROUND=814
    ROW_COUNT=815
    RPAD=816
    RTRIM=817
    SEC_TO_TIME=818
    SESSION_USER=819
    SHA=820
    SHA1=821
    SHA2=822
    SIGN=823
    SIN=824
    SLEEP=825
    SOUNDEX=826
    SQL_THREAD_WAIT_AFTER_GTIDS=827
    SQRT=828
    SRID=829
    STARTPOINT=830
    STRCMP=831
    STR_TO_DATE=832
    ST_AREA=833
    ST_ASBINARY=834
    ST_ASTEXT=835
    ST_ASWKB=836
    ST_ASWKT=837
    ST_BUFFER=838
    ST_CENTROID=839
    ST_CONTAINS=840
    ST_CROSSES=841
    ST_DIFFERENCE=842
    ST_DIMENSION=843
    ST_DISJOINT=844
    ST_DISTANCE=845
    ST_ENDPOINT=846
    ST_ENVELOPE=847
    ST_EQUALS=848
    ST_EXTERIORRING=849
    ST_GEOMCOLLFROMTEXT=850
    ST_GEOMCOLLFROMTXT=851
    ST_GEOMCOLLFROMWKB=852
    ST_GEOMETRYCOLLECTIONFROMTEXT=853
    ST_GEOMETRYCOLLECTIONFROMWKB=854
    ST_GEOMETRYFROMTEXT=855
    ST_GEOMETRYFROMWKB=856
    ST_GEOMETRYN=857
    ST_GEOMETRYTYPE=858
    ST_GEOMFROMTEXT=859
    ST_GEOMFROMWKB=860
    ST_INTERIORRINGN=861
    ST_INTERSECTION=862
    ST_INTERSECTS=863
    ST_ISCLOSED=864
    ST_ISEMPTY=865
    ST_ISSIMPLE=866
    ST_LINEFROMTEXT=867
    ST_LINEFROMWKB=868
    ST_LINESTRINGFROMTEXT=869
    ST_LINESTRINGFROMWKB=870
    ST_NUMGEOMETRIES=871
    ST_NUMINTERIORRING=872
    ST_NUMINTERIORRINGS=873
    ST_NUMPOINTS=874
    ST_OVERLAPS=875
    ST_POINTFROMTEXT=876
    ST_POINTFROMWKB=877
    ST_POINTN=878
    ST_POLYFROMTEXT=879
    ST_POLYFROMWKB=880
    ST_POLYGONFROMTEXT=881
    ST_POLYGONFROMWKB=882
    ST_SRID=883
    ST_STARTPOINT=884
    ST_SYMDIFFERENCE=885
    ST_TOUCHES=886
    ST_UNION=887
    ST_WITHIN=888
    ST_X=889
    ST_Y=890
    SUBDATE=891
    SUBSTRING_INDEX=892
    SUBTIME=893
    SYSTEM_USER=894
    TAN=895
    TIMEDIFF=896
    TIMESTAMPADD=897
    TIMESTAMPDIFF=898
    TIME_FORMAT=899
    TIME_TO_SEC=900
    TOUCHES=901
    TO_BASE64=902
    TO_DAYS=903
    TO_SECONDS=904
    UCASE=905
    UNCOMPRESS=906
    UNCOMPRESSED_LENGTH=907
    UNHEX=908
    UNIX_TIMESTAMP=909
    UPDATEXML=910
    UPPER=911
    UUID=912
    UUID_SHORT=913
    VALIDATE_PASSWORD_STRENGTH=914
    VERSION=915
    WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS=916
    WEEKDAY=917
    WEEKOFYEAR=918
    WEIGHT_STRING=919
    WITHIN=920
    YEARWEEK=921
    Y_FUNCTION=922
    X_FUNCTION=923
    VAR_ASSIGN=924
    PLUS_ASSIGN=925
    MINUS_ASSIGN=926
    MULT_ASSIGN=927
    DIV_ASSIGN=928
    MOD_ASSIGN=929
    AND_ASSIGN=930
    XOR_ASSIGN=931
    OR_ASSIGN=932
    STAR=933
    DIVIDE=934
    MODULE=935
    PLUS=936
    MINUSMINUS=937
    MINUS=938
    DIV=939
    MOD=940
    EQUAL_SYMBOL=941
    GREATER_SYMBOL=942
    LESS_SYMBOL=943
    EXCLAMATION_SYMBOL=944
    BIT_NOT_OP=945
    BIT_OR_OP=946
    BIT_AND_OP=947
    BIT_XOR_OP=948
    DOT=949
    LR_BRACKET=950
    RR_BRACKET=951
    COMMA=952
    SEMI=953
    AT_SIGN=954
    ZERO_DECIMAL=955
    ONE_DECIMAL=956
    TWO_DECIMAL=957
    SINGLE_QUOTE_SYMB=958
    DOUBLE_QUOTE_SYMB=959
    REVERSE_QUOTE_SYMB=960
    COLON_SYMB=961
    CHARSET_REVERSE_QOUTE_STRING=962
    FILESIZE_LITERAL=963
    START_NATIONAL_STRING_LITERAL=964
    STRING_LITERAL=965
    DECIMAL_LITERAL=966
    HEXADECIMAL_LITERAL=967
    REAL_LITERAL=968
    NULL_SPEC_LITERAL=969
    BIT_STRING=970
    STRING_CHARSET_NAME=971
    DOT_ID=972
    ID=973
    REVERSE_QUOTE_ID=974
    STRING_USER_NAME=975
    LOCAL_ID=976
    GLOBAL_ID=977
    ERROR_RECONGNIGION=978

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class RootContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SqlParser.EOF, 0)

        def sqlStatements(self):
            return self.getTypedRuleContext(SqlParser.SqlStatementsContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_root

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoot" ):
                listener.enterRoot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoot" ):
                listener.exitRoot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRoot" ):
                return visitor.visitRoot(self)
            else:
                return visitor.visitChildren(self)




    def root(self):

        localctx = SqlParser.RootContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_root)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.SELECT or _la==SqlParser.LR_BRACKET or _la==SqlParser.SEMI:
                self.state = 140
                self.sqlStatements()


            self.state = 143
            self.match(SqlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SqlStatementsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sqlStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.SqlStatementContext)
            else:
                return self.getTypedRuleContext(SqlParser.SqlStatementContext,i)


        def emptyStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.EmptyStatementContext)
            else:
                return self.getTypedRuleContext(SqlParser.EmptyStatementContext,i)


        def SEMI(self, i:int=None):
            if i is None:
                return self.getTokens(SqlParser.SEMI)
            else:
                return self.getToken(SqlParser.SEMI, i)

        def MINUSMINUS(self, i:int=None):
            if i is None:
                return self.getTokens(SqlParser.MINUSMINUS)
            else:
                return self.getToken(SqlParser.MINUSMINUS, i)

        def getRuleIndex(self):
            return SqlParser.RULE_sqlStatements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSqlStatements" ):
                listener.enterSqlStatements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSqlStatements" ):
                listener.exitSqlStatements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSqlStatements" ):
                return visitor.visitSqlStatements(self)
            else:
                return visitor.visitChildren(self)




    def sqlStatements(self):

        localctx = SqlParser.SqlStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sqlStatements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 152
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [SqlParser.SELECT, SqlParser.LR_BRACKET]:
                        self.state = 145
                        self.sqlStatement()
                        self.state = 147
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlParser.MINUSMINUS:
                            self.state = 146
                            self.match(SqlParser.MINUSMINUS)


                        self.state = 149
                        self.match(SqlParser.SEMI)
                        pass
                    elif token in [SqlParser.SEMI]:
                        self.state = 151
                        self.emptyStatement()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 156
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

            self.state = 165
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.SELECT, SqlParser.LR_BRACKET]:
                self.state = 157
                self.sqlStatement()
                self.state = 162
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.MINUSMINUS or _la==SqlParser.SEMI:
                    self.state = 159
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==SqlParser.MINUSMINUS:
                        self.state = 158
                        self.match(SqlParser.MINUSMINUS)


                    self.state = 161
                    self.match(SqlParser.SEMI)


                pass
            elif token in [SqlParser.SEMI]:
                self.state = 164
                self.emptyStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SqlStatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dmlStatement(self):
            return self.getTypedRuleContext(SqlParser.DmlStatementContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_sqlStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSqlStatement" ):
                listener.enterSqlStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSqlStatement" ):
                listener.exitSqlStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSqlStatement" ):
                return visitor.visitSqlStatement(self)
            else:
                return visitor.visitChildren(self)




    def sqlStatement(self):

        localctx = SqlParser.SqlStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_sqlStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self.dmlStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EmptyStatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMI(self):
            return self.getToken(SqlParser.SEMI, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_emptyStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmptyStatement" ):
                listener.enterEmptyStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmptyStatement" ):
                listener.exitEmptyStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmptyStatement" ):
                return visitor.visitEmptyStatement(self)
            else:
                return visitor.visitChildren(self)




    def emptyStatement(self):

        localctx = SqlParser.EmptyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_emptyStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            self.match(SqlParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DmlStatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectStatement(self):
            return self.getTypedRuleContext(SqlParser.SelectStatementContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_dmlStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDmlStatement" ):
                listener.enterDmlStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDmlStatement" ):
                listener.exitDmlStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDmlStatement" ):
                return visitor.visitDmlStatement(self)
            else:
                return visitor.visitChildren(self)




    def dmlStatement(self):

        localctx = SqlParser.DmlStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_dmlStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 171
            self.selectStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimestampValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CURRENT_TIMESTAMP(self):
            return self.getToken(SqlParser.CURRENT_TIMESTAMP, 0)

        def stringLiteral(self):
            return self.getTypedRuleContext(SqlParser.StringLiteralContext,0)


        def decimalLiteral(self):
            return self.getTypedRuleContext(SqlParser.DecimalLiteralContext,0)


        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_timestampValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimestampValue" ):
                listener.enterTimestampValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimestampValue" ):
                listener.exitTimestampValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimestampValue" ):
                return visitor.visitTimestampValue(self)
            else:
                return visitor.visitChildren(self)




    def timestampValue(self):

        localctx = SqlParser.TimestampValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_timestampValue)
        try:
            self.state = 177
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 173
                self.match(SqlParser.CURRENT_TIMESTAMP)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 174
                self.stringLiteral()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 175
                self.decimalLiteral()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 176
                self.expression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntervalExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL(self):
            return self.getToken(SqlParser.INTERVAL, 0)

        def intervalType(self):
            return self.getTypedRuleContext(SqlParser.IntervalTypeContext,0)


        def decimalLiteral(self):
            return self.getTypedRuleContext(SqlParser.DecimalLiteralContext,0)


        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_intervalExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalExpr" ):
                listener.enterIntervalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalExpr" ):
                listener.exitIntervalExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalExpr" ):
                return visitor.visitIntervalExpr(self)
            else:
                return visitor.visitChildren(self)




    def intervalExpr(self):

        localctx = SqlParser.IntervalExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_intervalExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.match(SqlParser.PLUS)
            self.state = 180
            self.match(SqlParser.INTERVAL)
            self.state = 183
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 181
                self.decimalLiteral()
                pass

            elif la_ == 2:
                self.state = 182
                self.expression(0)
                pass


            self.state = 185
            self.intervalType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntervalTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intervalTypeBase(self):
            return self.getTypedRuleContext(SqlParser.IntervalTypeBaseContext,0)


        def YEAR(self):
            return self.getToken(SqlParser.YEAR, 0)

        def YEAR_MONTH(self):
            return self.getToken(SqlParser.YEAR_MONTH, 0)

        def DAY_HOUR(self):
            return self.getToken(SqlParser.DAY_HOUR, 0)

        def DAY_MINUTE(self):
            return self.getToken(SqlParser.DAY_MINUTE, 0)

        def DAY_SECOND(self):
            return self.getToken(SqlParser.DAY_SECOND, 0)

        def HOUR_MINUTE(self):
            return self.getToken(SqlParser.HOUR_MINUTE, 0)

        def HOUR_SECOND(self):
            return self.getToken(SqlParser.HOUR_SECOND, 0)

        def MINUTE_SECOND(self):
            return self.getToken(SqlParser.MINUTE_SECOND, 0)

        def SECOND_MICROSECOND(self):
            return self.getToken(SqlParser.SECOND_MICROSECOND, 0)

        def MINUTE_MICROSECOND(self):
            return self.getToken(SqlParser.MINUTE_MICROSECOND, 0)

        def HOUR_MICROSECOND(self):
            return self.getToken(SqlParser.HOUR_MICROSECOND, 0)

        def DAY_MICROSECOND(self):
            return self.getToken(SqlParser.DAY_MICROSECOND, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_intervalType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalType" ):
                listener.enterIntervalType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalType" ):
                listener.exitIntervalType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalType" ):
                return visitor.visitIntervalType(self)
            else:
                return visitor.visitChildren(self)




    def intervalType(self):

        localctx = SqlParser.IntervalTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_intervalType)
        try:
            self.state = 200
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.QUARTER, SqlParser.MONTH, SqlParser.DAY, SqlParser.HOUR, SqlParser.MINUTE, SqlParser.WEEK, SqlParser.SECOND, SqlParser.MICROSECOND]:
                self.enterOuterAlt(localctx, 1)
                self.state = 187
                self.intervalTypeBase()
                pass
            elif token in [SqlParser.YEAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 188
                self.match(SqlParser.YEAR)
                pass
            elif token in [SqlParser.YEAR_MONTH]:
                self.enterOuterAlt(localctx, 3)
                self.state = 189
                self.match(SqlParser.YEAR_MONTH)
                pass
            elif token in [SqlParser.DAY_HOUR]:
                self.enterOuterAlt(localctx, 4)
                self.state = 190
                self.match(SqlParser.DAY_HOUR)
                pass
            elif token in [SqlParser.DAY_MINUTE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 191
                self.match(SqlParser.DAY_MINUTE)
                pass
            elif token in [SqlParser.DAY_SECOND]:
                self.enterOuterAlt(localctx, 6)
                self.state = 192
                self.match(SqlParser.DAY_SECOND)
                pass
            elif token in [SqlParser.HOUR_MINUTE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 193
                self.match(SqlParser.HOUR_MINUTE)
                pass
            elif token in [SqlParser.HOUR_SECOND]:
                self.enterOuterAlt(localctx, 8)
                self.state = 194
                self.match(SqlParser.HOUR_SECOND)
                pass
            elif token in [SqlParser.MINUTE_SECOND]:
                self.enterOuterAlt(localctx, 9)
                self.state = 195
                self.match(SqlParser.MINUTE_SECOND)
                pass
            elif token in [SqlParser.SECOND_MICROSECOND]:
                self.enterOuterAlt(localctx, 10)
                self.state = 196
                self.match(SqlParser.SECOND_MICROSECOND)
                pass
            elif token in [SqlParser.MINUTE_MICROSECOND]:
                self.enterOuterAlt(localctx, 11)
                self.state = 197
                self.match(SqlParser.MINUTE_MICROSECOND)
                pass
            elif token in [SqlParser.HOUR_MICROSECOND]:
                self.enterOuterAlt(localctx, 12)
                self.state = 198
                self.match(SqlParser.HOUR_MICROSECOND)
                pass
            elif token in [SqlParser.DAY_MICROSECOND]:
                self.enterOuterAlt(localctx, 13)
                self.state = 199
                self.match(SqlParser.DAY_MICROSECOND)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def uid(self):
            return self.getTypedRuleContext(SqlParser.UidContext,0)


        def dataType(self):
            return self.getTypedRuleContext(SqlParser.DataTypeContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_functionParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionParameter" ):
                listener.enterFunctionParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionParameter" ):
                listener.exitFunctionParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionParameter" ):
                return visitor.visitFunctionParameter(self)
            else:
                return visitor.visitChildren(self)




    def functionParameter(self):

        localctx = SqlParser.FunctionParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_functionParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.uid()
            self.state = 203
            self.dataType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SelectStatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_selectStatement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleSelectContext(SelectStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SelectStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def querySpecification(self):
            return self.getTypedRuleContext(SqlParser.QuerySpecificationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleSelect" ):
                listener.enterSimpleSelect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleSelect" ):
                listener.exitSimpleSelect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleSelect" ):
                return visitor.visitSimpleSelect(self)
            else:
                return visitor.visitChildren(self)


    class ParenthesisSelectContext(SelectStatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SelectStatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def queryExpression(self):
            return self.getTypedRuleContext(SqlParser.QueryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesisSelect" ):
                listener.enterParenthesisSelect(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesisSelect" ):
                listener.exitParenthesisSelect(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesisSelect" ):
                return visitor.visitParenthesisSelect(self)
            else:
                return visitor.visitChildren(self)



    def selectStatement(self):

        localctx = SqlParser.SelectStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_selectStatement)
        try:
            self.state = 207
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.SELECT]:
                localctx = SqlParser.SimpleSelectContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 205
                self.querySpecification()
                pass
            elif token in [SqlParser.LR_BRACKET]:
                localctx = SqlParser.ParenthesisSelectContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 206
                self.queryExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrderByClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(SqlParser.ORDER, 0)

        def BY(self):
            return self.getToken(SqlParser.BY, 0)

        def orderByExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.OrderByExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.OrderByExpressionContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_orderByClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderByClause" ):
                listener.enterOrderByClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderByClause" ):
                listener.exitOrderByClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderByClause" ):
                return visitor.visitOrderByClause(self)
            else:
                return visitor.visitChildren(self)




    def orderByClause(self):

        localctx = SqlParser.OrderByClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_orderByClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(SqlParser.ORDER)
            self.state = 210
            self.match(SqlParser.BY)
            self.state = 211
            self.orderByExpression()
            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 212
                self.match(SqlParser.COMMA)
                self.state = 213
                self.orderByExpression()
                self.state = 218
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrderByExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.order = None # Token

        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)


        def ASC(self):
            return self.getToken(SqlParser.ASC, 0)

        def DESC(self):
            return self.getToken(SqlParser.DESC, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_orderByExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderByExpression" ):
                listener.enterOrderByExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderByExpression" ):
                listener.exitOrderByExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderByExpression" ):
                return visitor.visitOrderByExpression(self)
            else:
                return visitor.visitChildren(self)




    def orderByExpression(self):

        localctx = SqlParser.OrderByExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_orderByExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            self.expression(0)
            self.state = 221
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.ASC or _la==SqlParser.DESC:
                self.state = 220
                localctx.order = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlParser.ASC or _la==SqlParser.DESC):
                    localctx.order = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TableSourcesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableSource(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.TableSourceContext)
            else:
                return self.getTypedRuleContext(SqlParser.TableSourceContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_tableSources

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableSources" ):
                listener.enterTableSources(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableSources" ):
                listener.exitTableSources(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableSources" ):
                return visitor.visitTableSources(self)
            else:
                return visitor.visitChildren(self)




    def tableSources(self):

        localctx = SqlParser.TableSourcesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_tableSources)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 223
            self.tableSource()
            self.state = 228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 224
                self.match(SqlParser.COMMA)
                self.state = 225
                self.tableSource()
                self.state = 230
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TableSourceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_tableSource

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TableSourceNestedContext(TableSourceContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.TableSourceContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tableSource(self):
            return self.getTypedRuleContext(SqlParser.TableSourceContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableSourceNested" ):
                listener.enterTableSourceNested(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableSourceNested" ):
                listener.exitTableSourceNested(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableSourceNested" ):
                return visitor.visitTableSourceNested(self)
            else:
                return visitor.visitChildren(self)


    class TableSourceBaseContext(TableSourceContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.TableSourceContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tableSourceItem(self):
            return self.getTypedRuleContext(SqlParser.TableSourceItemContext,0)

        def joinPart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.JoinPartContext)
            else:
                return self.getTypedRuleContext(SqlParser.JoinPartContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableSourceBase" ):
                listener.enterTableSourceBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableSourceBase" ):
                listener.exitTableSourceBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableSourceBase" ):
                return visitor.visitTableSourceBase(self)
            else:
                return visitor.visitChildren(self)



    def tableSource(self):

        localctx = SqlParser.TableSourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_tableSource)
        try:
            self.state = 242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                localctx = SqlParser.TableSourceBaseContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 231
                self.tableSourceItem()
                self.state = 235
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,14,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 232
                        self.joinPart() 
                    self.state = 237
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,14,self._ctx)

                pass

            elif la_ == 2:
                localctx = SqlParser.TableSourceNestedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 238
                self.match(SqlParser.LR_BRACKET)
                self.state = 239
                self.tableSource()
                self.state = 240
                self.match(SqlParser.RR_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TableSourceItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_tableSourceItem

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SubqueryTableItemContext(TableSourceItemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.TableSourceItemContext
            super().__init__(parser)
            self.parenthesisSubquery = None # SelectStatementContext
            self.alias = None # UidContext
            self.copyFrom(ctx)

        def uid(self):
            return self.getTypedRuleContext(SqlParser.UidContext,0)

        def selectStatement(self):
            return self.getTypedRuleContext(SqlParser.SelectStatementContext,0)

        def AS(self):
            return self.getToken(SqlParser.AS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubqueryTableItem" ):
                listener.enterSubqueryTableItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubqueryTableItem" ):
                listener.exitSubqueryTableItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubqueryTableItem" ):
                return visitor.visitSubqueryTableItem(self)
            else:
                return visitor.visitChildren(self)


    class AtomTableItemContext(TableSourceItemContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.TableSourceItemContext
            super().__init__(parser)
            self.alias = None # UidContext
            self.copyFrom(ctx)

        def tableName(self):
            return self.getTypedRuleContext(SqlParser.TableNameContext,0)

        def uid(self):
            return self.getTypedRuleContext(SqlParser.UidContext,0)

        def AS(self):
            return self.getToken(SqlParser.AS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtomTableItem" ):
                listener.enterAtomTableItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtomTableItem" ):
                listener.exitAtomTableItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtomTableItem" ):
                return visitor.visitAtomTableItem(self)
            else:
                return visitor.visitChildren(self)



    def tableSourceItem(self):

        localctx = SqlParser.TableSourceItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_tableSourceItem)
        self._la = 0 # Token type
        try:
            self.state = 263
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.DATABASE, SqlParser.LEFT, SqlParser.RIGHT, SqlParser.DATE, SqlParser.TIME, SqlParser.TIMESTAMP, SqlParser.DATETIME, SqlParser.YEAR, SqlParser.TEXT, SqlParser.ENUM, SqlParser.SERIAL, SqlParser.COUNT, SqlParser.POSITION, SqlParser.ACCOUNT, SqlParser.ACTION, SqlParser.AFTER, SqlParser.AGGREGATE, SqlParser.ALGORITHM, SqlParser.ANY, SqlParser.AT, SqlParser.AUTHORS, SqlParser.AUTOCOMMIT, SqlParser.AUTOEXTEND_SIZE, SqlParser.AUTO_INCREMENT, SqlParser.AVG_ROW_LENGTH, SqlParser.BEGIN, SqlParser.BINLOG, SqlParser.BIT, SqlParser.BLOCK, SqlParser.BOOL, SqlParser.BOOLEAN, SqlParser.BTREE, SqlParser.CACHE, SqlParser.CASCADED, SqlParser.CHAIN, SqlParser.CHANGED, SqlParser.CHANNEL, SqlParser.CHECKSUM, SqlParser.CIPHER, SqlParser.CLIENT, SqlParser.CLOSE, SqlParser.COALESCE, SqlParser.CODE, SqlParser.COLUMNS, SqlParser.COLUMN_FORMAT, SqlParser.COMMENT, SqlParser.COMMIT, SqlParser.COMPACT, SqlParser.COMPLETION, SqlParser.COMPRESSED, SqlParser.COMPRESSION, SqlParser.CONCURRENT, SqlParser.CONNECTION, SqlParser.CONSISTENT, SqlParser.CONTAINS, SqlParser.CONTEXT, SqlParser.CONTRIBUTORS, SqlParser.COPY, SqlParser.CPU, SqlParser.DATA, SqlParser.DATAFILE, SqlParser.DEALLOCATE, SqlParser.DEFAULT_AUTH, SqlParser.DEFINER, SqlParser.DELAY_KEY_WRITE, SqlParser.DES_KEY_FILE, SqlParser.DIRECTORY, SqlParser.DISABLE, SqlParser.DISCARD, SqlParser.DISK, SqlParser.DO, SqlParser.DUMPFILE, SqlParser.DUPLICATE, SqlParser.DYNAMIC, SqlParser.ENABLE, SqlParser.ENCRYPTION, SqlParser.END, SqlParser.ENDS, SqlParser.ENGINE, SqlParser.ENGINES, SqlParser.ERROR, SqlParser.ERRORS, SqlParser.ESCAPE, SqlParser.EVEN, SqlParser.EVENT, SqlParser.EVENTS, SqlParser.EVERY, SqlParser.EXCHANGE, SqlParser.EXCLUSIVE, SqlParser.EXPIRE, SqlParser.EXPORT, SqlParser.EXTENDED, SqlParser.EXTENT_SIZE, SqlParser.FAST, SqlParser.FAULTS, SqlParser.FIELDS, SqlParser.FILE_BLOCK_SIZE, SqlParser.FILTER, SqlParser.FIRST, SqlParser.FIXED, SqlParser.FLUSH, SqlParser.FOLLOWS, SqlParser.FOUND, SqlParser.FULL, SqlParser.FUNCTION, SqlParser.GENERAL, SqlParser.GLOBAL, SqlParser.GRANTS, SqlParser.GROUP_REPLICATION, SqlParser.HANDLER, SqlParser.HASH, SqlParser.HELP, SqlParser.HOST, SqlParser.HOSTS, SqlParser.IDENTIFIED, SqlParser.IGNORE_SERVER_IDS, SqlParser.IMPORT, SqlParser.INDEXES, SqlParser.INITIAL_SIZE, SqlParser.INPLACE, SqlParser.INSERT_METHOD, SqlParser.INSTALL, SqlParser.INSTANCE, SqlParser.INVOKER, SqlParser.IO, SqlParser.IO_THREAD, SqlParser.IPC, SqlParser.ISOLATION, SqlParser.ISSUER, SqlParser.JSON, SqlParser.KEY_BLOCK_SIZE, SqlParser.LANGUAGE, SqlParser.LAST, SqlParser.LEAVES, SqlParser.LESS, SqlParser.LEVEL, SqlParser.LIST, SqlParser.LOCAL, SqlParser.LOGFILE, SqlParser.LOGS, SqlParser.MASTER, SqlParser.MASTER_AUTO_POSITION, SqlParser.MASTER_CONNECT_RETRY, SqlParser.MASTER_DELAY, SqlParser.MASTER_HEARTBEAT_PERIOD, SqlParser.MASTER_HOST, SqlParser.MASTER_LOG_FILE, SqlParser.MASTER_LOG_POS, SqlParser.MASTER_PASSWORD, SqlParser.MASTER_PORT, SqlParser.MASTER_RETRY_COUNT, SqlParser.MASTER_SSL, SqlParser.MASTER_SSL_CA, SqlParser.MASTER_SSL_CAPATH, SqlParser.MASTER_SSL_CERT, SqlParser.MASTER_SSL_CIPHER, SqlParser.MASTER_SSL_CRL, SqlParser.MASTER_SSL_CRLPATH, SqlParser.MASTER_SSL_KEY, SqlParser.MASTER_TLS_VERSION, SqlParser.MASTER_USER, SqlParser.MAX_CONNECTIONS_PER_HOUR, SqlParser.MAX_QUERIES_PER_HOUR, SqlParser.MAX_ROWS, SqlParser.MAX_SIZE, SqlParser.MAX_UPDATES_PER_HOUR, SqlParser.MAX_USER_CONNECTIONS, SqlParser.MEDIUM, SqlParser.MERGE, SqlParser.MID, SqlParser.MIGRATE, SqlParser.MIN_ROWS, SqlParser.MODE, SqlParser.MODIFY, SqlParser.MUTEX, SqlParser.MYSQL, SqlParser.NAME, SqlParser.NAMES, SqlParser.NCHAR, SqlParser.NEVER, SqlParser.NEXT, SqlParser.NO, SqlParser.NODEGROUP, SqlParser.NONE, SqlParser.OFFLINE, SqlParser.OFFSET, SqlParser.OJ, SqlParser.OLD_PASSWORD, SqlParser.ONE, SqlParser.ONLINE, SqlParser.ONLY, SqlParser.OPEN, SqlParser.OPTIMIZER_COSTS, SqlParser.OPTIONS, SqlParser.OWNER, SqlParser.PACK_KEYS, SqlParser.PAGE, SqlParser.PARSER, SqlParser.PARTIAL, SqlParser.PARTITIONING, SqlParser.PARTITIONS, SqlParser.PASSWORD, SqlParser.PHASE, SqlParser.PLUGIN, SqlParser.PLUGIN_DIR, SqlParser.PLUGINS, SqlParser.PORT, SqlParser.PRECEDES, SqlParser.PREPARE, SqlParser.PRESERVE, SqlParser.PREV, SqlParser.PROCESSLIST, SqlParser.PROFILE, SqlParser.PROFILES, SqlParser.PROXY, SqlParser.QUERY, SqlParser.QUICK, SqlParser.REBUILD, SqlParser.RECOVER, SqlParser.REDO_BUFFER_SIZE, SqlParser.REDUNDANT, SqlParser.RELAY, SqlParser.RELAY_LOG_FILE, SqlParser.RELAY_LOG_POS, SqlParser.RELAYLOG, SqlParser.REMOVE, SqlParser.REORGANIZE, SqlParser.REPAIR, SqlParser.REPLICATE_DO_DB, SqlParser.REPLICATE_DO_TABLE, SqlParser.REPLICATE_IGNORE_DB, SqlParser.REPLICATE_IGNORE_TABLE, SqlParser.REPLICATE_REWRITE_DB, SqlParser.REPLICATE_WILD_DO_TABLE, SqlParser.REPLICATE_WILD_IGNORE_TABLE, SqlParser.REPLICATION, SqlParser.RESET, SqlParser.RESUME, SqlParser.RETURNS, SqlParser.ROLLBACK, SqlParser.ROLLUP, SqlParser.ROTATE, SqlParser.ROW, SqlParser.ROWS, SqlParser.ROW_FORMAT, SqlParser.SAVEPOINT, SqlParser.SCHEDULE, SqlParser.SECURITY, SqlParser.SERVER, SqlParser.SESSION, SqlParser.SHARE, SqlParser.SHARED, SqlParser.SIGNED, SqlParser.SIMPLE, SqlParser.SLAVE, SqlParser.SLOW, SqlParser.SNAPSHOT, SqlParser.SOCKET, SqlParser.SOME, SqlParser.SONAME, SqlParser.SOUNDS, SqlParser.SOURCE, SqlParser.SQL_AFTER_GTIDS, SqlParser.SQL_AFTER_MTS_GAPS, SqlParser.SQL_BEFORE_GTIDS, SqlParser.SQL_BUFFER_RESULT, SqlParser.SQL_CACHE, SqlParser.SQL_NO_CACHE, SqlParser.SQL_THREAD, SqlParser.START, SqlParser.STARTS, SqlParser.STATS_AUTO_RECALC, SqlParser.STATS_PERSISTENT, SqlParser.STATS_SAMPLE_PAGES, SqlParser.STATUS, SqlParser.STOP, SqlParser.STORAGE, SqlParser.STRING, SqlParser.SUBJECT, SqlParser.SUBPARTITION, SqlParser.SUBPARTITIONS, SqlParser.SUSPEND, SqlParser.SWAPS, SqlParser.SWITCHES, SqlParser.TABLESPACE, SqlParser.TEMPORARY, SqlParser.TEMPTABLE, SqlParser.THAN, SqlParser.TRADITIONAL, SqlParser.TRANSACTION, SqlParser.TRIGGERS, SqlParser.TRUNCATE, SqlParser.UNDEFINED, SqlParser.UNDOFILE, SqlParser.UNDO_BUFFER_SIZE, SqlParser.UNINSTALL, SqlParser.UNKNOWN, SqlParser.UNTIL, SqlParser.UPGRADE, SqlParser.USER, SqlParser.USE_FRM, SqlParser.USER_RESOURCES, SqlParser.VALIDATION, SqlParser.VALUE, SqlParser.VARIABLES, SqlParser.VIEW, SqlParser.WAIT, SqlParser.WARNINGS, SqlParser.WITHOUT, SqlParser.WORK, SqlParser.WRAPPER, SqlParser.X509, SqlParser.XA, SqlParser.XML, SqlParser.QUARTER, SqlParser.MONTH, SqlParser.DAY, SqlParser.HOUR, SqlParser.MINUTE, SqlParser.WEEK, SqlParser.SECOND, SqlParser.MICROSECOND, SqlParser.MEMORY, SqlParser.GEOMETRYCOLLECTION, SqlParser.LINESTRING, SqlParser.MULTILINESTRING, SqlParser.MULTIPOINT, SqlParser.MULTIPOLYGON, SqlParser.POINT, SqlParser.POLYGON, SqlParser.ABS, SqlParser.ACOS, SqlParser.ADDDATE, SqlParser.ADDTIME, SqlParser.AES_DECRYPT, SqlParser.AES_ENCRYPT, SqlParser.AREA, SqlParser.ASBINARY, SqlParser.ASIN, SqlParser.ASTEXT, SqlParser.ASWKB, SqlParser.ASWKT, SqlParser.ASYMMETRIC_DECRYPT, SqlParser.ASYMMETRIC_DERIVE, SqlParser.ASYMMETRIC_ENCRYPT, SqlParser.ASYMMETRIC_SIGN, SqlParser.ASYMMETRIC_VERIFY, SqlParser.ATAN, SqlParser.ATAN2, SqlParser.BENCHMARK, SqlParser.BIN, SqlParser.BIT_COUNT, SqlParser.BIT_LENGTH, SqlParser.BUFFER, SqlParser.CEIL, SqlParser.CEILING, SqlParser.CENTROID, SqlParser.CHARACTER_LENGTH, SqlParser.CHARSET, SqlParser.CHAR_LENGTH, SqlParser.COERCIBILITY, SqlParser.COLLATION, SqlParser.COMPRESS, SqlParser.CONCAT, SqlParser.CONCAT_WS, SqlParser.CONNECTION_ID, SqlParser.CONV, SqlParser.CONVERT_TZ, SqlParser.COS, SqlParser.COT, SqlParser.CRC32, SqlParser.CREATE_ASYMMETRIC_PRIV_KEY, SqlParser.CREATE_ASYMMETRIC_PUB_KEY, SqlParser.CREATE_DH_PARAMETERS, SqlParser.CREATE_DIGEST, SqlParser.CROSSES, SqlParser.DATEDIFF, SqlParser.DATE_FORMAT, SqlParser.DAYNAME, SqlParser.DAYOFMONTH, SqlParser.DAYOFWEEK, SqlParser.DAYOFYEAR, SqlParser.DECODE, SqlParser.DEGREES, SqlParser.DES_DECRYPT, SqlParser.DES_ENCRYPT, SqlParser.DIMENSION, SqlParser.DISJOINT, SqlParser.ELT, SqlParser.ENCODE, SqlParser.ENCRYPT, SqlParser.ENDPOINT, SqlParser.ENVELOPE, SqlParser.EQUALS, SqlParser.EXP, SqlParser.EXPORT_SET, SqlParser.EXTERIORRING, SqlParser.EXTRACTVALUE, SqlParser.FIELD, SqlParser.FIND_IN_SET, SqlParser.FLOOR, SqlParser.FORMAT, SqlParser.FOUND_ROWS, SqlParser.FROM_BASE64, SqlParser.FROM_DAYS, SqlParser.FROM_UNIXTIME, SqlParser.GEOMCOLLFROMTEXT, SqlParser.GEOMCOLLFROMWKB, SqlParser.GEOMETRYCOLLECTIONFROMTEXT, SqlParser.GEOMETRYCOLLECTIONFROMWKB, SqlParser.GEOMETRYFROMTEXT, SqlParser.GEOMETRYFROMWKB, SqlParser.GEOMETRYN, SqlParser.GEOMETRYTYPE, SqlParser.GEOMFROMTEXT, SqlParser.GEOMFROMWKB, SqlParser.GET_FORMAT, SqlParser.GET_LOCK, SqlParser.GLENGTH, SqlParser.GREATEST, SqlParser.GTID_SUBSET, SqlParser.GTID_SUBTRACT, SqlParser.HEX, SqlParser.IFNULL, SqlParser.INET6_ATON, SqlParser.INET6_NTOA, SqlParser.INET_ATON, SqlParser.INET_NTOA, SqlParser.INSTR, SqlParser.INTERIORRINGN, SqlParser.INTERSECTS, SqlParser.ISCLOSED, SqlParser.ISEMPTY, SqlParser.ISNULL, SqlParser.ISSIMPLE, SqlParser.IS_FREE_LOCK, SqlParser.IS_IPV4, SqlParser.IS_IPV4_COMPAT, SqlParser.IS_IPV4_MAPPED, SqlParser.IS_IPV6, SqlParser.IS_USED_LOCK, SqlParser.LAST_INSERT_ID, SqlParser.LCASE, SqlParser.LEAST, SqlParser.LENGTH, SqlParser.LINEFROMTEXT, SqlParser.LINEFROMWKB, SqlParser.LINESTRINGFROMTEXT, SqlParser.LINESTRINGFROMWKB, SqlParser.LN, SqlParser.LOAD_FILE, SqlParser.LOCATE, SqlParser.LOG, SqlParser.LOG10, SqlParser.LOG2, SqlParser.LOWER, SqlParser.LPAD, SqlParser.LTRIM, SqlParser.MAKEDATE, SqlParser.MAKETIME, SqlParser.MAKE_SET, SqlParser.MASTER_POS_WAIT, SqlParser.MBRCONTAINS, SqlParser.MBRDISJOINT, SqlParser.MBREQUAL, SqlParser.MBRINTERSECTS, SqlParser.MBROVERLAPS, SqlParser.MBRTOUCHES, SqlParser.MBRWITHIN, SqlParser.MD5, SqlParser.MLINEFROMTEXT, SqlParser.MLINEFROMWKB, SqlParser.MONTHNAME, SqlParser.MPOINTFROMTEXT, SqlParser.MPOINTFROMWKB, SqlParser.MPOLYFROMTEXT, SqlParser.MPOLYFROMWKB, SqlParser.MULTILINESTRINGFROMTEXT, SqlParser.MULTILINESTRINGFROMWKB, SqlParser.MULTIPOINTFROMTEXT, SqlParser.MULTIPOINTFROMWKB, SqlParser.MULTIPOLYGONFROMTEXT, SqlParser.MULTIPOLYGONFROMWKB, SqlParser.NAME_CONST, SqlParser.NULLIF, SqlParser.NUMGEOMETRIES, SqlParser.NUMINTERIORRINGS, SqlParser.NUMPOINTS, SqlParser.OCT, SqlParser.OCTET_LENGTH, SqlParser.ORD, SqlParser.OVERLAPS, SqlParser.PERIOD_ADD, SqlParser.PERIOD_DIFF, SqlParser.PI, SqlParser.POINTFROMTEXT, SqlParser.POINTFROMWKB, SqlParser.POINTN, SqlParser.POLYFROMTEXT, SqlParser.POLYFROMWKB, SqlParser.POLYGONFROMTEXT, SqlParser.POLYGONFROMWKB, SqlParser.POW, SqlParser.POWER, SqlParser.QUOTE, SqlParser.RADIANS, SqlParser.RAND, SqlParser.RANDOM_BYTES, SqlParser.RELEASE_LOCK, SqlParser.REVERSE, SqlParser.ROUND, SqlParser.ROW_COUNT, SqlParser.RPAD, SqlParser.RTRIM, SqlParser.SEC_TO_TIME, SqlParser.SESSION_USER, SqlParser.SHA, SqlParser.SHA1, SqlParser.SHA2, SqlParser.SIGN, SqlParser.SIN, SqlParser.SLEEP, SqlParser.SOUNDEX, SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, SqlParser.SQRT, SqlParser.SRID, SqlParser.STARTPOINT, SqlParser.STRCMP, SqlParser.STR_TO_DATE, SqlParser.ST_AREA, SqlParser.ST_ASBINARY, SqlParser.ST_ASTEXT, SqlParser.ST_ASWKB, SqlParser.ST_ASWKT, SqlParser.ST_BUFFER, SqlParser.ST_CENTROID, SqlParser.ST_CONTAINS, SqlParser.ST_CROSSES, SqlParser.ST_DIFFERENCE, SqlParser.ST_DIMENSION, SqlParser.ST_DISJOINT, SqlParser.ST_DISTANCE, SqlParser.ST_ENDPOINT, SqlParser.ST_ENVELOPE, SqlParser.ST_EQUALS, SqlParser.ST_EXTERIORRING, SqlParser.ST_GEOMCOLLFROMTEXT, SqlParser.ST_GEOMCOLLFROMTXT, SqlParser.ST_GEOMCOLLFROMWKB, SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, SqlParser.ST_GEOMETRYFROMTEXT, SqlParser.ST_GEOMETRYFROMWKB, SqlParser.ST_GEOMETRYN, SqlParser.ST_GEOMETRYTYPE, SqlParser.ST_GEOMFROMTEXT, SqlParser.ST_GEOMFROMWKB, SqlParser.ST_INTERIORRINGN, SqlParser.ST_INTERSECTION, SqlParser.ST_INTERSECTS, SqlParser.ST_ISCLOSED, SqlParser.ST_ISEMPTY, SqlParser.ST_ISSIMPLE, SqlParser.ST_LINEFROMTEXT, SqlParser.ST_LINEFROMWKB, SqlParser.ST_LINESTRINGFROMTEXT, SqlParser.ST_LINESTRINGFROMWKB, SqlParser.ST_NUMGEOMETRIES, SqlParser.ST_NUMINTERIORRING, SqlParser.ST_NUMINTERIORRINGS, SqlParser.ST_NUMPOINTS, SqlParser.ST_OVERLAPS, SqlParser.ST_POINTFROMTEXT, SqlParser.ST_POINTFROMWKB, SqlParser.ST_POINTN, SqlParser.ST_POLYFROMTEXT, SqlParser.ST_POLYFROMWKB, SqlParser.ST_POLYGONFROMTEXT, SqlParser.ST_POLYGONFROMWKB, SqlParser.ST_SRID, SqlParser.ST_STARTPOINT, SqlParser.ST_SYMDIFFERENCE, SqlParser.ST_TOUCHES, SqlParser.ST_UNION, SqlParser.ST_WITHIN, SqlParser.ST_X, SqlParser.ST_Y, SqlParser.SUBDATE, SqlParser.SUBSTRING_INDEX, SqlParser.SUBTIME, SqlParser.SYSTEM_USER, SqlParser.TAN, SqlParser.TIMEDIFF, SqlParser.TIMESTAMPADD, SqlParser.TIMESTAMPDIFF, SqlParser.TIME_FORMAT, SqlParser.TIME_TO_SEC, SqlParser.TOUCHES, SqlParser.TO_BASE64, SqlParser.TO_DAYS, SqlParser.TO_SECONDS, SqlParser.UCASE, SqlParser.UNCOMPRESS, SqlParser.UNCOMPRESSED_LENGTH, SqlParser.UNHEX, SqlParser.UNIX_TIMESTAMP, SqlParser.UPDATEXML, SqlParser.UPPER, SqlParser.UUID, SqlParser.UUID_SHORT, SqlParser.VALIDATE_PASSWORD_STRENGTH, SqlParser.VERSION, SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, SqlParser.WEEKDAY, SqlParser.WEEKOFYEAR, SqlParser.WEIGHT_STRING, SqlParser.WITHIN, SqlParser.YEARWEEK, SqlParser.Y_FUNCTION, SqlParser.X_FUNCTION, SqlParser.CHARSET_REVERSE_QOUTE_STRING, SqlParser.ID, SqlParser.REVERSE_QUOTE_ID]:
                localctx = SqlParser.AtomTableItemContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 244
                self.tableName()
                self.state = 249
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                if la_ == 1:
                    self.state = 246
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==SqlParser.AS:
                        self.state = 245
                        self.match(SqlParser.AS)


                    self.state = 248
                    localctx.alias = self.uid()


                pass
            elif token in [SqlParser.SELECT, SqlParser.LR_BRACKET]:
                localctx = SqlParser.SubqueryTableItemContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 256
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
                if la_ == 1:
                    self.state = 251
                    self.selectStatement()
                    pass

                elif la_ == 2:
                    self.state = 252
                    self.match(SqlParser.LR_BRACKET)
                    self.state = 253
                    localctx.parenthesisSubquery = self.selectStatement()
                    self.state = 254
                    self.match(SqlParser.RR_BRACKET)
                    pass


                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.AS:
                    self.state = 258
                    self.match(SqlParser.AS)


                self.state = 261
                localctx.alias = self.uid()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class JoinPartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_joinPart

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class InnerJoinContext(JoinPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.JoinPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def JOIN(self):
            return self.getToken(SqlParser.JOIN, 0)
        def tableSourceItem(self):
            return self.getTypedRuleContext(SqlParser.TableSourceItemContext,0)

        def ON(self):
            return self.getToken(SqlParser.ON, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)

        def INNER(self):
            return self.getToken(SqlParser.INNER, 0)
        def CROSS(self):
            return self.getToken(SqlParser.CROSS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInnerJoin" ):
                listener.enterInnerJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInnerJoin" ):
                listener.exitInnerJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInnerJoin" ):
                return visitor.visitInnerJoin(self)
            else:
                return visitor.visitChildren(self)


    class OuterJoinContext(JoinPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.JoinPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def JOIN(self):
            return self.getToken(SqlParser.JOIN, 0)
        def tableSourceItem(self):
            return self.getTypedRuleContext(SqlParser.TableSourceItemContext,0)

        def LEFT(self):
            return self.getToken(SqlParser.LEFT, 0)
        def RIGHT(self):
            return self.getToken(SqlParser.RIGHT, 0)
        def ON(self):
            return self.getToken(SqlParser.ON, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)

        def OUTER(self):
            return self.getToken(SqlParser.OUTER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOuterJoin" ):
                listener.enterOuterJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOuterJoin" ):
                listener.exitOuterJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOuterJoin" ):
                return visitor.visitOuterJoin(self)
            else:
                return visitor.visitChildren(self)


    class StraightJoinContext(JoinPartContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.JoinPartContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRAIGHT_JOIN(self):
            return self.getToken(SqlParser.STRAIGHT_JOIN, 0)
        def tableSourceItem(self):
            return self.getTypedRuleContext(SqlParser.TableSourceItemContext,0)

        def ON(self):
            return self.getToken(SqlParser.ON, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStraightJoin" ):
                listener.enterStraightJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStraightJoin" ):
                listener.exitStraightJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStraightJoin" ):
                return visitor.visitStraightJoin(self)
            else:
                return visitor.visitChildren(self)



    def joinPart(self):

        localctx = SqlParser.JoinPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_joinPart)
        self._la = 0 # Token type
        try:
            self.state = 289
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.CROSS, SqlParser.INNER, SqlParser.JOIN]:
                localctx = SqlParser.InnerJoinContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 266
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.CROSS or _la==SqlParser.INNER:
                    self.state = 265
                    _la = self._input.LA(1)
                    if not(_la==SqlParser.CROSS or _la==SqlParser.INNER):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 268
                self.match(SqlParser.JOIN)
                self.state = 269
                self.tableSourceItem()
                self.state = 272
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.ON:
                    self.state = 270
                    self.match(SqlParser.ON)
                    self.state = 271
                    self.expression(0)


                pass
            elif token in [SqlParser.STRAIGHT_JOIN]:
                localctx = SqlParser.StraightJoinContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 274
                self.match(SqlParser.STRAIGHT_JOIN)
                self.state = 275
                self.tableSourceItem()
                self.state = 278
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.ON:
                    self.state = 276
                    self.match(SqlParser.ON)
                    self.state = 277
                    self.expression(0)


                pass
            elif token in [SqlParser.LEFT, SqlParser.RIGHT]:
                localctx = SqlParser.OuterJoinContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 280
                _la = self._input.LA(1)
                if not(_la==SqlParser.LEFT or _la==SqlParser.RIGHT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.OUTER:
                    self.state = 281
                    self.match(SqlParser.OUTER)


                self.state = 284
                self.match(SqlParser.JOIN)
                self.state = 285
                self.tableSourceItem()

                self.state = 286
                self.match(SqlParser.ON)
                self.state = 287
                self.expression(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QueryExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def querySpecification(self):
            return self.getTypedRuleContext(SqlParser.QuerySpecificationContext,0)


        def queryExpression(self):
            return self.getTypedRuleContext(SqlParser.QueryExpressionContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_queryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryExpression" ):
                listener.enterQueryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryExpression" ):
                listener.exitQueryExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryExpression" ):
                return visitor.visitQueryExpression(self)
            else:
                return visitor.visitChildren(self)




    def queryExpression(self):

        localctx = SqlParser.QueryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_queryExpression)
        try:
            self.state = 299
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 291
                self.match(SqlParser.LR_BRACKET)
                self.state = 292
                self.querySpecification()
                self.state = 293
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 295
                self.match(SqlParser.LR_BRACKET)
                self.state = 296
                self.queryExpression()
                self.state = 297
                self.match(SqlParser.RR_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QuerySpecificationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(SqlParser.SELECT, 0)

        def selectElements(self):
            return self.getTypedRuleContext(SqlParser.SelectElementsContext,0)


        def selectSpec(self):
            return self.getTypedRuleContext(SqlParser.SelectSpecContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(SqlParser.FromClauseContext,0)


        def orderByClause(self):
            return self.getTypedRuleContext(SqlParser.OrderByClauseContext,0)


        def limitClause(self):
            return self.getTypedRuleContext(SqlParser.LimitClauseContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_querySpecification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuerySpecification" ):
                listener.enterQuerySpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuerySpecification" ):
                listener.exitQuerySpecification(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuerySpecification" ):
                return visitor.visitQuerySpecification(self)
            else:
                return visitor.visitChildren(self)




    def querySpecification(self):

        localctx = SqlParser.QuerySpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_querySpecification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self.match(SqlParser.SELECT)
            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlParser.ALL) | (1 << SqlParser.DISTINCT) | (1 << SqlParser.DISTINCTROW))) != 0):
                self.state = 302
                self.selectSpec()


            self.state = 305
            self.selectElements()
            self.state = 307
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.FROM:
                self.state = 306
                self.fromClause()


            self.state = 310
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.ORDER:
                self.state = 309
                self.orderByClause()


            self.state = 313
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.LIMIT:
                self.state = 312
                self.limitClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SelectSpecContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(SqlParser.ALL, 0)

        def DISTINCT(self):
            return self.getToken(SqlParser.DISTINCT, 0)

        def DISTINCTROW(self):
            return self.getToken(SqlParser.DISTINCTROW, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_selectSpec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectSpec" ):
                listener.enterSelectSpec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectSpec" ):
                listener.exitSelectSpec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectSpec" ):
                return visitor.visitSelectSpec(self)
            else:
                return visitor.visitChildren(self)




    def selectSpec(self):

        localctx = SqlParser.SelectSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_selectSpec)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 315
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlParser.ALL) | (1 << SqlParser.DISTINCT) | (1 << SqlParser.DISTINCTROW))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SelectElementsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.star = None # Token

        def selectElement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.SelectElementContext)
            else:
                return self.getTypedRuleContext(SqlParser.SelectElementContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_selectElements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectElements" ):
                listener.enterSelectElements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectElements" ):
                listener.exitSelectElements(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectElements" ):
                return visitor.visitSelectElements(self)
            else:
                return visitor.visitChildren(self)




    def selectElements(self):

        localctx = SqlParser.SelectElementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_selectElements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.STAR]:
                self.state = 317
                localctx.star = self.match(SqlParser.STAR)
                pass
            elif token in [SqlParser.CASE, SqlParser.CAST, SqlParser.CONVERT, SqlParser.CURRENT_USER, SqlParser.DATABASE, SqlParser.EXISTS, SqlParser.FALSE, SqlParser.IF, SqlParser.INSERT, SqlParser.INTERVAL, SqlParser.LEFT, SqlParser.NOT, SqlParser.NULL_LITERAL, SqlParser.REPLACE, SqlParser.RIGHT, SqlParser.TRUE, SqlParser.VALUES, SqlParser.DATE, SqlParser.TIME, SqlParser.TIMESTAMP, SqlParser.DATETIME, SqlParser.YEAR, SqlParser.CHAR, SqlParser.BINARY, SqlParser.TEXT, SqlParser.ENUM, SqlParser.SERIAL, SqlParser.AVG, SqlParser.BIT_AND, SqlParser.BIT_OR, SqlParser.BIT_XOR, SqlParser.COUNT, SqlParser.GROUP_CONCAT, SqlParser.MAX, SqlParser.MIN, SqlParser.STD, SqlParser.STDDEV, SqlParser.STDDEV_POP, SqlParser.STDDEV_SAMP, SqlParser.SUM, SqlParser.VAR_POP, SqlParser.VAR_SAMP, SqlParser.VARIANCE, SqlParser.CURRENT_DATE, SqlParser.CURRENT_TIME, SqlParser.CURRENT_TIMESTAMP, SqlParser.LOCALTIME, SqlParser.CURDATE, SqlParser.CURTIME, SqlParser.DATE_ADD, SqlParser.DATE_SUB, SqlParser.EXTRACT, SqlParser.LOCALTIMESTAMP, SqlParser.NOW, SqlParser.POSITION, SqlParser.SUBSTR, SqlParser.SUBSTRING, SqlParser.SYSDATE, SqlParser.TRIM, SqlParser.UTC_DATE, SqlParser.UTC_TIME, SqlParser.UTC_TIMESTAMP, SqlParser.ACCOUNT, SqlParser.ACTION, SqlParser.AFTER, SqlParser.AGGREGATE, SqlParser.ALGORITHM, SqlParser.ANY, SqlParser.AT, SqlParser.AUTHORS, SqlParser.AUTOCOMMIT, SqlParser.AUTOEXTEND_SIZE, SqlParser.AUTO_INCREMENT, SqlParser.AVG_ROW_LENGTH, SqlParser.BEGIN, SqlParser.BINLOG, SqlParser.BIT, SqlParser.BLOCK, SqlParser.BOOL, SqlParser.BOOLEAN, SqlParser.BTREE, SqlParser.CACHE, SqlParser.CASCADED, SqlParser.CHAIN, SqlParser.CHANGED, SqlParser.CHANNEL, SqlParser.CHECKSUM, SqlParser.CIPHER, SqlParser.CLIENT, SqlParser.CLOSE, SqlParser.COALESCE, SqlParser.CODE, SqlParser.COLUMNS, SqlParser.COLUMN_FORMAT, SqlParser.COMMENT, SqlParser.COMMIT, SqlParser.COMPACT, SqlParser.COMPLETION, SqlParser.COMPRESSED, SqlParser.COMPRESSION, SqlParser.CONCURRENT, SqlParser.CONNECTION, SqlParser.CONSISTENT, SqlParser.CONTAINS, SqlParser.CONTEXT, SqlParser.CONTRIBUTORS, SqlParser.COPY, SqlParser.CPU, SqlParser.DATA, SqlParser.DATAFILE, SqlParser.DEALLOCATE, SqlParser.DEFAULT_AUTH, SqlParser.DEFINER, SqlParser.DELAY_KEY_WRITE, SqlParser.DES_KEY_FILE, SqlParser.DIRECTORY, SqlParser.DISABLE, SqlParser.DISCARD, SqlParser.DISK, SqlParser.DO, SqlParser.DUMPFILE, SqlParser.DUPLICATE, SqlParser.DYNAMIC, SqlParser.ENABLE, SqlParser.ENCRYPTION, SqlParser.END, SqlParser.ENDS, SqlParser.ENGINE, SqlParser.ENGINES, SqlParser.ERROR, SqlParser.ERRORS, SqlParser.ESCAPE, SqlParser.EVEN, SqlParser.EVENT, SqlParser.EVENTS, SqlParser.EVERY, SqlParser.EXCHANGE, SqlParser.EXCLUSIVE, SqlParser.EXPIRE, SqlParser.EXPORT, SqlParser.EXTENDED, SqlParser.EXTENT_SIZE, SqlParser.FAST, SqlParser.FAULTS, SqlParser.FIELDS, SqlParser.FILE_BLOCK_SIZE, SqlParser.FILTER, SqlParser.FIRST, SqlParser.FIXED, SqlParser.FLUSH, SqlParser.FOLLOWS, SqlParser.FOUND, SqlParser.FULL, SqlParser.FUNCTION, SqlParser.GENERAL, SqlParser.GLOBAL, SqlParser.GRANTS, SqlParser.GROUP_REPLICATION, SqlParser.HANDLER, SqlParser.HASH, SqlParser.HELP, SqlParser.HOST, SqlParser.HOSTS, SqlParser.IDENTIFIED, SqlParser.IGNORE_SERVER_IDS, SqlParser.IMPORT, SqlParser.INDEXES, SqlParser.INITIAL_SIZE, SqlParser.INPLACE, SqlParser.INSERT_METHOD, SqlParser.INSTALL, SqlParser.INSTANCE, SqlParser.INVOKER, SqlParser.IO, SqlParser.IO_THREAD, SqlParser.IPC, SqlParser.ISOLATION, SqlParser.ISSUER, SqlParser.JSON, SqlParser.KEY_BLOCK_SIZE, SqlParser.LANGUAGE, SqlParser.LAST, SqlParser.LEAVES, SqlParser.LESS, SqlParser.LEVEL, SqlParser.LIST, SqlParser.LOCAL, SqlParser.LOGFILE, SqlParser.LOGS, SqlParser.MASTER, SqlParser.MASTER_AUTO_POSITION, SqlParser.MASTER_CONNECT_RETRY, SqlParser.MASTER_DELAY, SqlParser.MASTER_HEARTBEAT_PERIOD, SqlParser.MASTER_HOST, SqlParser.MASTER_LOG_FILE, SqlParser.MASTER_LOG_POS, SqlParser.MASTER_PASSWORD, SqlParser.MASTER_PORT, SqlParser.MASTER_RETRY_COUNT, SqlParser.MASTER_SSL, SqlParser.MASTER_SSL_CA, SqlParser.MASTER_SSL_CAPATH, SqlParser.MASTER_SSL_CERT, SqlParser.MASTER_SSL_CIPHER, SqlParser.MASTER_SSL_CRL, SqlParser.MASTER_SSL_CRLPATH, SqlParser.MASTER_SSL_KEY, SqlParser.MASTER_TLS_VERSION, SqlParser.MASTER_USER, SqlParser.MAX_CONNECTIONS_PER_HOUR, SqlParser.MAX_QUERIES_PER_HOUR, SqlParser.MAX_ROWS, SqlParser.MAX_SIZE, SqlParser.MAX_UPDATES_PER_HOUR, SqlParser.MAX_USER_CONNECTIONS, SqlParser.MEDIUM, SqlParser.MERGE, SqlParser.MID, SqlParser.MIGRATE, SqlParser.MIN_ROWS, SqlParser.MODE, SqlParser.MODIFY, SqlParser.MUTEX, SqlParser.MYSQL, SqlParser.NAME, SqlParser.NAMES, SqlParser.NCHAR, SqlParser.NEVER, SqlParser.NEXT, SqlParser.NO, SqlParser.NODEGROUP, SqlParser.NONE, SqlParser.OFFLINE, SqlParser.OFFSET, SqlParser.OJ, SqlParser.OLD_PASSWORD, SqlParser.ONE, SqlParser.ONLINE, SqlParser.ONLY, SqlParser.OPEN, SqlParser.OPTIMIZER_COSTS, SqlParser.OPTIONS, SqlParser.OWNER, SqlParser.PACK_KEYS, SqlParser.PAGE, SqlParser.PARSER, SqlParser.PARTIAL, SqlParser.PARTITIONING, SqlParser.PARTITIONS, SqlParser.PASSWORD, SqlParser.PHASE, SqlParser.PLUGIN, SqlParser.PLUGIN_DIR, SqlParser.PLUGINS, SqlParser.PORT, SqlParser.PRECEDES, SqlParser.PREPARE, SqlParser.PRESERVE, SqlParser.PREV, SqlParser.PROCESSLIST, SqlParser.PROFILE, SqlParser.PROFILES, SqlParser.PROXY, SqlParser.QUERY, SqlParser.QUICK, SqlParser.REBUILD, SqlParser.RECOVER, SqlParser.REDO_BUFFER_SIZE, SqlParser.REDUNDANT, SqlParser.RELAY, SqlParser.RELAY_LOG_FILE, SqlParser.RELAY_LOG_POS, SqlParser.RELAYLOG, SqlParser.REMOVE, SqlParser.REORGANIZE, SqlParser.REPAIR, SqlParser.REPLICATE_DO_DB, SqlParser.REPLICATE_DO_TABLE, SqlParser.REPLICATE_IGNORE_DB, SqlParser.REPLICATE_IGNORE_TABLE, SqlParser.REPLICATE_REWRITE_DB, SqlParser.REPLICATE_WILD_DO_TABLE, SqlParser.REPLICATE_WILD_IGNORE_TABLE, SqlParser.REPLICATION, SqlParser.RESET, SqlParser.RESUME, SqlParser.RETURNS, SqlParser.ROLLBACK, SqlParser.ROLLUP, SqlParser.ROTATE, SqlParser.ROW, SqlParser.ROWS, SqlParser.ROW_FORMAT, SqlParser.SAVEPOINT, SqlParser.SCHEDULE, SqlParser.SECURITY, SqlParser.SERVER, SqlParser.SESSION, SqlParser.SHARE, SqlParser.SHARED, SqlParser.SIGNED, SqlParser.SIMPLE, SqlParser.SLAVE, SqlParser.SLOW, SqlParser.SNAPSHOT, SqlParser.SOCKET, SqlParser.SOME, SqlParser.SONAME, SqlParser.SOUNDS, SqlParser.SOURCE, SqlParser.SQL_AFTER_GTIDS, SqlParser.SQL_AFTER_MTS_GAPS, SqlParser.SQL_BEFORE_GTIDS, SqlParser.SQL_BUFFER_RESULT, SqlParser.SQL_CACHE, SqlParser.SQL_NO_CACHE, SqlParser.SQL_THREAD, SqlParser.START, SqlParser.STARTS, SqlParser.STATS_AUTO_RECALC, SqlParser.STATS_PERSISTENT, SqlParser.STATS_SAMPLE_PAGES, SqlParser.STATUS, SqlParser.STOP, SqlParser.STORAGE, SqlParser.STRING, SqlParser.SUBJECT, SqlParser.SUBPARTITION, SqlParser.SUBPARTITIONS, SqlParser.SUSPEND, SqlParser.SWAPS, SqlParser.SWITCHES, SqlParser.TABLESPACE, SqlParser.TEMPORARY, SqlParser.TEMPTABLE, SqlParser.THAN, SqlParser.TRADITIONAL, SqlParser.TRANSACTION, SqlParser.TRIGGERS, SqlParser.TRUNCATE, SqlParser.UNDEFINED, SqlParser.UNDOFILE, SqlParser.UNDO_BUFFER_SIZE, SqlParser.UNINSTALL, SqlParser.UNKNOWN, SqlParser.UNTIL, SqlParser.UPGRADE, SqlParser.USER, SqlParser.USE_FRM, SqlParser.USER_RESOURCES, SqlParser.VALIDATION, SqlParser.VALUE, SqlParser.VARIABLES, SqlParser.VIEW, SqlParser.WAIT, SqlParser.WARNINGS, SqlParser.WITHOUT, SqlParser.WORK, SqlParser.WRAPPER, SqlParser.X509, SqlParser.XA, SqlParser.XML, SqlParser.QUARTER, SqlParser.MONTH, SqlParser.DAY, SqlParser.HOUR, SqlParser.MINUTE, SqlParser.WEEK, SqlParser.SECOND, SqlParser.MICROSECOND, SqlParser.ASCII, SqlParser.MEMORY, SqlParser.GEOMETRYCOLLECTION, SqlParser.LINESTRING, SqlParser.MULTILINESTRING, SqlParser.MULTIPOINT, SqlParser.MULTIPOLYGON, SqlParser.POINT, SqlParser.POLYGON, SqlParser.ABS, SqlParser.ACOS, SqlParser.ADDDATE, SqlParser.ADDTIME, SqlParser.AES_DECRYPT, SqlParser.AES_ENCRYPT, SqlParser.AREA, SqlParser.ASBINARY, SqlParser.ASIN, SqlParser.ASTEXT, SqlParser.ASWKB, SqlParser.ASWKT, SqlParser.ASYMMETRIC_DECRYPT, SqlParser.ASYMMETRIC_DERIVE, SqlParser.ASYMMETRIC_ENCRYPT, SqlParser.ASYMMETRIC_SIGN, SqlParser.ASYMMETRIC_VERIFY, SqlParser.ATAN, SqlParser.ATAN2, SqlParser.BENCHMARK, SqlParser.BIN, SqlParser.BIT_COUNT, SqlParser.BIT_LENGTH, SqlParser.BUFFER, SqlParser.CEIL, SqlParser.CEILING, SqlParser.CENTROID, SqlParser.CHARACTER_LENGTH, SqlParser.CHARSET, SqlParser.CHAR_LENGTH, SqlParser.COERCIBILITY, SqlParser.COLLATION, SqlParser.COMPRESS, SqlParser.CONCAT, SqlParser.CONCAT_WS, SqlParser.CONNECTION_ID, SqlParser.CONV, SqlParser.CONVERT_TZ, SqlParser.COS, SqlParser.COT, SqlParser.CRC32, SqlParser.CREATE_ASYMMETRIC_PRIV_KEY, SqlParser.CREATE_ASYMMETRIC_PUB_KEY, SqlParser.CREATE_DH_PARAMETERS, SqlParser.CREATE_DIGEST, SqlParser.CROSSES, SqlParser.DATEDIFF, SqlParser.DATE_FORMAT, SqlParser.DAYNAME, SqlParser.DAYOFMONTH, SqlParser.DAYOFWEEK, SqlParser.DAYOFYEAR, SqlParser.DECODE, SqlParser.DEGREES, SqlParser.DES_DECRYPT, SqlParser.DES_ENCRYPT, SqlParser.DIMENSION, SqlParser.DISJOINT, SqlParser.ELT, SqlParser.ENCODE, SqlParser.ENCRYPT, SqlParser.ENDPOINT, SqlParser.ENVELOPE, SqlParser.EQUALS, SqlParser.EXP, SqlParser.EXPORT_SET, SqlParser.EXTERIORRING, SqlParser.EXTRACTVALUE, SqlParser.FIELD, SqlParser.FIND_IN_SET, SqlParser.FLOOR, SqlParser.FORMAT, SqlParser.FOUND_ROWS, SqlParser.FROM_BASE64, SqlParser.FROM_DAYS, SqlParser.FROM_UNIXTIME, SqlParser.GEOMCOLLFROMTEXT, SqlParser.GEOMCOLLFROMWKB, SqlParser.GEOMETRYCOLLECTIONFROMTEXT, SqlParser.GEOMETRYCOLLECTIONFROMWKB, SqlParser.GEOMETRYFROMTEXT, SqlParser.GEOMETRYFROMWKB, SqlParser.GEOMETRYN, SqlParser.GEOMETRYTYPE, SqlParser.GEOMFROMTEXT, SqlParser.GEOMFROMWKB, SqlParser.GET_FORMAT, SqlParser.GET_LOCK, SqlParser.GLENGTH, SqlParser.GREATEST, SqlParser.GTID_SUBSET, SqlParser.GTID_SUBTRACT, SqlParser.HEX, SqlParser.IFNULL, SqlParser.INET6_ATON, SqlParser.INET6_NTOA, SqlParser.INET_ATON, SqlParser.INET_NTOA, SqlParser.INSTR, SqlParser.INTERIORRINGN, SqlParser.INTERSECTS, SqlParser.ISCLOSED, SqlParser.ISEMPTY, SqlParser.ISNULL, SqlParser.ISSIMPLE, SqlParser.IS_FREE_LOCK, SqlParser.IS_IPV4, SqlParser.IS_IPV4_COMPAT, SqlParser.IS_IPV4_MAPPED, SqlParser.IS_IPV6, SqlParser.IS_USED_LOCK, SqlParser.LAST_INSERT_ID, SqlParser.LCASE, SqlParser.LEAST, SqlParser.LENGTH, SqlParser.LINEFROMTEXT, SqlParser.LINEFROMWKB, SqlParser.LINESTRINGFROMTEXT, SqlParser.LINESTRINGFROMWKB, SqlParser.LN, SqlParser.LOAD_FILE, SqlParser.LOCATE, SqlParser.LOG, SqlParser.LOG10, SqlParser.LOG2, SqlParser.LOWER, SqlParser.LPAD, SqlParser.LTRIM, SqlParser.MAKEDATE, SqlParser.MAKETIME, SqlParser.MAKE_SET, SqlParser.MASTER_POS_WAIT, SqlParser.MBRCONTAINS, SqlParser.MBRDISJOINT, SqlParser.MBREQUAL, SqlParser.MBRINTERSECTS, SqlParser.MBROVERLAPS, SqlParser.MBRTOUCHES, SqlParser.MBRWITHIN, SqlParser.MD5, SqlParser.MLINEFROMTEXT, SqlParser.MLINEFROMWKB, SqlParser.MONTHNAME, SqlParser.MPOINTFROMTEXT, SqlParser.MPOINTFROMWKB, SqlParser.MPOLYFROMTEXT, SqlParser.MPOLYFROMWKB, SqlParser.MULTILINESTRINGFROMTEXT, SqlParser.MULTILINESTRINGFROMWKB, SqlParser.MULTIPOINTFROMTEXT, SqlParser.MULTIPOINTFROMWKB, SqlParser.MULTIPOLYGONFROMTEXT, SqlParser.MULTIPOLYGONFROMWKB, SqlParser.NAME_CONST, SqlParser.NULLIF, SqlParser.NUMGEOMETRIES, SqlParser.NUMINTERIORRINGS, SqlParser.NUMPOINTS, SqlParser.OCT, SqlParser.OCTET_LENGTH, SqlParser.ORD, SqlParser.OVERLAPS, SqlParser.PERIOD_ADD, SqlParser.PERIOD_DIFF, SqlParser.PI, SqlParser.POINTFROMTEXT, SqlParser.POINTFROMWKB, SqlParser.POINTN, SqlParser.POLYFROMTEXT, SqlParser.POLYFROMWKB, SqlParser.POLYGONFROMTEXT, SqlParser.POLYGONFROMWKB, SqlParser.POW, SqlParser.POWER, SqlParser.QUOTE, SqlParser.RADIANS, SqlParser.RAND, SqlParser.RANDOM_BYTES, SqlParser.RELEASE_LOCK, SqlParser.REVERSE, SqlParser.ROUND, SqlParser.ROW_COUNT, SqlParser.RPAD, SqlParser.RTRIM, SqlParser.SEC_TO_TIME, SqlParser.SESSION_USER, SqlParser.SHA, SqlParser.SHA1, SqlParser.SHA2, SqlParser.SIGN, SqlParser.SIN, SqlParser.SLEEP, SqlParser.SOUNDEX, SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, SqlParser.SQRT, SqlParser.SRID, SqlParser.STARTPOINT, SqlParser.STRCMP, SqlParser.STR_TO_DATE, SqlParser.ST_AREA, SqlParser.ST_ASBINARY, SqlParser.ST_ASTEXT, SqlParser.ST_ASWKB, SqlParser.ST_ASWKT, SqlParser.ST_BUFFER, SqlParser.ST_CENTROID, SqlParser.ST_CONTAINS, SqlParser.ST_CROSSES, SqlParser.ST_DIFFERENCE, SqlParser.ST_DIMENSION, SqlParser.ST_DISJOINT, SqlParser.ST_DISTANCE, SqlParser.ST_ENDPOINT, SqlParser.ST_ENVELOPE, SqlParser.ST_EQUALS, SqlParser.ST_EXTERIORRING, SqlParser.ST_GEOMCOLLFROMTEXT, SqlParser.ST_GEOMCOLLFROMTXT, SqlParser.ST_GEOMCOLLFROMWKB, SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, SqlParser.ST_GEOMETRYFROMTEXT, SqlParser.ST_GEOMETRYFROMWKB, SqlParser.ST_GEOMETRYN, SqlParser.ST_GEOMETRYTYPE, SqlParser.ST_GEOMFROMTEXT, SqlParser.ST_GEOMFROMWKB, SqlParser.ST_INTERIORRINGN, SqlParser.ST_INTERSECTION, SqlParser.ST_INTERSECTS, SqlParser.ST_ISCLOSED, SqlParser.ST_ISEMPTY, SqlParser.ST_ISSIMPLE, SqlParser.ST_LINEFROMTEXT, SqlParser.ST_LINEFROMWKB, SqlParser.ST_LINESTRINGFROMTEXT, SqlParser.ST_LINESTRINGFROMWKB, SqlParser.ST_NUMGEOMETRIES, SqlParser.ST_NUMINTERIORRING, SqlParser.ST_NUMINTERIORRINGS, SqlParser.ST_NUMPOINTS, SqlParser.ST_OVERLAPS, SqlParser.ST_POINTFROMTEXT, SqlParser.ST_POINTFROMWKB, SqlParser.ST_POINTN, SqlParser.ST_POLYFROMTEXT, SqlParser.ST_POLYFROMWKB, SqlParser.ST_POLYGONFROMTEXT, SqlParser.ST_POLYGONFROMWKB, SqlParser.ST_SRID, SqlParser.ST_STARTPOINT, SqlParser.ST_SYMDIFFERENCE, SqlParser.ST_TOUCHES, SqlParser.ST_UNION, SqlParser.ST_WITHIN, SqlParser.ST_X, SqlParser.ST_Y, SqlParser.SUBDATE, SqlParser.SUBSTRING_INDEX, SqlParser.SUBTIME, SqlParser.SYSTEM_USER, SqlParser.TAN, SqlParser.TIMEDIFF, SqlParser.TIMESTAMPADD, SqlParser.TIMESTAMPDIFF, SqlParser.TIME_FORMAT, SqlParser.TIME_TO_SEC, SqlParser.TOUCHES, SqlParser.TO_BASE64, SqlParser.TO_DAYS, SqlParser.TO_SECONDS, SqlParser.UCASE, SqlParser.UNCOMPRESS, SqlParser.UNCOMPRESSED_LENGTH, SqlParser.UNHEX, SqlParser.UNIX_TIMESTAMP, SqlParser.UPDATEXML, SqlParser.UPPER, SqlParser.UUID, SqlParser.UUID_SHORT, SqlParser.VALIDATE_PASSWORD_STRENGTH, SqlParser.VERSION, SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, SqlParser.WEEKDAY, SqlParser.WEEKOFYEAR, SqlParser.WEIGHT_STRING, SqlParser.WITHIN, SqlParser.YEARWEEK, SqlParser.Y_FUNCTION, SqlParser.X_FUNCTION, SqlParser.PLUS, SqlParser.MINUS, SqlParser.EXCLAMATION_SYMBOL, SqlParser.BIT_NOT_OP, SqlParser.LR_BRACKET, SqlParser.ZERO_DECIMAL, SqlParser.ONE_DECIMAL, SqlParser.TWO_DECIMAL, SqlParser.CHARSET_REVERSE_QOUTE_STRING, SqlParser.STRING_LITERAL, SqlParser.DECIMAL_LITERAL, SqlParser.HEXADECIMAL_LITERAL, SqlParser.ID, SqlParser.REVERSE_QUOTE_ID, SqlParser.LOCAL_ID]:
                self.state = 318
                self.selectElement()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 325
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 321
                self.match(SqlParser.COMMA)
                self.state = 322
                self.selectElement()
                self.state = 327
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SelectElementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_selectElement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SelectExpressionElementContext(SelectElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SelectElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)

        def LOCAL_ID(self):
            return self.getToken(SqlParser.LOCAL_ID, 0)
        def VAR_ASSIGN(self):
            return self.getToken(SqlParser.VAR_ASSIGN, 0)
        def uid(self):
            return self.getTypedRuleContext(SqlParser.UidContext,0)

        def AS(self):
            return self.getToken(SqlParser.AS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectExpressionElement" ):
                listener.enterSelectExpressionElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectExpressionElement" ):
                listener.exitSelectExpressionElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectExpressionElement" ):
                return visitor.visitSelectExpressionElement(self)
            else:
                return visitor.visitChildren(self)


    class SelectFunctionElementContext(SelectElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SelectElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionCall(self):
            return self.getTypedRuleContext(SqlParser.FunctionCallContext,0)

        def uid(self):
            return self.getTypedRuleContext(SqlParser.UidContext,0)

        def AS(self):
            return self.getToken(SqlParser.AS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectFunctionElement" ):
                listener.enterSelectFunctionElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectFunctionElement" ):
                listener.exitSelectFunctionElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectFunctionElement" ):
                return visitor.visitSelectFunctionElement(self)
            else:
                return visitor.visitChildren(self)


    class SelectStarElementContext(SelectElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SelectElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fullId(self):
            return self.getTypedRuleContext(SqlParser.FullIdContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectStarElement" ):
                listener.enterSelectStarElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectStarElement" ):
                listener.exitSelectStarElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectStarElement" ):
                return visitor.visitSelectStarElement(self)
            else:
                return visitor.visitChildren(self)


    class SelectColumnElementContext(SelectElementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SelectElementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fullColumnName(self):
            return self.getTypedRuleContext(SqlParser.FullColumnNameContext,0)

        def uid(self):
            return self.getTypedRuleContext(SqlParser.UidContext,0)

        def AS(self):
            return self.getToken(SqlParser.AS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectColumnElement" ):
                listener.enterSelectColumnElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectColumnElement" ):
                listener.exitSelectColumnElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectColumnElement" ):
                return visitor.visitSelectColumnElement(self)
            else:
                return visitor.visitChildren(self)



    def selectElement(self):

        localctx = SqlParser.SelectElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_selectElement)
        self._la = 0 # Token type
        try:
            self.state = 357
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                localctx = SqlParser.SelectStarElementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 328
                self.fullId()
                self.state = 329
                self.match(SqlParser.DOT)
                self.state = 330
                self.match(SqlParser.STAR)
                pass

            elif la_ == 2:
                localctx = SqlParser.SelectColumnElementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 332
                self.fullColumnName()
                self.state = 337
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
                if la_ == 1:
                    self.state = 334
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==SqlParser.AS:
                        self.state = 333
                        self.match(SqlParser.AS)


                    self.state = 336
                    self.uid()


                pass

            elif la_ == 3:
                localctx = SqlParser.SelectFunctionElementContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 339
                self.functionCall()
                self.state = 344
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
                if la_ == 1:
                    self.state = 341
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==SqlParser.AS:
                        self.state = 340
                        self.match(SqlParser.AS)


                    self.state = 343
                    self.uid()


                pass

            elif la_ == 4:
                localctx = SqlParser.SelectExpressionElementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 348
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
                if la_ == 1:
                    self.state = 346
                    self.match(SqlParser.LOCAL_ID)
                    self.state = 347
                    self.match(SqlParser.VAR_ASSIGN)


                self.state = 350
                self.expression(0)
                self.state = 355
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                if la_ == 1:
                    self.state = 352
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==SqlParser.AS:
                        self.state = 351
                        self.match(SqlParser.AS)


                    self.state = 354
                    self.uid()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FromClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.whereExpr = None # ExpressionContext
            self.havingExpr = None # ExpressionContext

        def FROM(self):
            return self.getToken(SqlParser.FROM, 0)

        def tableSources(self):
            return self.getTypedRuleContext(SqlParser.TableSourcesContext,0)


        def WHERE(self):
            return self.getToken(SqlParser.WHERE, 0)

        def GROUP(self):
            return self.getToken(SqlParser.GROUP, 0)

        def BY(self):
            return self.getToken(SqlParser.BY, 0)

        def groupByItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.GroupByItemContext)
            else:
                return self.getTypedRuleContext(SqlParser.GroupByItemContext,i)


        def HAVING(self):
            return self.getToken(SqlParser.HAVING, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromClause" ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromClause" ):
                listener.exitFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromClause" ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = SqlParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_fromClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.match(SqlParser.FROM)
            self.state = 360
            self.tableSources()
            self.state = 363
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.WHERE:
                self.state = 361
                self.match(SqlParser.WHERE)
                self.state = 362
                localctx.whereExpr = self.expression(0)


            self.state = 375
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.GROUP:
                self.state = 365
                self.match(SqlParser.GROUP)
                self.state = 366
                self.match(SqlParser.BY)
                self.state = 367
                self.groupByItem()
                self.state = 372
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlParser.COMMA:
                    self.state = 368
                    self.match(SqlParser.COMMA)
                    self.state = 369
                    self.groupByItem()
                    self.state = 374
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 379
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.HAVING:
                self.state = 377
                self.match(SqlParser.HAVING)
                self.state = 378
                localctx.havingExpr = self.expression(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GroupByItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.order = None # Token

        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)


        def ASC(self):
            return self.getToken(SqlParser.ASC, 0)

        def DESC(self):
            return self.getToken(SqlParser.DESC, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_groupByItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupByItem" ):
                listener.enterGroupByItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupByItem" ):
                listener.exitGroupByItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupByItem" ):
                return visitor.visitGroupByItem(self)
            else:
                return visitor.visitChildren(self)




    def groupByItem(self):

        localctx = SqlParser.GroupByItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_groupByItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            self.expression(0)
            self.state = 383
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.ASC or _la==SqlParser.DESC:
                self.state = 382
                localctx.order = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlParser.ASC or _la==SqlParser.DESC):
                    localctx.order = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LimitClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.offset = None # DecimalLiteralContext
            self.limit = None # DecimalLiteralContext

        def LIMIT(self):
            return self.getToken(SqlParser.LIMIT, 0)

        def OFFSET(self):
            return self.getToken(SqlParser.OFFSET, 0)

        def decimalLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.DecimalLiteralContext)
            else:
                return self.getTypedRuleContext(SqlParser.DecimalLiteralContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_limitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimitClause" ):
                listener.enterLimitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimitClause" ):
                listener.exitLimitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimitClause" ):
                return visitor.visitLimitClause(self)
            else:
                return visitor.visitChildren(self)




    def limitClause(self):

        localctx = SqlParser.LimitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_limitClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            self.match(SqlParser.LIMIT)
            self.state = 396
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 389
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
                if la_ == 1:
                    self.state = 386
                    localctx.offset = self.decimalLiteral()
                    self.state = 387
                    self.match(SqlParser.COMMA)


                self.state = 391
                localctx.limit = self.decimalLiteral()
                pass

            elif la_ == 2:
                self.state = 392
                localctx.limit = self.decimalLiteral()
                self.state = 393
                self.match(SqlParser.OFFSET)
                self.state = 394
                localctx.offset = self.decimalLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FullIdContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def uid(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.UidContext)
            else:
                return self.getTypedRuleContext(SqlParser.UidContext,i)


        def DOT_ID(self):
            return self.getToken(SqlParser.DOT_ID, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_fullId

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFullId" ):
                listener.enterFullId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFullId" ):
                listener.exitFullId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFullId" ):
                return visitor.visitFullId(self)
            else:
                return visitor.visitChildren(self)




    def fullId(self):

        localctx = SqlParser.FullIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_fullId)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.uid()
            self.state = 402
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.state = 399
                self.match(SqlParser.DOT_ID)

            elif la_ == 2:
                self.state = 400
                self.match(SqlParser.DOT)
                self.state = 401
                self.uid()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TableNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fullId(self):
            return self.getTypedRuleContext(SqlParser.FullIdContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_tableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableName" ):
                listener.enterTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableName" ):
                listener.exitTableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableName" ):
                return visitor.visitTableName(self)
            else:
                return visitor.visitChildren(self)




    def tableName(self):

        localctx = SqlParser.TableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_tableName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 404
            self.fullId()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FullColumnNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def uid(self):
            return self.getTypedRuleContext(SqlParser.UidContext,0)


        def dottedId(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.DottedIdContext)
            else:
                return self.getTypedRuleContext(SqlParser.DottedIdContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_fullColumnName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFullColumnName" ):
                listener.enterFullColumnName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFullColumnName" ):
                listener.exitFullColumnName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFullColumnName" ):
                return visitor.visitFullColumnName(self)
            else:
                return visitor.visitChildren(self)




    def fullColumnName(self):

        localctx = SqlParser.FullColumnNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_fullColumnName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 406
            self.uid()
            self.state = 411
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.state = 407
                self.dottedId()
                self.state = 409
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
                if la_ == 1:
                    self.state = 408
                    self.dottedId()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MysqlVariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCAL_ID(self):
            return self.getToken(SqlParser.LOCAL_ID, 0)

        def GLOBAL_ID(self):
            return self.getToken(SqlParser.GLOBAL_ID, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_mysqlVariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMysqlVariable" ):
                listener.enterMysqlVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMysqlVariable" ):
                listener.exitMysqlVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMysqlVariable" ):
                return visitor.visitMysqlVariable(self)
            else:
                return visitor.visitChildren(self)




    def mysqlVariable(self):

        localctx = SqlParser.MysqlVariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_mysqlVariable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            _la = self._input.LA(1)
            if not(_la==SqlParser.LOCAL_ID or _la==SqlParser.GLOBAL_ID):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UidContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simpleId(self):
            return self.getTypedRuleContext(SqlParser.SimpleIdContext,0)


        def REVERSE_QUOTE_ID(self):
            return self.getToken(SqlParser.REVERSE_QUOTE_ID, 0)

        def CHARSET_REVERSE_QOUTE_STRING(self):
            return self.getToken(SqlParser.CHARSET_REVERSE_QOUTE_STRING, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_uid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUid" ):
                listener.enterUid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUid" ):
                listener.exitUid(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUid" ):
                return visitor.visitUid(self)
            else:
                return visitor.visitChildren(self)




    def uid(self):

        localctx = SqlParser.UidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_uid)
        try:
            self.state = 418
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.DATABASE, SqlParser.LEFT, SqlParser.RIGHT, SqlParser.DATE, SqlParser.TIME, SqlParser.TIMESTAMP, SqlParser.DATETIME, SqlParser.YEAR, SqlParser.TEXT, SqlParser.ENUM, SqlParser.SERIAL, SqlParser.COUNT, SqlParser.POSITION, SqlParser.ACCOUNT, SqlParser.ACTION, SqlParser.AFTER, SqlParser.AGGREGATE, SqlParser.ALGORITHM, SqlParser.ANY, SqlParser.AT, SqlParser.AUTHORS, SqlParser.AUTOCOMMIT, SqlParser.AUTOEXTEND_SIZE, SqlParser.AUTO_INCREMENT, SqlParser.AVG_ROW_LENGTH, SqlParser.BEGIN, SqlParser.BINLOG, SqlParser.BIT, SqlParser.BLOCK, SqlParser.BOOL, SqlParser.BOOLEAN, SqlParser.BTREE, SqlParser.CACHE, SqlParser.CASCADED, SqlParser.CHAIN, SqlParser.CHANGED, SqlParser.CHANNEL, SqlParser.CHECKSUM, SqlParser.CIPHER, SqlParser.CLIENT, SqlParser.CLOSE, SqlParser.COALESCE, SqlParser.CODE, SqlParser.COLUMNS, SqlParser.COLUMN_FORMAT, SqlParser.COMMENT, SqlParser.COMMIT, SqlParser.COMPACT, SqlParser.COMPLETION, SqlParser.COMPRESSED, SqlParser.COMPRESSION, SqlParser.CONCURRENT, SqlParser.CONNECTION, SqlParser.CONSISTENT, SqlParser.CONTAINS, SqlParser.CONTEXT, SqlParser.CONTRIBUTORS, SqlParser.COPY, SqlParser.CPU, SqlParser.DATA, SqlParser.DATAFILE, SqlParser.DEALLOCATE, SqlParser.DEFAULT_AUTH, SqlParser.DEFINER, SqlParser.DELAY_KEY_WRITE, SqlParser.DES_KEY_FILE, SqlParser.DIRECTORY, SqlParser.DISABLE, SqlParser.DISCARD, SqlParser.DISK, SqlParser.DO, SqlParser.DUMPFILE, SqlParser.DUPLICATE, SqlParser.DYNAMIC, SqlParser.ENABLE, SqlParser.ENCRYPTION, SqlParser.END, SqlParser.ENDS, SqlParser.ENGINE, SqlParser.ENGINES, SqlParser.ERROR, SqlParser.ERRORS, SqlParser.ESCAPE, SqlParser.EVEN, SqlParser.EVENT, SqlParser.EVENTS, SqlParser.EVERY, SqlParser.EXCHANGE, SqlParser.EXCLUSIVE, SqlParser.EXPIRE, SqlParser.EXPORT, SqlParser.EXTENDED, SqlParser.EXTENT_SIZE, SqlParser.FAST, SqlParser.FAULTS, SqlParser.FIELDS, SqlParser.FILE_BLOCK_SIZE, SqlParser.FILTER, SqlParser.FIRST, SqlParser.FIXED, SqlParser.FLUSH, SqlParser.FOLLOWS, SqlParser.FOUND, SqlParser.FULL, SqlParser.FUNCTION, SqlParser.GENERAL, SqlParser.GLOBAL, SqlParser.GRANTS, SqlParser.GROUP_REPLICATION, SqlParser.HANDLER, SqlParser.HASH, SqlParser.HELP, SqlParser.HOST, SqlParser.HOSTS, SqlParser.IDENTIFIED, SqlParser.IGNORE_SERVER_IDS, SqlParser.IMPORT, SqlParser.INDEXES, SqlParser.INITIAL_SIZE, SqlParser.INPLACE, SqlParser.INSERT_METHOD, SqlParser.INSTALL, SqlParser.INSTANCE, SqlParser.INVOKER, SqlParser.IO, SqlParser.IO_THREAD, SqlParser.IPC, SqlParser.ISOLATION, SqlParser.ISSUER, SqlParser.JSON, SqlParser.KEY_BLOCK_SIZE, SqlParser.LANGUAGE, SqlParser.LAST, SqlParser.LEAVES, SqlParser.LESS, SqlParser.LEVEL, SqlParser.LIST, SqlParser.LOCAL, SqlParser.LOGFILE, SqlParser.LOGS, SqlParser.MASTER, SqlParser.MASTER_AUTO_POSITION, SqlParser.MASTER_CONNECT_RETRY, SqlParser.MASTER_DELAY, SqlParser.MASTER_HEARTBEAT_PERIOD, SqlParser.MASTER_HOST, SqlParser.MASTER_LOG_FILE, SqlParser.MASTER_LOG_POS, SqlParser.MASTER_PASSWORD, SqlParser.MASTER_PORT, SqlParser.MASTER_RETRY_COUNT, SqlParser.MASTER_SSL, SqlParser.MASTER_SSL_CA, SqlParser.MASTER_SSL_CAPATH, SqlParser.MASTER_SSL_CERT, SqlParser.MASTER_SSL_CIPHER, SqlParser.MASTER_SSL_CRL, SqlParser.MASTER_SSL_CRLPATH, SqlParser.MASTER_SSL_KEY, SqlParser.MASTER_TLS_VERSION, SqlParser.MASTER_USER, SqlParser.MAX_CONNECTIONS_PER_HOUR, SqlParser.MAX_QUERIES_PER_HOUR, SqlParser.MAX_ROWS, SqlParser.MAX_SIZE, SqlParser.MAX_UPDATES_PER_HOUR, SqlParser.MAX_USER_CONNECTIONS, SqlParser.MEDIUM, SqlParser.MERGE, SqlParser.MID, SqlParser.MIGRATE, SqlParser.MIN_ROWS, SqlParser.MODE, SqlParser.MODIFY, SqlParser.MUTEX, SqlParser.MYSQL, SqlParser.NAME, SqlParser.NAMES, SqlParser.NCHAR, SqlParser.NEVER, SqlParser.NEXT, SqlParser.NO, SqlParser.NODEGROUP, SqlParser.NONE, SqlParser.OFFLINE, SqlParser.OFFSET, SqlParser.OJ, SqlParser.OLD_PASSWORD, SqlParser.ONE, SqlParser.ONLINE, SqlParser.ONLY, SqlParser.OPEN, SqlParser.OPTIMIZER_COSTS, SqlParser.OPTIONS, SqlParser.OWNER, SqlParser.PACK_KEYS, SqlParser.PAGE, SqlParser.PARSER, SqlParser.PARTIAL, SqlParser.PARTITIONING, SqlParser.PARTITIONS, SqlParser.PASSWORD, SqlParser.PHASE, SqlParser.PLUGIN, SqlParser.PLUGIN_DIR, SqlParser.PLUGINS, SqlParser.PORT, SqlParser.PRECEDES, SqlParser.PREPARE, SqlParser.PRESERVE, SqlParser.PREV, SqlParser.PROCESSLIST, SqlParser.PROFILE, SqlParser.PROFILES, SqlParser.PROXY, SqlParser.QUERY, SqlParser.QUICK, SqlParser.REBUILD, SqlParser.RECOVER, SqlParser.REDO_BUFFER_SIZE, SqlParser.REDUNDANT, SqlParser.RELAY, SqlParser.RELAY_LOG_FILE, SqlParser.RELAY_LOG_POS, SqlParser.RELAYLOG, SqlParser.REMOVE, SqlParser.REORGANIZE, SqlParser.REPAIR, SqlParser.REPLICATE_DO_DB, SqlParser.REPLICATE_DO_TABLE, SqlParser.REPLICATE_IGNORE_DB, SqlParser.REPLICATE_IGNORE_TABLE, SqlParser.REPLICATE_REWRITE_DB, SqlParser.REPLICATE_WILD_DO_TABLE, SqlParser.REPLICATE_WILD_IGNORE_TABLE, SqlParser.REPLICATION, SqlParser.RESET, SqlParser.RESUME, SqlParser.RETURNS, SqlParser.ROLLBACK, SqlParser.ROLLUP, SqlParser.ROTATE, SqlParser.ROW, SqlParser.ROWS, SqlParser.ROW_FORMAT, SqlParser.SAVEPOINT, SqlParser.SCHEDULE, SqlParser.SECURITY, SqlParser.SERVER, SqlParser.SESSION, SqlParser.SHARE, SqlParser.SHARED, SqlParser.SIGNED, SqlParser.SIMPLE, SqlParser.SLAVE, SqlParser.SLOW, SqlParser.SNAPSHOT, SqlParser.SOCKET, SqlParser.SOME, SqlParser.SONAME, SqlParser.SOUNDS, SqlParser.SOURCE, SqlParser.SQL_AFTER_GTIDS, SqlParser.SQL_AFTER_MTS_GAPS, SqlParser.SQL_BEFORE_GTIDS, SqlParser.SQL_BUFFER_RESULT, SqlParser.SQL_CACHE, SqlParser.SQL_NO_CACHE, SqlParser.SQL_THREAD, SqlParser.START, SqlParser.STARTS, SqlParser.STATS_AUTO_RECALC, SqlParser.STATS_PERSISTENT, SqlParser.STATS_SAMPLE_PAGES, SqlParser.STATUS, SqlParser.STOP, SqlParser.STORAGE, SqlParser.STRING, SqlParser.SUBJECT, SqlParser.SUBPARTITION, SqlParser.SUBPARTITIONS, SqlParser.SUSPEND, SqlParser.SWAPS, SqlParser.SWITCHES, SqlParser.TABLESPACE, SqlParser.TEMPORARY, SqlParser.TEMPTABLE, SqlParser.THAN, SqlParser.TRADITIONAL, SqlParser.TRANSACTION, SqlParser.TRIGGERS, SqlParser.TRUNCATE, SqlParser.UNDEFINED, SqlParser.UNDOFILE, SqlParser.UNDO_BUFFER_SIZE, SqlParser.UNINSTALL, SqlParser.UNKNOWN, SqlParser.UNTIL, SqlParser.UPGRADE, SqlParser.USER, SqlParser.USE_FRM, SqlParser.USER_RESOURCES, SqlParser.VALIDATION, SqlParser.VALUE, SqlParser.VARIABLES, SqlParser.VIEW, SqlParser.WAIT, SqlParser.WARNINGS, SqlParser.WITHOUT, SqlParser.WORK, SqlParser.WRAPPER, SqlParser.X509, SqlParser.XA, SqlParser.XML, SqlParser.QUARTER, SqlParser.MONTH, SqlParser.DAY, SqlParser.HOUR, SqlParser.MINUTE, SqlParser.WEEK, SqlParser.SECOND, SqlParser.MICROSECOND, SqlParser.MEMORY, SqlParser.GEOMETRYCOLLECTION, SqlParser.LINESTRING, SqlParser.MULTILINESTRING, SqlParser.MULTIPOINT, SqlParser.MULTIPOLYGON, SqlParser.POINT, SqlParser.POLYGON, SqlParser.ABS, SqlParser.ACOS, SqlParser.ADDDATE, SqlParser.ADDTIME, SqlParser.AES_DECRYPT, SqlParser.AES_ENCRYPT, SqlParser.AREA, SqlParser.ASBINARY, SqlParser.ASIN, SqlParser.ASTEXT, SqlParser.ASWKB, SqlParser.ASWKT, SqlParser.ASYMMETRIC_DECRYPT, SqlParser.ASYMMETRIC_DERIVE, SqlParser.ASYMMETRIC_ENCRYPT, SqlParser.ASYMMETRIC_SIGN, SqlParser.ASYMMETRIC_VERIFY, SqlParser.ATAN, SqlParser.ATAN2, SqlParser.BENCHMARK, SqlParser.BIN, SqlParser.BIT_COUNT, SqlParser.BIT_LENGTH, SqlParser.BUFFER, SqlParser.CEIL, SqlParser.CEILING, SqlParser.CENTROID, SqlParser.CHARACTER_LENGTH, SqlParser.CHARSET, SqlParser.CHAR_LENGTH, SqlParser.COERCIBILITY, SqlParser.COLLATION, SqlParser.COMPRESS, SqlParser.CONCAT, SqlParser.CONCAT_WS, SqlParser.CONNECTION_ID, SqlParser.CONV, SqlParser.CONVERT_TZ, SqlParser.COS, SqlParser.COT, SqlParser.CRC32, SqlParser.CREATE_ASYMMETRIC_PRIV_KEY, SqlParser.CREATE_ASYMMETRIC_PUB_KEY, SqlParser.CREATE_DH_PARAMETERS, SqlParser.CREATE_DIGEST, SqlParser.CROSSES, SqlParser.DATEDIFF, SqlParser.DATE_FORMAT, SqlParser.DAYNAME, SqlParser.DAYOFMONTH, SqlParser.DAYOFWEEK, SqlParser.DAYOFYEAR, SqlParser.DECODE, SqlParser.DEGREES, SqlParser.DES_DECRYPT, SqlParser.DES_ENCRYPT, SqlParser.DIMENSION, SqlParser.DISJOINT, SqlParser.ELT, SqlParser.ENCODE, SqlParser.ENCRYPT, SqlParser.ENDPOINT, SqlParser.ENVELOPE, SqlParser.EQUALS, SqlParser.EXP, SqlParser.EXPORT_SET, SqlParser.EXTERIORRING, SqlParser.EXTRACTVALUE, SqlParser.FIELD, SqlParser.FIND_IN_SET, SqlParser.FLOOR, SqlParser.FORMAT, SqlParser.FOUND_ROWS, SqlParser.FROM_BASE64, SqlParser.FROM_DAYS, SqlParser.FROM_UNIXTIME, SqlParser.GEOMCOLLFROMTEXT, SqlParser.GEOMCOLLFROMWKB, SqlParser.GEOMETRYCOLLECTIONFROMTEXT, SqlParser.GEOMETRYCOLLECTIONFROMWKB, SqlParser.GEOMETRYFROMTEXT, SqlParser.GEOMETRYFROMWKB, SqlParser.GEOMETRYN, SqlParser.GEOMETRYTYPE, SqlParser.GEOMFROMTEXT, SqlParser.GEOMFROMWKB, SqlParser.GET_FORMAT, SqlParser.GET_LOCK, SqlParser.GLENGTH, SqlParser.GREATEST, SqlParser.GTID_SUBSET, SqlParser.GTID_SUBTRACT, SqlParser.HEX, SqlParser.IFNULL, SqlParser.INET6_ATON, SqlParser.INET6_NTOA, SqlParser.INET_ATON, SqlParser.INET_NTOA, SqlParser.INSTR, SqlParser.INTERIORRINGN, SqlParser.INTERSECTS, SqlParser.ISCLOSED, SqlParser.ISEMPTY, SqlParser.ISNULL, SqlParser.ISSIMPLE, SqlParser.IS_FREE_LOCK, SqlParser.IS_IPV4, SqlParser.IS_IPV4_COMPAT, SqlParser.IS_IPV4_MAPPED, SqlParser.IS_IPV6, SqlParser.IS_USED_LOCK, SqlParser.LAST_INSERT_ID, SqlParser.LCASE, SqlParser.LEAST, SqlParser.LENGTH, SqlParser.LINEFROMTEXT, SqlParser.LINEFROMWKB, SqlParser.LINESTRINGFROMTEXT, SqlParser.LINESTRINGFROMWKB, SqlParser.LN, SqlParser.LOAD_FILE, SqlParser.LOCATE, SqlParser.LOG, SqlParser.LOG10, SqlParser.LOG2, SqlParser.LOWER, SqlParser.LPAD, SqlParser.LTRIM, SqlParser.MAKEDATE, SqlParser.MAKETIME, SqlParser.MAKE_SET, SqlParser.MASTER_POS_WAIT, SqlParser.MBRCONTAINS, SqlParser.MBRDISJOINT, SqlParser.MBREQUAL, SqlParser.MBRINTERSECTS, SqlParser.MBROVERLAPS, SqlParser.MBRTOUCHES, SqlParser.MBRWITHIN, SqlParser.MD5, SqlParser.MLINEFROMTEXT, SqlParser.MLINEFROMWKB, SqlParser.MONTHNAME, SqlParser.MPOINTFROMTEXT, SqlParser.MPOINTFROMWKB, SqlParser.MPOLYFROMTEXT, SqlParser.MPOLYFROMWKB, SqlParser.MULTILINESTRINGFROMTEXT, SqlParser.MULTILINESTRINGFROMWKB, SqlParser.MULTIPOINTFROMTEXT, SqlParser.MULTIPOINTFROMWKB, SqlParser.MULTIPOLYGONFROMTEXT, SqlParser.MULTIPOLYGONFROMWKB, SqlParser.NAME_CONST, SqlParser.NULLIF, SqlParser.NUMGEOMETRIES, SqlParser.NUMINTERIORRINGS, SqlParser.NUMPOINTS, SqlParser.OCT, SqlParser.OCTET_LENGTH, SqlParser.ORD, SqlParser.OVERLAPS, SqlParser.PERIOD_ADD, SqlParser.PERIOD_DIFF, SqlParser.PI, SqlParser.POINTFROMTEXT, SqlParser.POINTFROMWKB, SqlParser.POINTN, SqlParser.POLYFROMTEXT, SqlParser.POLYFROMWKB, SqlParser.POLYGONFROMTEXT, SqlParser.POLYGONFROMWKB, SqlParser.POW, SqlParser.POWER, SqlParser.QUOTE, SqlParser.RADIANS, SqlParser.RAND, SqlParser.RANDOM_BYTES, SqlParser.RELEASE_LOCK, SqlParser.REVERSE, SqlParser.ROUND, SqlParser.ROW_COUNT, SqlParser.RPAD, SqlParser.RTRIM, SqlParser.SEC_TO_TIME, SqlParser.SESSION_USER, SqlParser.SHA, SqlParser.SHA1, SqlParser.SHA2, SqlParser.SIGN, SqlParser.SIN, SqlParser.SLEEP, SqlParser.SOUNDEX, SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, SqlParser.SQRT, SqlParser.SRID, SqlParser.STARTPOINT, SqlParser.STRCMP, SqlParser.STR_TO_DATE, SqlParser.ST_AREA, SqlParser.ST_ASBINARY, SqlParser.ST_ASTEXT, SqlParser.ST_ASWKB, SqlParser.ST_ASWKT, SqlParser.ST_BUFFER, SqlParser.ST_CENTROID, SqlParser.ST_CONTAINS, SqlParser.ST_CROSSES, SqlParser.ST_DIFFERENCE, SqlParser.ST_DIMENSION, SqlParser.ST_DISJOINT, SqlParser.ST_DISTANCE, SqlParser.ST_ENDPOINT, SqlParser.ST_ENVELOPE, SqlParser.ST_EQUALS, SqlParser.ST_EXTERIORRING, SqlParser.ST_GEOMCOLLFROMTEXT, SqlParser.ST_GEOMCOLLFROMTXT, SqlParser.ST_GEOMCOLLFROMWKB, SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, SqlParser.ST_GEOMETRYFROMTEXT, SqlParser.ST_GEOMETRYFROMWKB, SqlParser.ST_GEOMETRYN, SqlParser.ST_GEOMETRYTYPE, SqlParser.ST_GEOMFROMTEXT, SqlParser.ST_GEOMFROMWKB, SqlParser.ST_INTERIORRINGN, SqlParser.ST_INTERSECTION, SqlParser.ST_INTERSECTS, SqlParser.ST_ISCLOSED, SqlParser.ST_ISEMPTY, SqlParser.ST_ISSIMPLE, SqlParser.ST_LINEFROMTEXT, SqlParser.ST_LINEFROMWKB, SqlParser.ST_LINESTRINGFROMTEXT, SqlParser.ST_LINESTRINGFROMWKB, SqlParser.ST_NUMGEOMETRIES, SqlParser.ST_NUMINTERIORRING, SqlParser.ST_NUMINTERIORRINGS, SqlParser.ST_NUMPOINTS, SqlParser.ST_OVERLAPS, SqlParser.ST_POINTFROMTEXT, SqlParser.ST_POINTFROMWKB, SqlParser.ST_POINTN, SqlParser.ST_POLYFROMTEXT, SqlParser.ST_POLYFROMWKB, SqlParser.ST_POLYGONFROMTEXT, SqlParser.ST_POLYGONFROMWKB, SqlParser.ST_SRID, SqlParser.ST_STARTPOINT, SqlParser.ST_SYMDIFFERENCE, SqlParser.ST_TOUCHES, SqlParser.ST_UNION, SqlParser.ST_WITHIN, SqlParser.ST_X, SqlParser.ST_Y, SqlParser.SUBDATE, SqlParser.SUBSTRING_INDEX, SqlParser.SUBTIME, SqlParser.SYSTEM_USER, SqlParser.TAN, SqlParser.TIMEDIFF, SqlParser.TIMESTAMPADD, SqlParser.TIMESTAMPDIFF, SqlParser.TIME_FORMAT, SqlParser.TIME_TO_SEC, SqlParser.TOUCHES, SqlParser.TO_BASE64, SqlParser.TO_DAYS, SqlParser.TO_SECONDS, SqlParser.UCASE, SqlParser.UNCOMPRESS, SqlParser.UNCOMPRESSED_LENGTH, SqlParser.UNHEX, SqlParser.UNIX_TIMESTAMP, SqlParser.UPDATEXML, SqlParser.UPPER, SqlParser.UUID, SqlParser.UUID_SHORT, SqlParser.VALIDATE_PASSWORD_STRENGTH, SqlParser.VERSION, SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, SqlParser.WEEKDAY, SqlParser.WEEKOFYEAR, SqlParser.WEIGHT_STRING, SqlParser.WITHIN, SqlParser.YEARWEEK, SqlParser.Y_FUNCTION, SqlParser.X_FUNCTION, SqlParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 415
                self.simpleId()
                pass
            elif token in [SqlParser.REVERSE_QUOTE_ID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 416
                self.match(SqlParser.REVERSE_QUOTE_ID)
                pass
            elif token in [SqlParser.CHARSET_REVERSE_QOUTE_STRING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 417
                self.match(SqlParser.CHARSET_REVERSE_QOUTE_STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SimpleIdContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(SqlParser.ID, 0)

        def intervalTypeBase(self):
            return self.getTypedRuleContext(SqlParser.IntervalTypeBaseContext,0)


        def dataTypeBase(self):
            return self.getTypedRuleContext(SqlParser.DataTypeBaseContext,0)


        def keywordsCanBeId(self):
            return self.getTypedRuleContext(SqlParser.KeywordsCanBeIdContext,0)


        def functionNameBase(self):
            return self.getTypedRuleContext(SqlParser.FunctionNameBaseContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_simpleId

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleId" ):
                listener.enterSimpleId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleId" ):
                listener.exitSimpleId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleId" ):
                return visitor.visitSimpleId(self)
            else:
                return visitor.visitChildren(self)




    def simpleId(self):

        localctx = SqlParser.SimpleIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_simpleId)
        try:
            self.state = 425
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 420
                self.match(SqlParser.ID)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 421
                self.intervalTypeBase()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 422
                self.dataTypeBase()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 423
                self.keywordsCanBeId()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 424
                self.functionNameBase()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DottedIdContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT_ID(self):
            return self.getToken(SqlParser.DOT_ID, 0)

        def uid(self):
            return self.getTypedRuleContext(SqlParser.UidContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_dottedId

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDottedId" ):
                listener.enterDottedId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDottedId" ):
                listener.exitDottedId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDottedId" ):
                return visitor.visitDottedId(self)
            else:
                return visitor.visitChildren(self)




    def dottedId(self):

        localctx = SqlParser.DottedIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_dottedId)
        try:
            self.state = 430
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.DOT_ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 427
                self.match(SqlParser.DOT_ID)
                pass
            elif token in [SqlParser.DOT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 428
                self.match(SqlParser.DOT)
                self.state = 429
                self.uid()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DecimalLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECIMAL_LITERAL(self):
            return self.getToken(SqlParser.DECIMAL_LITERAL, 0)

        def ZERO_DECIMAL(self):
            return self.getToken(SqlParser.ZERO_DECIMAL, 0)

        def ONE_DECIMAL(self):
            return self.getToken(SqlParser.ONE_DECIMAL, 0)

        def TWO_DECIMAL(self):
            return self.getToken(SqlParser.TWO_DECIMAL, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_decimalLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecimalLiteral" ):
                listener.enterDecimalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecimalLiteral" ):
                listener.exitDecimalLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecimalLiteral" ):
                return visitor.visitDecimalLiteral(self)
            else:
                return visitor.visitChildren(self)




    def decimalLiteral(self):

        localctx = SqlParser.DecimalLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_decimalLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 432
            _la = self._input.LA(1)
            if not(((((_la - 955)) & ~0x3f) == 0 and ((1 << (_la - 955)) & ((1 << (SqlParser.ZERO_DECIMAL - 955)) | (1 << (SqlParser.ONE_DECIMAL - 955)) | (1 << (SqlParser.TWO_DECIMAL - 955)) | (1 << (SqlParser.DECIMAL_LITERAL - 955)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StringLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(SqlParser.STRING_LITERAL)
            else:
                return self.getToken(SqlParser.STRING_LITERAL, i)

        def getRuleIndex(self):
            return SqlParser.RULE_stringLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)




    def stringLiteral(self):

        localctx = SqlParser.StringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_stringLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 435 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 434
                    self.match(SqlParser.STRING_LITERAL)

                else:
                    raise NoViableAltException(self)
                self.state = 437 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,54,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BooleanLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(SqlParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(SqlParser.FALSE, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_booleanLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanLiteral" ):
                return visitor.visitBooleanLiteral(self)
            else:
                return visitor.visitChildren(self)




    def booleanLiteral(self):

        localctx = SqlParser.BooleanLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_booleanLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            _la = self._input.LA(1)
            if not(_la==SqlParser.FALSE or _la==SqlParser.TRUE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HexadecimalLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HEXADECIMAL_LITERAL(self):
            return self.getToken(SqlParser.HEXADECIMAL_LITERAL, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_hexadecimalLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHexadecimalLiteral" ):
                listener.enterHexadecimalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHexadecimalLiteral" ):
                listener.exitHexadecimalLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHexadecimalLiteral" ):
                return visitor.visitHexadecimalLiteral(self)
            else:
                return visitor.visitChildren(self)




    def hexadecimalLiteral(self):

        localctx = SqlParser.HexadecimalLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_hexadecimalLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self.match(SqlParser.HEXADECIMAL_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NullNotnullContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULL_LITERAL(self):
            return self.getToken(SqlParser.NULL_LITERAL, 0)

        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_nullNotnull

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullNotnull" ):
                listener.enterNullNotnull(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullNotnull" ):
                listener.exitNullNotnull(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullNotnull" ):
                return visitor.visitNullNotnull(self)
            else:
                return visitor.visitChildren(self)




    def nullNotnull(self):

        localctx = SqlParser.NullNotnullContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_nullNotnull)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.NOT:
                self.state = 443
                self.match(SqlParser.NOT)


            self.state = 446
            self.match(SqlParser.NULL_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.nullLiteral = None # Token

        def stringLiteral(self):
            return self.getTypedRuleContext(SqlParser.StringLiteralContext,0)


        def decimalLiteral(self):
            return self.getTypedRuleContext(SqlParser.DecimalLiteralContext,0)


        def hexadecimalLiteral(self):
            return self.getTypedRuleContext(SqlParser.HexadecimalLiteralContext,0)


        def booleanLiteral(self):
            return self.getTypedRuleContext(SqlParser.BooleanLiteralContext,0)


        def NULL_LITERAL(self):
            return self.getToken(SqlParser.NULL_LITERAL, 0)

        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_constant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant" ):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)




    def constant(self):

        localctx = SqlParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_constant)
        self._la = 0 # Token type
        try:
            self.state = 458
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 448
                self.stringLiteral()
                pass
            elif token in [SqlParser.ZERO_DECIMAL, SqlParser.ONE_DECIMAL, SqlParser.TWO_DECIMAL, SqlParser.DECIMAL_LITERAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 449
                self.decimalLiteral()
                pass
            elif token in [SqlParser.MINUS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 450
                self.match(SqlParser.MINUS)
                self.state = 451
                self.decimalLiteral()
                pass
            elif token in [SqlParser.HEXADECIMAL_LITERAL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 452
                self.hexadecimalLiteral()
                pass
            elif token in [SqlParser.FALSE, SqlParser.TRUE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 453
                self.booleanLiteral()
                pass
            elif token in [SqlParser.NOT, SqlParser.NULL_LITERAL]:
                self.enterOuterAlt(localctx, 6)
                self.state = 455
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.NOT:
                    self.state = 454
                    self.match(SqlParser.NOT)


                self.state = 457
                localctx.nullLiteral = self.match(SqlParser.NULL_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DataTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_dataType

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SpatialDataTypeContext(DataTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.DataTypeContext
            super().__init__(parser)
            self.typeName = None # Token
            self.copyFrom(ctx)

        def GEOMETRYCOLLECTION(self):
            return self.getToken(SqlParser.GEOMETRYCOLLECTION, 0)
        def LINESTRING(self):
            return self.getToken(SqlParser.LINESTRING, 0)
        def MULTILINESTRING(self):
            return self.getToken(SqlParser.MULTILINESTRING, 0)
        def MULTIPOINT(self):
            return self.getToken(SqlParser.MULTIPOINT, 0)
        def MULTIPOLYGON(self):
            return self.getToken(SqlParser.MULTIPOLYGON, 0)
        def POINT(self):
            return self.getToken(SqlParser.POINT, 0)
        def POLYGON(self):
            return self.getToken(SqlParser.POLYGON, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpatialDataType" ):
                listener.enterSpatialDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpatialDataType" ):
                listener.exitSpatialDataType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpatialDataType" ):
                return visitor.visitSpatialDataType(self)
            else:
                return visitor.visitChildren(self)


    class SimpleDataTypeContext(DataTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.DataTypeContext
            super().__init__(parser)
            self.typeName = None # Token
            self.copyFrom(ctx)

        def DATE(self):
            return self.getToken(SqlParser.DATE, 0)
        def TINYBLOB(self):
            return self.getToken(SqlParser.TINYBLOB, 0)
        def BLOB(self):
            return self.getToken(SqlParser.BLOB, 0)
        def MEDIUMBLOB(self):
            return self.getToken(SqlParser.MEDIUMBLOB, 0)
        def LONGBLOB(self):
            return self.getToken(SqlParser.LONGBLOB, 0)
        def BOOL(self):
            return self.getToken(SqlParser.BOOL, 0)
        def BOOLEAN(self):
            return self.getToken(SqlParser.BOOLEAN, 0)
        def SERIAL(self):
            return self.getToken(SqlParser.SERIAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleDataType" ):
                listener.enterSimpleDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleDataType" ):
                listener.exitSimpleDataType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleDataType" ):
                return visitor.visitSimpleDataType(self)
            else:
                return visitor.visitChildren(self)



    def dataType(self):

        localctx = SqlParser.DataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_dataType)
        self._la = 0 # Token type
        try:
            self.state = 462
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.DATE, SqlParser.TINYBLOB, SqlParser.BLOB, SqlParser.MEDIUMBLOB, SqlParser.LONGBLOB, SqlParser.SERIAL, SqlParser.BOOL, SqlParser.BOOLEAN]:
                localctx = SqlParser.SimpleDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 460
                localctx.typeName = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & ((1 << (SqlParser.DATE - 182)) | (1 << (SqlParser.TINYBLOB - 182)) | (1 << (SqlParser.BLOB - 182)) | (1 << (SqlParser.MEDIUMBLOB - 182)) | (1 << (SqlParser.LONGBLOB - 182)) | (1 << (SqlParser.SERIAL - 182)))) != 0) or _la==SqlParser.BOOL or _la==SqlParser.BOOLEAN):
                    localctx.typeName = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [SqlParser.GEOMETRYCOLLECTION, SqlParser.LINESTRING, SqlParser.MULTILINESTRING, SqlParser.MULTIPOINT, SqlParser.MULTIPOLYGON, SqlParser.POINT, SqlParser.POLYGON]:
                localctx = SqlParser.SpatialDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 461
                localctx.typeName = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 627)) & ~0x3f) == 0 and ((1 << (_la - 627)) & ((1 << (SqlParser.GEOMETRYCOLLECTION - 627)) | (1 << (SqlParser.LINESTRING - 627)) | (1 << (SqlParser.MULTILINESTRING - 627)) | (1 << (SqlParser.MULTIPOINT - 627)) | (1 << (SqlParser.MULTIPOLYGON - 627)) | (1 << (SqlParser.POINT - 627)) | (1 << (SqlParser.POLYGON - 627)))) != 0)):
                    localctx.typeName = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConvertedDataTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.typeName = None # Token

        def DATE(self):
            return self.getToken(SqlParser.DATE, 0)

        def DATETIME(self):
            return self.getToken(SqlParser.DATETIME, 0)

        def TIME(self):
            return self.getToken(SqlParser.TIME, 0)

        def SIGNED(self):
            return self.getToken(SqlParser.SIGNED, 0)

        def UNSIGNED(self):
            return self.getToken(SqlParser.UNSIGNED, 0)

        def INTEGER(self):
            return self.getToken(SqlParser.INTEGER, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_convertedDataType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConvertedDataType" ):
                listener.enterConvertedDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConvertedDataType" ):
                listener.exitConvertedDataType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConvertedDataType" ):
                return visitor.visitConvertedDataType(self)
            else:
                return visitor.visitChildren(self)




    def convertedDataType(self):

        localctx = SqlParser.ConvertedDataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_convertedDataType)
        self._la = 0 # Token type
        try:
            self.state = 470
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.RR_BRACKET]:
                self.enterOuterAlt(localctx, 1)

                pass
            elif token in [SqlParser.DATE, SqlParser.TIME, SqlParser.DATETIME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 465
                localctx.typeName = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & ((1 << (SqlParser.DATE - 182)) | (1 << (SqlParser.TIME - 182)) | (1 << (SqlParser.DATETIME - 182)))) != 0)):
                    localctx.typeName = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [SqlParser.UNSIGNED, SqlParser.SIGNED]:
                self.enterOuterAlt(localctx, 3)
                self.state = 466
                _la = self._input.LA(1)
                if not(_la==SqlParser.UNSIGNED or _la==SqlParser.SIGNED):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 468
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.INTEGER:
                    self.state = 467
                    self.match(SqlParser.INTEGER)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UidListContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def uid(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.UidContext)
            else:
                return self.getTypedRuleContext(SqlParser.UidContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_uidList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUidList" ):
                listener.enterUidList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUidList" ):
                listener.exitUidList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUidList" ):
                return visitor.visitUidList(self)
            else:
                return visitor.visitChildren(self)




    def uidList(self):

        localctx = SqlParser.UidListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_uidList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            self.uid()
            self.state = 477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 473
                self.match(SqlParser.COMMA)
                self.state = 474
                self.uid()
                self.state = 479
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TablesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.TableNameContext)
            else:
                return self.getTypedRuleContext(SqlParser.TableNameContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_tables

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTables" ):
                listener.enterTables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTables" ):
                listener.exitTables(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTables" ):
                return visitor.visitTables(self)
            else:
                return visitor.visitChildren(self)




    def tables(self):

        localctx = SqlParser.TablesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_tables)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.tableName()
            self.state = 485
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 481
                self.match(SqlParser.COMMA)
                self.state = 482
                self.tableName()
                self.state = 487
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_expressions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressions" ):
                listener.enterExpressions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressions" ):
                listener.exitExpressions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressions" ):
                return visitor.visitExpressions(self)
            else:
                return visitor.visitChildren(self)




    def expressions(self):

        localctx = SqlParser.ExpressionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_expressions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
            self.expression(0)
            self.state = 493
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 489
                self.match(SqlParser.COMMA)
                self.state = 490
                self.expression(0)
                self.state = 495
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionsWithDefaultsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expressionOrDefault(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionOrDefaultContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionOrDefaultContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_expressionsWithDefaults

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionsWithDefaults" ):
                listener.enterExpressionsWithDefaults(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionsWithDefaults" ):
                listener.exitExpressionsWithDefaults(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionsWithDefaults" ):
                return visitor.visitExpressionsWithDefaults(self)
            else:
                return visitor.visitChildren(self)




    def expressionsWithDefaults(self):

        localctx = SqlParser.ExpressionsWithDefaultsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_expressionsWithDefaults)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.expressionOrDefault()
            self.state = 501
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 497
                self.match(SqlParser.COMMA)
                self.state = 498
                self.expressionOrDefault()
                self.state = 503
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(SqlParser.ConstantContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_constants

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstants" ):
                listener.enterConstants(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstants" ):
                listener.exitConstants(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstants" ):
                return visitor.visitConstants(self)
            else:
                return visitor.visitChildren(self)




    def constants(self):

        localctx = SqlParser.ConstantsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_constants)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            self.constant()
            self.state = 509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 505
                self.match(SqlParser.COMMA)
                self.state = 506
                self.constant()
                self.state = 511
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SimpleStringsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(SqlParser.STRING_LITERAL)
            else:
                return self.getToken(SqlParser.STRING_LITERAL, i)

        def getRuleIndex(self):
            return SqlParser.RULE_simpleStrings

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleStrings" ):
                listener.enterSimpleStrings(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleStrings" ):
                listener.exitSimpleStrings(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleStrings" ):
                return visitor.visitSimpleStrings(self)
            else:
                return visitor.visitChildren(self)




    def simpleStrings(self):

        localctx = SqlParser.SimpleStringsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_simpleStrings)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.match(SqlParser.STRING_LITERAL)
            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 513
                self.match(SqlParser.COMMA)
                self.state = 514
                self.match(SqlParser.STRING_LITERAL)
                self.state = 519
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UserVariablesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCAL_ID(self, i:int=None):
            if i is None:
                return self.getTokens(SqlParser.LOCAL_ID)
            else:
                return self.getToken(SqlParser.LOCAL_ID, i)

        def getRuleIndex(self):
            return SqlParser.RULE_userVariables

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUserVariables" ):
                listener.enterUserVariables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUserVariables" ):
                listener.exitUserVariables(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUserVariables" ):
                return visitor.visitUserVariables(self)
            else:
                return visitor.visitChildren(self)




    def userVariables(self):

        localctx = SqlParser.UserVariablesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_userVariables)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 520
            self.match(SqlParser.LOCAL_ID)
            self.state = 525
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 521
                self.match(SqlParser.COMMA)
                self.state = 522
                self.match(SqlParser.LOCAL_ID)
                self.state = 527
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefaultValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULL_LITERAL(self):
            return self.getToken(SqlParser.NULL_LITERAL, 0)

        def constant(self):
            return self.getTypedRuleContext(SqlParser.ConstantContext,0)


        def currentTimestamp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.CurrentTimestampContext)
            else:
                return self.getTypedRuleContext(SqlParser.CurrentTimestampContext,i)


        def ON(self):
            return self.getToken(SqlParser.ON, 0)

        def UPDATE(self):
            return self.getToken(SqlParser.UPDATE, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_defaultValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultValue" ):
                listener.enterDefaultValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultValue" ):
                listener.exitDefaultValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultValue" ):
                return visitor.visitDefaultValue(self)
            else:
                return visitor.visitChildren(self)




    def defaultValue(self):

        localctx = SqlParser.DefaultValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_defaultValue)
        self._la = 0 # Token type
        try:
            self.state = 536
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 528
                self.match(SqlParser.NULL_LITERAL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 529
                self.constant()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 530
                self.currentTimestamp()
                self.state = 534
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.ON:
                    self.state = 531
                    self.match(SqlParser.ON)
                    self.state = 532
                    self.match(SqlParser.UPDATE)
                    self.state = 533
                    self.currentTimestamp()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CurrentTimestampContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOW(self):
            return self.getToken(SqlParser.NOW, 0)

        def CURRENT_TIMESTAMP(self):
            return self.getToken(SqlParser.CURRENT_TIMESTAMP, 0)

        def LOCALTIME(self):
            return self.getToken(SqlParser.LOCALTIME, 0)

        def LOCALTIMESTAMP(self):
            return self.getToken(SqlParser.LOCALTIMESTAMP, 0)

        def decimalLiteral(self):
            return self.getTypedRuleContext(SqlParser.DecimalLiteralContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_currentTimestamp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCurrentTimestamp" ):
                listener.enterCurrentTimestamp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCurrentTimestamp" ):
                listener.exitCurrentTimestamp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCurrentTimestamp" ):
                return visitor.visitCurrentTimestamp(self)
            else:
                return visitor.visitChildren(self)




    def currentTimestamp(self):

        localctx = SqlParser.CurrentTimestampContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_currentTimestamp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 552
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.CURRENT_TIMESTAMP, SqlParser.LOCALTIME, SqlParser.LOCALTIMESTAMP]:
                self.state = 538
                _la = self._input.LA(1)
                if not(((((_la - 230)) & ~0x3f) == 0 and ((1 << (_la - 230)) & ((1 << (SqlParser.CURRENT_TIMESTAMP - 230)) | (1 << (SqlParser.LOCALTIME - 230)) | (1 << (SqlParser.LOCALTIMESTAMP - 230)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 544
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.LR_BRACKET:
                    self.state = 539
                    self.match(SqlParser.LR_BRACKET)
                    self.state = 541
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if ((((_la - 955)) & ~0x3f) == 0 and ((1 << (_la - 955)) & ((1 << (SqlParser.ZERO_DECIMAL - 955)) | (1 << (SqlParser.ONE_DECIMAL - 955)) | (1 << (SqlParser.TWO_DECIMAL - 955)) | (1 << (SqlParser.DECIMAL_LITERAL - 955)))) != 0):
                        self.state = 540
                        self.decimalLiteral()


                    self.state = 543
                    self.match(SqlParser.RR_BRACKET)


                pass
            elif token in [SqlParser.NOW]:
                self.state = 546
                self.match(SqlParser.NOW)
                self.state = 547
                self.match(SqlParser.LR_BRACKET)
                self.state = 549
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 955)) & ~0x3f) == 0 and ((1 << (_la - 955)) & ((1 << (SqlParser.ZERO_DECIMAL - 955)) | (1 << (SqlParser.ONE_DECIMAL - 955)) | (1 << (SqlParser.TWO_DECIMAL - 955)) | (1 << (SqlParser.DECIMAL_LITERAL - 955)))) != 0):
                    self.state = 548
                    self.decimalLiteral()


                self.state = 551
                self.match(SqlParser.RR_BRACKET)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionOrDefaultContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)


        def DEFAULT(self):
            return self.getToken(SqlParser.DEFAULT, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_expressionOrDefault

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionOrDefault" ):
                listener.enterExpressionOrDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionOrDefault" ):
                listener.exitExpressionOrDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionOrDefault" ):
                return visitor.visitExpressionOrDefault(self)
            else:
                return visitor.visitChildren(self)




    def expressionOrDefault(self):

        localctx = SqlParser.ExpressionOrDefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_expressionOrDefault)
        try:
            self.state = 556
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.CASE, SqlParser.CAST, SqlParser.CONVERT, SqlParser.CURRENT_USER, SqlParser.DATABASE, SqlParser.EXISTS, SqlParser.FALSE, SqlParser.IF, SqlParser.INSERT, SqlParser.INTERVAL, SqlParser.LEFT, SqlParser.NOT, SqlParser.NULL_LITERAL, SqlParser.REPLACE, SqlParser.RIGHT, SqlParser.TRUE, SqlParser.VALUES, SqlParser.DATE, SqlParser.TIME, SqlParser.TIMESTAMP, SqlParser.DATETIME, SqlParser.YEAR, SqlParser.CHAR, SqlParser.BINARY, SqlParser.TEXT, SqlParser.ENUM, SqlParser.SERIAL, SqlParser.AVG, SqlParser.BIT_AND, SqlParser.BIT_OR, SqlParser.BIT_XOR, SqlParser.COUNT, SqlParser.GROUP_CONCAT, SqlParser.MAX, SqlParser.MIN, SqlParser.STD, SqlParser.STDDEV, SqlParser.STDDEV_POP, SqlParser.STDDEV_SAMP, SqlParser.SUM, SqlParser.VAR_POP, SqlParser.VAR_SAMP, SqlParser.VARIANCE, SqlParser.CURRENT_DATE, SqlParser.CURRENT_TIME, SqlParser.CURRENT_TIMESTAMP, SqlParser.LOCALTIME, SqlParser.CURDATE, SqlParser.CURTIME, SqlParser.DATE_ADD, SqlParser.DATE_SUB, SqlParser.EXTRACT, SqlParser.LOCALTIMESTAMP, SqlParser.NOW, SqlParser.POSITION, SqlParser.SUBSTR, SqlParser.SUBSTRING, SqlParser.SYSDATE, SqlParser.TRIM, SqlParser.UTC_DATE, SqlParser.UTC_TIME, SqlParser.UTC_TIMESTAMP, SqlParser.ACCOUNT, SqlParser.ACTION, SqlParser.AFTER, SqlParser.AGGREGATE, SqlParser.ALGORITHM, SqlParser.ANY, SqlParser.AT, SqlParser.AUTHORS, SqlParser.AUTOCOMMIT, SqlParser.AUTOEXTEND_SIZE, SqlParser.AUTO_INCREMENT, SqlParser.AVG_ROW_LENGTH, SqlParser.BEGIN, SqlParser.BINLOG, SqlParser.BIT, SqlParser.BLOCK, SqlParser.BOOL, SqlParser.BOOLEAN, SqlParser.BTREE, SqlParser.CACHE, SqlParser.CASCADED, SqlParser.CHAIN, SqlParser.CHANGED, SqlParser.CHANNEL, SqlParser.CHECKSUM, SqlParser.CIPHER, SqlParser.CLIENT, SqlParser.CLOSE, SqlParser.COALESCE, SqlParser.CODE, SqlParser.COLUMNS, SqlParser.COLUMN_FORMAT, SqlParser.COMMENT, SqlParser.COMMIT, SqlParser.COMPACT, SqlParser.COMPLETION, SqlParser.COMPRESSED, SqlParser.COMPRESSION, SqlParser.CONCURRENT, SqlParser.CONNECTION, SqlParser.CONSISTENT, SqlParser.CONTAINS, SqlParser.CONTEXT, SqlParser.CONTRIBUTORS, SqlParser.COPY, SqlParser.CPU, SqlParser.DATA, SqlParser.DATAFILE, SqlParser.DEALLOCATE, SqlParser.DEFAULT_AUTH, SqlParser.DEFINER, SqlParser.DELAY_KEY_WRITE, SqlParser.DES_KEY_FILE, SqlParser.DIRECTORY, SqlParser.DISABLE, SqlParser.DISCARD, SqlParser.DISK, SqlParser.DO, SqlParser.DUMPFILE, SqlParser.DUPLICATE, SqlParser.DYNAMIC, SqlParser.ENABLE, SqlParser.ENCRYPTION, SqlParser.END, SqlParser.ENDS, SqlParser.ENGINE, SqlParser.ENGINES, SqlParser.ERROR, SqlParser.ERRORS, SqlParser.ESCAPE, SqlParser.EVEN, SqlParser.EVENT, SqlParser.EVENTS, SqlParser.EVERY, SqlParser.EXCHANGE, SqlParser.EXCLUSIVE, SqlParser.EXPIRE, SqlParser.EXPORT, SqlParser.EXTENDED, SqlParser.EXTENT_SIZE, SqlParser.FAST, SqlParser.FAULTS, SqlParser.FIELDS, SqlParser.FILE_BLOCK_SIZE, SqlParser.FILTER, SqlParser.FIRST, SqlParser.FIXED, SqlParser.FLUSH, SqlParser.FOLLOWS, SqlParser.FOUND, SqlParser.FULL, SqlParser.FUNCTION, SqlParser.GENERAL, SqlParser.GLOBAL, SqlParser.GRANTS, SqlParser.GROUP_REPLICATION, SqlParser.HANDLER, SqlParser.HASH, SqlParser.HELP, SqlParser.HOST, SqlParser.HOSTS, SqlParser.IDENTIFIED, SqlParser.IGNORE_SERVER_IDS, SqlParser.IMPORT, SqlParser.INDEXES, SqlParser.INITIAL_SIZE, SqlParser.INPLACE, SqlParser.INSERT_METHOD, SqlParser.INSTALL, SqlParser.INSTANCE, SqlParser.INVOKER, SqlParser.IO, SqlParser.IO_THREAD, SqlParser.IPC, SqlParser.ISOLATION, SqlParser.ISSUER, SqlParser.JSON, SqlParser.KEY_BLOCK_SIZE, SqlParser.LANGUAGE, SqlParser.LAST, SqlParser.LEAVES, SqlParser.LESS, SqlParser.LEVEL, SqlParser.LIST, SqlParser.LOCAL, SqlParser.LOGFILE, SqlParser.LOGS, SqlParser.MASTER, SqlParser.MASTER_AUTO_POSITION, SqlParser.MASTER_CONNECT_RETRY, SqlParser.MASTER_DELAY, SqlParser.MASTER_HEARTBEAT_PERIOD, SqlParser.MASTER_HOST, SqlParser.MASTER_LOG_FILE, SqlParser.MASTER_LOG_POS, SqlParser.MASTER_PASSWORD, SqlParser.MASTER_PORT, SqlParser.MASTER_RETRY_COUNT, SqlParser.MASTER_SSL, SqlParser.MASTER_SSL_CA, SqlParser.MASTER_SSL_CAPATH, SqlParser.MASTER_SSL_CERT, SqlParser.MASTER_SSL_CIPHER, SqlParser.MASTER_SSL_CRL, SqlParser.MASTER_SSL_CRLPATH, SqlParser.MASTER_SSL_KEY, SqlParser.MASTER_TLS_VERSION, SqlParser.MASTER_USER, SqlParser.MAX_CONNECTIONS_PER_HOUR, SqlParser.MAX_QUERIES_PER_HOUR, SqlParser.MAX_ROWS, SqlParser.MAX_SIZE, SqlParser.MAX_UPDATES_PER_HOUR, SqlParser.MAX_USER_CONNECTIONS, SqlParser.MEDIUM, SqlParser.MERGE, SqlParser.MID, SqlParser.MIGRATE, SqlParser.MIN_ROWS, SqlParser.MODE, SqlParser.MODIFY, SqlParser.MUTEX, SqlParser.MYSQL, SqlParser.NAME, SqlParser.NAMES, SqlParser.NCHAR, SqlParser.NEVER, SqlParser.NEXT, SqlParser.NO, SqlParser.NODEGROUP, SqlParser.NONE, SqlParser.OFFLINE, SqlParser.OFFSET, SqlParser.OJ, SqlParser.OLD_PASSWORD, SqlParser.ONE, SqlParser.ONLINE, SqlParser.ONLY, SqlParser.OPEN, SqlParser.OPTIMIZER_COSTS, SqlParser.OPTIONS, SqlParser.OWNER, SqlParser.PACK_KEYS, SqlParser.PAGE, SqlParser.PARSER, SqlParser.PARTIAL, SqlParser.PARTITIONING, SqlParser.PARTITIONS, SqlParser.PASSWORD, SqlParser.PHASE, SqlParser.PLUGIN, SqlParser.PLUGIN_DIR, SqlParser.PLUGINS, SqlParser.PORT, SqlParser.PRECEDES, SqlParser.PREPARE, SqlParser.PRESERVE, SqlParser.PREV, SqlParser.PROCESSLIST, SqlParser.PROFILE, SqlParser.PROFILES, SqlParser.PROXY, SqlParser.QUERY, SqlParser.QUICK, SqlParser.REBUILD, SqlParser.RECOVER, SqlParser.REDO_BUFFER_SIZE, SqlParser.REDUNDANT, SqlParser.RELAY, SqlParser.RELAY_LOG_FILE, SqlParser.RELAY_LOG_POS, SqlParser.RELAYLOG, SqlParser.REMOVE, SqlParser.REORGANIZE, SqlParser.REPAIR, SqlParser.REPLICATE_DO_DB, SqlParser.REPLICATE_DO_TABLE, SqlParser.REPLICATE_IGNORE_DB, SqlParser.REPLICATE_IGNORE_TABLE, SqlParser.REPLICATE_REWRITE_DB, SqlParser.REPLICATE_WILD_DO_TABLE, SqlParser.REPLICATE_WILD_IGNORE_TABLE, SqlParser.REPLICATION, SqlParser.RESET, SqlParser.RESUME, SqlParser.RETURNS, SqlParser.ROLLBACK, SqlParser.ROLLUP, SqlParser.ROTATE, SqlParser.ROW, SqlParser.ROWS, SqlParser.ROW_FORMAT, SqlParser.SAVEPOINT, SqlParser.SCHEDULE, SqlParser.SECURITY, SqlParser.SERVER, SqlParser.SESSION, SqlParser.SHARE, SqlParser.SHARED, SqlParser.SIGNED, SqlParser.SIMPLE, SqlParser.SLAVE, SqlParser.SLOW, SqlParser.SNAPSHOT, SqlParser.SOCKET, SqlParser.SOME, SqlParser.SONAME, SqlParser.SOUNDS, SqlParser.SOURCE, SqlParser.SQL_AFTER_GTIDS, SqlParser.SQL_AFTER_MTS_GAPS, SqlParser.SQL_BEFORE_GTIDS, SqlParser.SQL_BUFFER_RESULT, SqlParser.SQL_CACHE, SqlParser.SQL_NO_CACHE, SqlParser.SQL_THREAD, SqlParser.START, SqlParser.STARTS, SqlParser.STATS_AUTO_RECALC, SqlParser.STATS_PERSISTENT, SqlParser.STATS_SAMPLE_PAGES, SqlParser.STATUS, SqlParser.STOP, SqlParser.STORAGE, SqlParser.STRING, SqlParser.SUBJECT, SqlParser.SUBPARTITION, SqlParser.SUBPARTITIONS, SqlParser.SUSPEND, SqlParser.SWAPS, SqlParser.SWITCHES, SqlParser.TABLESPACE, SqlParser.TEMPORARY, SqlParser.TEMPTABLE, SqlParser.THAN, SqlParser.TRADITIONAL, SqlParser.TRANSACTION, SqlParser.TRIGGERS, SqlParser.TRUNCATE, SqlParser.UNDEFINED, SqlParser.UNDOFILE, SqlParser.UNDO_BUFFER_SIZE, SqlParser.UNINSTALL, SqlParser.UNKNOWN, SqlParser.UNTIL, SqlParser.UPGRADE, SqlParser.USER, SqlParser.USE_FRM, SqlParser.USER_RESOURCES, SqlParser.VALIDATION, SqlParser.VALUE, SqlParser.VARIABLES, SqlParser.VIEW, SqlParser.WAIT, SqlParser.WARNINGS, SqlParser.WITHOUT, SqlParser.WORK, SqlParser.WRAPPER, SqlParser.X509, SqlParser.XA, SqlParser.XML, SqlParser.QUARTER, SqlParser.MONTH, SqlParser.DAY, SqlParser.HOUR, SqlParser.MINUTE, SqlParser.WEEK, SqlParser.SECOND, SqlParser.MICROSECOND, SqlParser.ASCII, SqlParser.MEMORY, SqlParser.GEOMETRYCOLLECTION, SqlParser.LINESTRING, SqlParser.MULTILINESTRING, SqlParser.MULTIPOINT, SqlParser.MULTIPOLYGON, SqlParser.POINT, SqlParser.POLYGON, SqlParser.ABS, SqlParser.ACOS, SqlParser.ADDDATE, SqlParser.ADDTIME, SqlParser.AES_DECRYPT, SqlParser.AES_ENCRYPT, SqlParser.AREA, SqlParser.ASBINARY, SqlParser.ASIN, SqlParser.ASTEXT, SqlParser.ASWKB, SqlParser.ASWKT, SqlParser.ASYMMETRIC_DECRYPT, SqlParser.ASYMMETRIC_DERIVE, SqlParser.ASYMMETRIC_ENCRYPT, SqlParser.ASYMMETRIC_SIGN, SqlParser.ASYMMETRIC_VERIFY, SqlParser.ATAN, SqlParser.ATAN2, SqlParser.BENCHMARK, SqlParser.BIN, SqlParser.BIT_COUNT, SqlParser.BIT_LENGTH, SqlParser.BUFFER, SqlParser.CEIL, SqlParser.CEILING, SqlParser.CENTROID, SqlParser.CHARACTER_LENGTH, SqlParser.CHARSET, SqlParser.CHAR_LENGTH, SqlParser.COERCIBILITY, SqlParser.COLLATION, SqlParser.COMPRESS, SqlParser.CONCAT, SqlParser.CONCAT_WS, SqlParser.CONNECTION_ID, SqlParser.CONV, SqlParser.CONVERT_TZ, SqlParser.COS, SqlParser.COT, SqlParser.CRC32, SqlParser.CREATE_ASYMMETRIC_PRIV_KEY, SqlParser.CREATE_ASYMMETRIC_PUB_KEY, SqlParser.CREATE_DH_PARAMETERS, SqlParser.CREATE_DIGEST, SqlParser.CROSSES, SqlParser.DATEDIFF, SqlParser.DATE_FORMAT, SqlParser.DAYNAME, SqlParser.DAYOFMONTH, SqlParser.DAYOFWEEK, SqlParser.DAYOFYEAR, SqlParser.DECODE, SqlParser.DEGREES, SqlParser.DES_DECRYPT, SqlParser.DES_ENCRYPT, SqlParser.DIMENSION, SqlParser.DISJOINT, SqlParser.ELT, SqlParser.ENCODE, SqlParser.ENCRYPT, SqlParser.ENDPOINT, SqlParser.ENVELOPE, SqlParser.EQUALS, SqlParser.EXP, SqlParser.EXPORT_SET, SqlParser.EXTERIORRING, SqlParser.EXTRACTVALUE, SqlParser.FIELD, SqlParser.FIND_IN_SET, SqlParser.FLOOR, SqlParser.FORMAT, SqlParser.FOUND_ROWS, SqlParser.FROM_BASE64, SqlParser.FROM_DAYS, SqlParser.FROM_UNIXTIME, SqlParser.GEOMCOLLFROMTEXT, SqlParser.GEOMCOLLFROMWKB, SqlParser.GEOMETRYCOLLECTIONFROMTEXT, SqlParser.GEOMETRYCOLLECTIONFROMWKB, SqlParser.GEOMETRYFROMTEXT, SqlParser.GEOMETRYFROMWKB, SqlParser.GEOMETRYN, SqlParser.GEOMETRYTYPE, SqlParser.GEOMFROMTEXT, SqlParser.GEOMFROMWKB, SqlParser.GET_FORMAT, SqlParser.GET_LOCK, SqlParser.GLENGTH, SqlParser.GREATEST, SqlParser.GTID_SUBSET, SqlParser.GTID_SUBTRACT, SqlParser.HEX, SqlParser.IFNULL, SqlParser.INET6_ATON, SqlParser.INET6_NTOA, SqlParser.INET_ATON, SqlParser.INET_NTOA, SqlParser.INSTR, SqlParser.INTERIORRINGN, SqlParser.INTERSECTS, SqlParser.ISCLOSED, SqlParser.ISEMPTY, SqlParser.ISNULL, SqlParser.ISSIMPLE, SqlParser.IS_FREE_LOCK, SqlParser.IS_IPV4, SqlParser.IS_IPV4_COMPAT, SqlParser.IS_IPV4_MAPPED, SqlParser.IS_IPV6, SqlParser.IS_USED_LOCK, SqlParser.LAST_INSERT_ID, SqlParser.LCASE, SqlParser.LEAST, SqlParser.LENGTH, SqlParser.LINEFROMTEXT, SqlParser.LINEFROMWKB, SqlParser.LINESTRINGFROMTEXT, SqlParser.LINESTRINGFROMWKB, SqlParser.LN, SqlParser.LOAD_FILE, SqlParser.LOCATE, SqlParser.LOG, SqlParser.LOG10, SqlParser.LOG2, SqlParser.LOWER, SqlParser.LPAD, SqlParser.LTRIM, SqlParser.MAKEDATE, SqlParser.MAKETIME, SqlParser.MAKE_SET, SqlParser.MASTER_POS_WAIT, SqlParser.MBRCONTAINS, SqlParser.MBRDISJOINT, SqlParser.MBREQUAL, SqlParser.MBRINTERSECTS, SqlParser.MBROVERLAPS, SqlParser.MBRTOUCHES, SqlParser.MBRWITHIN, SqlParser.MD5, SqlParser.MLINEFROMTEXT, SqlParser.MLINEFROMWKB, SqlParser.MONTHNAME, SqlParser.MPOINTFROMTEXT, SqlParser.MPOINTFROMWKB, SqlParser.MPOLYFROMTEXT, SqlParser.MPOLYFROMWKB, SqlParser.MULTILINESTRINGFROMTEXT, SqlParser.MULTILINESTRINGFROMWKB, SqlParser.MULTIPOINTFROMTEXT, SqlParser.MULTIPOINTFROMWKB, SqlParser.MULTIPOLYGONFROMTEXT, SqlParser.MULTIPOLYGONFROMWKB, SqlParser.NAME_CONST, SqlParser.NULLIF, SqlParser.NUMGEOMETRIES, SqlParser.NUMINTERIORRINGS, SqlParser.NUMPOINTS, SqlParser.OCT, SqlParser.OCTET_LENGTH, SqlParser.ORD, SqlParser.OVERLAPS, SqlParser.PERIOD_ADD, SqlParser.PERIOD_DIFF, SqlParser.PI, SqlParser.POINTFROMTEXT, SqlParser.POINTFROMWKB, SqlParser.POINTN, SqlParser.POLYFROMTEXT, SqlParser.POLYFROMWKB, SqlParser.POLYGONFROMTEXT, SqlParser.POLYGONFROMWKB, SqlParser.POW, SqlParser.POWER, SqlParser.QUOTE, SqlParser.RADIANS, SqlParser.RAND, SqlParser.RANDOM_BYTES, SqlParser.RELEASE_LOCK, SqlParser.REVERSE, SqlParser.ROUND, SqlParser.ROW_COUNT, SqlParser.RPAD, SqlParser.RTRIM, SqlParser.SEC_TO_TIME, SqlParser.SESSION_USER, SqlParser.SHA, SqlParser.SHA1, SqlParser.SHA2, SqlParser.SIGN, SqlParser.SIN, SqlParser.SLEEP, SqlParser.SOUNDEX, SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, SqlParser.SQRT, SqlParser.SRID, SqlParser.STARTPOINT, SqlParser.STRCMP, SqlParser.STR_TO_DATE, SqlParser.ST_AREA, SqlParser.ST_ASBINARY, SqlParser.ST_ASTEXT, SqlParser.ST_ASWKB, SqlParser.ST_ASWKT, SqlParser.ST_BUFFER, SqlParser.ST_CENTROID, SqlParser.ST_CONTAINS, SqlParser.ST_CROSSES, SqlParser.ST_DIFFERENCE, SqlParser.ST_DIMENSION, SqlParser.ST_DISJOINT, SqlParser.ST_DISTANCE, SqlParser.ST_ENDPOINT, SqlParser.ST_ENVELOPE, SqlParser.ST_EQUALS, SqlParser.ST_EXTERIORRING, SqlParser.ST_GEOMCOLLFROMTEXT, SqlParser.ST_GEOMCOLLFROMTXT, SqlParser.ST_GEOMCOLLFROMWKB, SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, SqlParser.ST_GEOMETRYFROMTEXT, SqlParser.ST_GEOMETRYFROMWKB, SqlParser.ST_GEOMETRYN, SqlParser.ST_GEOMETRYTYPE, SqlParser.ST_GEOMFROMTEXT, SqlParser.ST_GEOMFROMWKB, SqlParser.ST_INTERIORRINGN, SqlParser.ST_INTERSECTION, SqlParser.ST_INTERSECTS, SqlParser.ST_ISCLOSED, SqlParser.ST_ISEMPTY, SqlParser.ST_ISSIMPLE, SqlParser.ST_LINEFROMTEXT, SqlParser.ST_LINEFROMWKB, SqlParser.ST_LINESTRINGFROMTEXT, SqlParser.ST_LINESTRINGFROMWKB, SqlParser.ST_NUMGEOMETRIES, SqlParser.ST_NUMINTERIORRING, SqlParser.ST_NUMINTERIORRINGS, SqlParser.ST_NUMPOINTS, SqlParser.ST_OVERLAPS, SqlParser.ST_POINTFROMTEXT, SqlParser.ST_POINTFROMWKB, SqlParser.ST_POINTN, SqlParser.ST_POLYFROMTEXT, SqlParser.ST_POLYFROMWKB, SqlParser.ST_POLYGONFROMTEXT, SqlParser.ST_POLYGONFROMWKB, SqlParser.ST_SRID, SqlParser.ST_STARTPOINT, SqlParser.ST_SYMDIFFERENCE, SqlParser.ST_TOUCHES, SqlParser.ST_UNION, SqlParser.ST_WITHIN, SqlParser.ST_X, SqlParser.ST_Y, SqlParser.SUBDATE, SqlParser.SUBSTRING_INDEX, SqlParser.SUBTIME, SqlParser.SYSTEM_USER, SqlParser.TAN, SqlParser.TIMEDIFF, SqlParser.TIMESTAMPADD, SqlParser.TIMESTAMPDIFF, SqlParser.TIME_FORMAT, SqlParser.TIME_TO_SEC, SqlParser.TOUCHES, SqlParser.TO_BASE64, SqlParser.TO_DAYS, SqlParser.TO_SECONDS, SqlParser.UCASE, SqlParser.UNCOMPRESS, SqlParser.UNCOMPRESSED_LENGTH, SqlParser.UNHEX, SqlParser.UNIX_TIMESTAMP, SqlParser.UPDATEXML, SqlParser.UPPER, SqlParser.UUID, SqlParser.UUID_SHORT, SqlParser.VALIDATE_PASSWORD_STRENGTH, SqlParser.VERSION, SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, SqlParser.WEEKDAY, SqlParser.WEEKOFYEAR, SqlParser.WEIGHT_STRING, SqlParser.WITHIN, SqlParser.YEARWEEK, SqlParser.Y_FUNCTION, SqlParser.X_FUNCTION, SqlParser.PLUS, SqlParser.MINUS, SqlParser.EXCLAMATION_SYMBOL, SqlParser.BIT_NOT_OP, SqlParser.LR_BRACKET, SqlParser.ZERO_DECIMAL, SqlParser.ONE_DECIMAL, SqlParser.TWO_DECIMAL, SqlParser.CHARSET_REVERSE_QOUTE_STRING, SqlParser.STRING_LITERAL, SqlParser.DECIMAL_LITERAL, SqlParser.HEXADECIMAL_LITERAL, SqlParser.ID, SqlParser.REVERSE_QUOTE_ID, SqlParser.LOCAL_ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 554
                self.expression(0)
                pass
            elif token in [SqlParser.DEFAULT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 555
                self.match(SqlParser.DEFAULT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfExistsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(SqlParser.IF, 0)

        def EXISTS(self):
            return self.getToken(SqlParser.EXISTS, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_ifExists

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfExists" ):
                listener.enterIfExists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfExists" ):
                listener.exitIfExists(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfExists" ):
                return visitor.visitIfExists(self)
            else:
                return visitor.visitChildren(self)




    def ifExists(self):

        localctx = SqlParser.IfExistsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_ifExists)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 558
            self.match(SqlParser.IF)
            self.state = 559
            self.match(SqlParser.EXISTS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfNotExistsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(SqlParser.IF, 0)

        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def EXISTS(self):
            return self.getToken(SqlParser.EXISTS, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_ifNotExists

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfNotExists" ):
                listener.enterIfNotExists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfNotExists" ):
                listener.exitIfNotExists(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfNotExists" ):
                return visitor.visitIfNotExists(self)
            else:
                return visitor.visitChildren(self)




    def ifNotExists(self):

        localctx = SqlParser.IfNotExistsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_ifNotExists)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 561
            self.match(SqlParser.IF)
            self.state = 562
            self.match(SqlParser.NOT)
            self.state = 563
            self.match(SqlParser.EXISTS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionCallContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_functionCall

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SpecificFunctionCallContext(FunctionCallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.FunctionCallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def specificFunction(self):
            return self.getTypedRuleContext(SqlParser.SpecificFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecificFunctionCall" ):
                listener.enterSpecificFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecificFunctionCall" ):
                listener.exitSpecificFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpecificFunctionCall" ):
                return visitor.visitSpecificFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class UdfFunctionCallContext(FunctionCallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.FunctionCallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fullId(self):
            return self.getTypedRuleContext(SqlParser.FullIdContext,0)

        def functionArgs(self):
            return self.getTypedRuleContext(SqlParser.FunctionArgsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUdfFunctionCall" ):
                listener.enterUdfFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUdfFunctionCall" ):
                listener.exitUdfFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUdfFunctionCall" ):
                return visitor.visitUdfFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class AggregateFunctionCallContext(FunctionCallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.FunctionCallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def aggregateWindowedFunction(self):
            return self.getTypedRuleContext(SqlParser.AggregateWindowedFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregateFunctionCall" ):
                listener.enterAggregateFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregateFunctionCall" ):
                listener.exitAggregateFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregateFunctionCall" ):
                return visitor.visitAggregateFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class ScalarFunctionCallContext(FunctionCallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.FunctionCallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def scalarFunctionName(self):
            return self.getTypedRuleContext(SqlParser.ScalarFunctionNameContext,0)

        def functionArgs(self):
            return self.getTypedRuleContext(SqlParser.FunctionArgsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScalarFunctionCall" ):
                listener.enterScalarFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScalarFunctionCall" ):
                listener.exitScalarFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScalarFunctionCall" ):
                return visitor.visitScalarFunctionCall(self)
            else:
                return visitor.visitChildren(self)



    def functionCall(self):

        localctx = SqlParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_functionCall)
        self._la = 0 # Token type
        try:
            self.state = 581
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
            if la_ == 1:
                localctx = SqlParser.SpecificFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 565
                self.specificFunction()
                pass

            elif la_ == 2:
                localctx = SqlParser.AggregateFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 566
                self.aggregateWindowedFunction()
                pass

            elif la_ == 3:
                localctx = SqlParser.ScalarFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 567
                self.scalarFunctionName()
                self.state = 568
                self.match(SqlParser.LR_BRACKET)
                self.state = 570
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlParser.CASE) | (1 << SqlParser.CAST) | (1 << SqlParser.CONVERT) | (1 << SqlParser.CURRENT_USER) | (1 << SqlParser.DATABASE) | (1 << SqlParser.EXISTS) | (1 << SqlParser.FALSE))) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (SqlParser.IF - 66)) | (1 << (SqlParser.INSERT - 66)) | (1 << (SqlParser.INTERVAL - 66)) | (1 << (SqlParser.LEFT - 66)) | (1 << (SqlParser.NOT - 66)) | (1 << (SqlParser.NULL_LITERAL - 66)) | (1 << (SqlParser.REPLACE - 66)) | (1 << (SqlParser.RIGHT - 66)))) != 0) or ((((_la - 153)) & ~0x3f) == 0 and ((1 << (_la - 153)) & ((1 << (SqlParser.TRUE - 153)) | (1 << (SqlParser.VALUES - 153)) | (1 << (SqlParser.DATE - 153)) | (1 << (SqlParser.TIME - 153)) | (1 << (SqlParser.TIMESTAMP - 153)) | (1 << (SqlParser.DATETIME - 153)) | (1 << (SqlParser.YEAR - 153)) | (1 << (SqlParser.CHAR - 153)) | (1 << (SqlParser.BINARY - 153)) | (1 << (SqlParser.TEXT - 153)) | (1 << (SqlParser.ENUM - 153)) | (1 << (SqlParser.SERIAL - 153)) | (1 << (SqlParser.AVG - 153)) | (1 << (SqlParser.BIT_AND - 153)) | (1 << (SqlParser.BIT_OR - 153)) | (1 << (SqlParser.BIT_XOR - 153)) | (1 << (SqlParser.COUNT - 153)))) != 0) or ((((_la - 217)) & ~0x3f) == 0 and ((1 << (_la - 217)) & ((1 << (SqlParser.GROUP_CONCAT - 217)) | (1 << (SqlParser.MAX - 217)) | (1 << (SqlParser.MIN - 217)) | (1 << (SqlParser.STD - 217)) | (1 << (SqlParser.STDDEV - 217)) | (1 << (SqlParser.STDDEV_POP - 217)) | (1 << (SqlParser.STDDEV_SAMP - 217)) | (1 << (SqlParser.SUM - 217)) | (1 << (SqlParser.VAR_POP - 217)) | (1 << (SqlParser.VAR_SAMP - 217)) | (1 << (SqlParser.VARIANCE - 217)) | (1 << (SqlParser.CURRENT_DATE - 217)) | (1 << (SqlParser.CURRENT_TIME - 217)) | (1 << (SqlParser.CURRENT_TIMESTAMP - 217)) | (1 << (SqlParser.LOCALTIME - 217)) | (1 << (SqlParser.CURDATE - 217)) | (1 << (SqlParser.CURTIME - 217)) | (1 << (SqlParser.DATE_ADD - 217)) | (1 << (SqlParser.DATE_SUB - 217)) | (1 << (SqlParser.EXTRACT - 217)) | (1 << (SqlParser.LOCALTIMESTAMP - 217)) | (1 << (SqlParser.NOW - 217)) | (1 << (SqlParser.POSITION - 217)) | (1 << (SqlParser.SUBSTR - 217)) | (1 << (SqlParser.SUBSTRING - 217)) | (1 << (SqlParser.SYSDATE - 217)) | (1 << (SqlParser.TRIM - 217)) | (1 << (SqlParser.UTC_DATE - 217)) | (1 << (SqlParser.UTC_TIME - 217)) | (1 << (SqlParser.UTC_TIMESTAMP - 217)) | (1 << (SqlParser.ACCOUNT - 217)) | (1 << (SqlParser.ACTION - 217)) | (1 << (SqlParser.AFTER - 217)) | (1 << (SqlParser.AGGREGATE - 217)) | (1 << (SqlParser.ALGORITHM - 217)) | (1 << (SqlParser.ANY - 217)) | (1 << (SqlParser.AT - 217)) | (1 << (SqlParser.AUTHORS - 217)) | (1 << (SqlParser.AUTOCOMMIT - 217)) | (1 << (SqlParser.AUTOEXTEND_SIZE - 217)) | (1 << (SqlParser.AUTO_INCREMENT - 217)) | (1 << (SqlParser.AVG_ROW_LENGTH - 217)) | (1 << (SqlParser.BEGIN - 217)) | (1 << (SqlParser.BINLOG - 217)) | (1 << (SqlParser.BIT - 217)) | (1 << (SqlParser.BLOCK - 217)) | (1 << (SqlParser.BOOL - 217)) | (1 << (SqlParser.BOOLEAN - 217)) | (1 << (SqlParser.BTREE - 217)) | (1 << (SqlParser.CACHE - 217)) | (1 << (SqlParser.CASCADED - 217)) | (1 << (SqlParser.CHAIN - 217)) | (1 << (SqlParser.CHANGED - 217)) | (1 << (SqlParser.CHANNEL - 217)) | (1 << (SqlParser.CHECKSUM - 217)) | (1 << (SqlParser.CIPHER - 217)) | (1 << (SqlParser.CLIENT - 217)) | (1 << (SqlParser.CLOSE - 217)) | (1 << (SqlParser.COALESCE - 217)) | (1 << (SqlParser.CODE - 217)) | (1 << (SqlParser.COLUMNS - 217)) | (1 << (SqlParser.COLUMN_FORMAT - 217)) | (1 << (SqlParser.COMMENT - 217)) | (1 << (SqlParser.COMMIT - 217)))) != 0) or ((((_la - 281)) & ~0x3f) == 0 and ((1 << (_la - 281)) & ((1 << (SqlParser.COMPACT - 281)) | (1 << (SqlParser.COMPLETION - 281)) | (1 << (SqlParser.COMPRESSED - 281)) | (1 << (SqlParser.COMPRESSION - 281)) | (1 << (SqlParser.CONCURRENT - 281)) | (1 << (SqlParser.CONNECTION - 281)) | (1 << (SqlParser.CONSISTENT - 281)) | (1 << (SqlParser.CONTAINS - 281)) | (1 << (SqlParser.CONTEXT - 281)) | (1 << (SqlParser.CONTRIBUTORS - 281)) | (1 << (SqlParser.COPY - 281)) | (1 << (SqlParser.CPU - 281)) | (1 << (SqlParser.DATA - 281)) | (1 << (SqlParser.DATAFILE - 281)) | (1 << (SqlParser.DEALLOCATE - 281)) | (1 << (SqlParser.DEFAULT_AUTH - 281)) | (1 << (SqlParser.DEFINER - 281)) | (1 << (SqlParser.DELAY_KEY_WRITE - 281)) | (1 << (SqlParser.DES_KEY_FILE - 281)) | (1 << (SqlParser.DIRECTORY - 281)) | (1 << (SqlParser.DISABLE - 281)) | (1 << (SqlParser.DISCARD - 281)) | (1 << (SqlParser.DISK - 281)) | (1 << (SqlParser.DO - 281)) | (1 << (SqlParser.DUMPFILE - 281)) | (1 << (SqlParser.DUPLICATE - 281)) | (1 << (SqlParser.DYNAMIC - 281)) | (1 << (SqlParser.ENABLE - 281)) | (1 << (SqlParser.ENCRYPTION - 281)) | (1 << (SqlParser.END - 281)) | (1 << (SqlParser.ENDS - 281)) | (1 << (SqlParser.ENGINE - 281)) | (1 << (SqlParser.ENGINES - 281)) | (1 << (SqlParser.ERROR - 281)) | (1 << (SqlParser.ERRORS - 281)) | (1 << (SqlParser.ESCAPE - 281)) | (1 << (SqlParser.EVEN - 281)) | (1 << (SqlParser.EVENT - 281)) | (1 << (SqlParser.EVENTS - 281)) | (1 << (SqlParser.EVERY - 281)) | (1 << (SqlParser.EXCHANGE - 281)) | (1 << (SqlParser.EXCLUSIVE - 281)) | (1 << (SqlParser.EXPIRE - 281)) | (1 << (SqlParser.EXPORT - 281)) | (1 << (SqlParser.EXTENDED - 281)) | (1 << (SqlParser.EXTENT_SIZE - 281)) | (1 << (SqlParser.FAST - 281)) | (1 << (SqlParser.FAULTS - 281)) | (1 << (SqlParser.FIELDS - 281)) | (1 << (SqlParser.FILE_BLOCK_SIZE - 281)) | (1 << (SqlParser.FILTER - 281)) | (1 << (SqlParser.FIRST - 281)) | (1 << (SqlParser.FIXED - 281)) | (1 << (SqlParser.FLUSH - 281)) | (1 << (SqlParser.FOLLOWS - 281)) | (1 << (SqlParser.FOUND - 281)) | (1 << (SqlParser.FULL - 281)) | (1 << (SqlParser.FUNCTION - 281)) | (1 << (SqlParser.GENERAL - 281)) | (1 << (SqlParser.GLOBAL - 281)) | (1 << (SqlParser.GRANTS - 281)) | (1 << (SqlParser.GROUP_REPLICATION - 281)) | (1 << (SqlParser.HANDLER - 281)) | (1 << (SqlParser.HASH - 281)))) != 0) or ((((_la - 345)) & ~0x3f) == 0 and ((1 << (_la - 345)) & ((1 << (SqlParser.HELP - 345)) | (1 << (SqlParser.HOST - 345)) | (1 << (SqlParser.HOSTS - 345)) | (1 << (SqlParser.IDENTIFIED - 345)) | (1 << (SqlParser.IGNORE_SERVER_IDS - 345)) | (1 << (SqlParser.IMPORT - 345)) | (1 << (SqlParser.INDEXES - 345)) | (1 << (SqlParser.INITIAL_SIZE - 345)) | (1 << (SqlParser.INPLACE - 345)) | (1 << (SqlParser.INSERT_METHOD - 345)) | (1 << (SqlParser.INSTALL - 345)) | (1 << (SqlParser.INSTANCE - 345)) | (1 << (SqlParser.INVOKER - 345)) | (1 << (SqlParser.IO - 345)) | (1 << (SqlParser.IO_THREAD - 345)) | (1 << (SqlParser.IPC - 345)) | (1 << (SqlParser.ISOLATION - 345)) | (1 << (SqlParser.ISSUER - 345)) | (1 << (SqlParser.JSON - 345)) | (1 << (SqlParser.KEY_BLOCK_SIZE - 345)) | (1 << (SqlParser.LANGUAGE - 345)) | (1 << (SqlParser.LAST - 345)) | (1 << (SqlParser.LEAVES - 345)) | (1 << (SqlParser.LESS - 345)) | (1 << (SqlParser.LEVEL - 345)) | (1 << (SqlParser.LIST - 345)) | (1 << (SqlParser.LOCAL - 345)) | (1 << (SqlParser.LOGFILE - 345)) | (1 << (SqlParser.LOGS - 345)) | (1 << (SqlParser.MASTER - 345)) | (1 << (SqlParser.MASTER_AUTO_POSITION - 345)) | (1 << (SqlParser.MASTER_CONNECT_RETRY - 345)) | (1 << (SqlParser.MASTER_DELAY - 345)) | (1 << (SqlParser.MASTER_HEARTBEAT_PERIOD - 345)) | (1 << (SqlParser.MASTER_HOST - 345)) | (1 << (SqlParser.MASTER_LOG_FILE - 345)) | (1 << (SqlParser.MASTER_LOG_POS - 345)) | (1 << (SqlParser.MASTER_PASSWORD - 345)) | (1 << (SqlParser.MASTER_PORT - 345)) | (1 << (SqlParser.MASTER_RETRY_COUNT - 345)) | (1 << (SqlParser.MASTER_SSL - 345)) | (1 << (SqlParser.MASTER_SSL_CA - 345)) | (1 << (SqlParser.MASTER_SSL_CAPATH - 345)) | (1 << (SqlParser.MASTER_SSL_CERT - 345)) | (1 << (SqlParser.MASTER_SSL_CIPHER - 345)) | (1 << (SqlParser.MASTER_SSL_CRL - 345)) | (1 << (SqlParser.MASTER_SSL_CRLPATH - 345)) | (1 << (SqlParser.MASTER_SSL_KEY - 345)) | (1 << (SqlParser.MASTER_TLS_VERSION - 345)) | (1 << (SqlParser.MASTER_USER - 345)) | (1 << (SqlParser.MAX_CONNECTIONS_PER_HOUR - 345)) | (1 << (SqlParser.MAX_QUERIES_PER_HOUR - 345)) | (1 << (SqlParser.MAX_ROWS - 345)) | (1 << (SqlParser.MAX_SIZE - 345)) | (1 << (SqlParser.MAX_UPDATES_PER_HOUR - 345)) | (1 << (SqlParser.MAX_USER_CONNECTIONS - 345)) | (1 << (SqlParser.MEDIUM - 345)) | (1 << (SqlParser.MERGE - 345)) | (1 << (SqlParser.MID - 345)) | (1 << (SqlParser.MIGRATE - 345)) | (1 << (SqlParser.MIN_ROWS - 345)) | (1 << (SqlParser.MODE - 345)) | (1 << (SqlParser.MODIFY - 345)) | (1 << (SqlParser.MUTEX - 345)))) != 0) or ((((_la - 409)) & ~0x3f) == 0 and ((1 << (_la - 409)) & ((1 << (SqlParser.MYSQL - 409)) | (1 << (SqlParser.NAME - 409)) | (1 << (SqlParser.NAMES - 409)) | (1 << (SqlParser.NCHAR - 409)) | (1 << (SqlParser.NEVER - 409)) | (1 << (SqlParser.NEXT - 409)) | (1 << (SqlParser.NO - 409)) | (1 << (SqlParser.NODEGROUP - 409)) | (1 << (SqlParser.NONE - 409)) | (1 << (SqlParser.OFFLINE - 409)) | (1 << (SqlParser.OFFSET - 409)) | (1 << (SqlParser.OJ - 409)) | (1 << (SqlParser.OLD_PASSWORD - 409)) | (1 << (SqlParser.ONE - 409)) | (1 << (SqlParser.ONLINE - 409)) | (1 << (SqlParser.ONLY - 409)) | (1 << (SqlParser.OPEN - 409)) | (1 << (SqlParser.OPTIMIZER_COSTS - 409)) | (1 << (SqlParser.OPTIONS - 409)) | (1 << (SqlParser.OWNER - 409)) | (1 << (SqlParser.PACK_KEYS - 409)) | (1 << (SqlParser.PAGE - 409)) | (1 << (SqlParser.PARSER - 409)) | (1 << (SqlParser.PARTIAL - 409)) | (1 << (SqlParser.PARTITIONING - 409)) | (1 << (SqlParser.PARTITIONS - 409)) | (1 << (SqlParser.PASSWORD - 409)) | (1 << (SqlParser.PHASE - 409)) | (1 << (SqlParser.PLUGIN - 409)) | (1 << (SqlParser.PLUGIN_DIR - 409)) | (1 << (SqlParser.PLUGINS - 409)) | (1 << (SqlParser.PORT - 409)) | (1 << (SqlParser.PRECEDES - 409)) | (1 << (SqlParser.PREPARE - 409)) | (1 << (SqlParser.PRESERVE - 409)) | (1 << (SqlParser.PREV - 409)) | (1 << (SqlParser.PROCESSLIST - 409)) | (1 << (SqlParser.PROFILE - 409)) | (1 << (SqlParser.PROFILES - 409)) | (1 << (SqlParser.PROXY - 409)) | (1 << (SqlParser.QUERY - 409)) | (1 << (SqlParser.QUICK - 409)) | (1 << (SqlParser.REBUILD - 409)) | (1 << (SqlParser.RECOVER - 409)) | (1 << (SqlParser.REDO_BUFFER_SIZE - 409)) | (1 << (SqlParser.REDUNDANT - 409)) | (1 << (SqlParser.RELAY - 409)) | (1 << (SqlParser.RELAY_LOG_FILE - 409)) | (1 << (SqlParser.RELAY_LOG_POS - 409)) | (1 << (SqlParser.RELAYLOG - 409)) | (1 << (SqlParser.REMOVE - 409)) | (1 << (SqlParser.REORGANIZE - 409)) | (1 << (SqlParser.REPAIR - 409)) | (1 << (SqlParser.REPLICATE_DO_DB - 409)) | (1 << (SqlParser.REPLICATE_DO_TABLE - 409)) | (1 << (SqlParser.REPLICATE_IGNORE_DB - 409)) | (1 << (SqlParser.REPLICATE_IGNORE_TABLE - 409)) | (1 << (SqlParser.REPLICATE_REWRITE_DB - 409)) | (1 << (SqlParser.REPLICATE_WILD_DO_TABLE - 409)) | (1 << (SqlParser.REPLICATE_WILD_IGNORE_TABLE - 409)) | (1 << (SqlParser.REPLICATION - 409)) | (1 << (SqlParser.RESET - 409)) | (1 << (SqlParser.RESUME - 409)) | (1 << (SqlParser.RETURNS - 409)))) != 0) or ((((_la - 473)) & ~0x3f) == 0 and ((1 << (_la - 473)) & ((1 << (SqlParser.ROLLBACK - 473)) | (1 << (SqlParser.ROLLUP - 473)) | (1 << (SqlParser.ROTATE - 473)) | (1 << (SqlParser.ROW - 473)) | (1 << (SqlParser.ROWS - 473)) | (1 << (SqlParser.ROW_FORMAT - 473)) | (1 << (SqlParser.SAVEPOINT - 473)) | (1 << (SqlParser.SCHEDULE - 473)) | (1 << (SqlParser.SECURITY - 473)) | (1 << (SqlParser.SERVER - 473)) | (1 << (SqlParser.SESSION - 473)) | (1 << (SqlParser.SHARE - 473)) | (1 << (SqlParser.SHARED - 473)) | (1 << (SqlParser.SIGNED - 473)) | (1 << (SqlParser.SIMPLE - 473)) | (1 << (SqlParser.SLAVE - 473)) | (1 << (SqlParser.SLOW - 473)) | (1 << (SqlParser.SNAPSHOT - 473)) | (1 << (SqlParser.SOCKET - 473)) | (1 << (SqlParser.SOME - 473)) | (1 << (SqlParser.SONAME - 473)) | (1 << (SqlParser.SOUNDS - 473)) | (1 << (SqlParser.SOURCE - 473)) | (1 << (SqlParser.SQL_AFTER_GTIDS - 473)) | (1 << (SqlParser.SQL_AFTER_MTS_GAPS - 473)) | (1 << (SqlParser.SQL_BEFORE_GTIDS - 473)) | (1 << (SqlParser.SQL_BUFFER_RESULT - 473)) | (1 << (SqlParser.SQL_CACHE - 473)) | (1 << (SqlParser.SQL_NO_CACHE - 473)) | (1 << (SqlParser.SQL_THREAD - 473)) | (1 << (SqlParser.START - 473)) | (1 << (SqlParser.STARTS - 473)) | (1 << (SqlParser.STATS_AUTO_RECALC - 473)) | (1 << (SqlParser.STATS_PERSISTENT - 473)) | (1 << (SqlParser.STATS_SAMPLE_PAGES - 473)) | (1 << (SqlParser.STATUS - 473)) | (1 << (SqlParser.STOP - 473)) | (1 << (SqlParser.STORAGE - 473)) | (1 << (SqlParser.STRING - 473)) | (1 << (SqlParser.SUBJECT - 473)) | (1 << (SqlParser.SUBPARTITION - 473)) | (1 << (SqlParser.SUBPARTITIONS - 473)) | (1 << (SqlParser.SUSPEND - 473)) | (1 << (SqlParser.SWAPS - 473)) | (1 << (SqlParser.SWITCHES - 473)) | (1 << (SqlParser.TABLESPACE - 473)) | (1 << (SqlParser.TEMPORARY - 473)) | (1 << (SqlParser.TEMPTABLE - 473)) | (1 << (SqlParser.THAN - 473)) | (1 << (SqlParser.TRADITIONAL - 473)) | (1 << (SqlParser.TRANSACTION - 473)) | (1 << (SqlParser.TRIGGERS - 473)) | (1 << (SqlParser.TRUNCATE - 473)) | (1 << (SqlParser.UNDEFINED - 473)) | (1 << (SqlParser.UNDOFILE - 473)) | (1 << (SqlParser.UNDO_BUFFER_SIZE - 473)) | (1 << (SqlParser.UNINSTALL - 473)) | (1 << (SqlParser.UNKNOWN - 473)) | (1 << (SqlParser.UNTIL - 473)) | (1 << (SqlParser.UPGRADE - 473)) | (1 << (SqlParser.USER - 473)) | (1 << (SqlParser.USE_FRM - 473)) | (1 << (SqlParser.USER_RESOURCES - 473)))) != 0) or ((((_la - 537)) & ~0x3f) == 0 and ((1 << (_la - 537)) & ((1 << (SqlParser.VALIDATION - 537)) | (1 << (SqlParser.VALUE - 537)) | (1 << (SqlParser.VARIABLES - 537)) | (1 << (SqlParser.VIEW - 537)) | (1 << (SqlParser.WAIT - 537)) | (1 << (SqlParser.WARNINGS - 537)) | (1 << (SqlParser.WITHOUT - 537)) | (1 << (SqlParser.WORK - 537)) | (1 << (SqlParser.WRAPPER - 537)) | (1 << (SqlParser.X509 - 537)) | (1 << (SqlParser.XA - 537)) | (1 << (SqlParser.XML - 537)) | (1 << (SqlParser.QUARTER - 537)) | (1 << (SqlParser.MONTH - 537)) | (1 << (SqlParser.DAY - 537)) | (1 << (SqlParser.HOUR - 537)) | (1 << (SqlParser.MINUTE - 537)) | (1 << (SqlParser.WEEK - 537)) | (1 << (SqlParser.SECOND - 537)) | (1 << (SqlParser.MICROSECOND - 537)) | (1 << (SqlParser.ASCII - 537)))) != 0) or ((((_la - 617)) & ~0x3f) == 0 and ((1 << (_la - 617)) & ((1 << (SqlParser.MEMORY - 617)) | (1 << (SqlParser.GEOMETRYCOLLECTION - 617)) | (1 << (SqlParser.LINESTRING - 617)) | (1 << (SqlParser.MULTILINESTRING - 617)) | (1 << (SqlParser.MULTIPOINT - 617)) | (1 << (SqlParser.MULTIPOLYGON - 617)) | (1 << (SqlParser.POINT - 617)) | (1 << (SqlParser.POLYGON - 617)) | (1 << (SqlParser.ABS - 617)) | (1 << (SqlParser.ACOS - 617)) | (1 << (SqlParser.ADDDATE - 617)) | (1 << (SqlParser.ADDTIME - 617)) | (1 << (SqlParser.AES_DECRYPT - 617)) | (1 << (SqlParser.AES_ENCRYPT - 617)) | (1 << (SqlParser.AREA - 617)) | (1 << (SqlParser.ASBINARY - 617)) | (1 << (SqlParser.ASIN - 617)) | (1 << (SqlParser.ASTEXT - 617)) | (1 << (SqlParser.ASWKB - 617)) | (1 << (SqlParser.ASWKT - 617)) | (1 << (SqlParser.ASYMMETRIC_DECRYPT - 617)) | (1 << (SqlParser.ASYMMETRIC_DERIVE - 617)) | (1 << (SqlParser.ASYMMETRIC_ENCRYPT - 617)) | (1 << (SqlParser.ASYMMETRIC_SIGN - 617)) | (1 << (SqlParser.ASYMMETRIC_VERIFY - 617)) | (1 << (SqlParser.ATAN - 617)) | (1 << (SqlParser.ATAN2 - 617)) | (1 << (SqlParser.BENCHMARK - 617)) | (1 << (SqlParser.BIN - 617)) | (1 << (SqlParser.BIT_COUNT - 617)) | (1 << (SqlParser.BIT_LENGTH - 617)) | (1 << (SqlParser.BUFFER - 617)) | (1 << (SqlParser.CEIL - 617)) | (1 << (SqlParser.CEILING - 617)) | (1 << (SqlParser.CENTROID - 617)) | (1 << (SqlParser.CHARACTER_LENGTH - 617)) | (1 << (SqlParser.CHARSET - 617)) | (1 << (SqlParser.CHAR_LENGTH - 617)) | (1 << (SqlParser.COERCIBILITY - 617)) | (1 << (SqlParser.COLLATION - 617)) | (1 << (SqlParser.COMPRESS - 617)) | (1 << (SqlParser.CONCAT - 617)) | (1 << (SqlParser.CONCAT_WS - 617)) | (1 << (SqlParser.CONNECTION_ID - 617)) | (1 << (SqlParser.CONV - 617)) | (1 << (SqlParser.CONVERT_TZ - 617)) | (1 << (SqlParser.COS - 617)) | (1 << (SqlParser.COT - 617)) | (1 << (SqlParser.CRC32 - 617)) | (1 << (SqlParser.CREATE_ASYMMETRIC_PRIV_KEY - 617)) | (1 << (SqlParser.CREATE_ASYMMETRIC_PUB_KEY - 617)) | (1 << (SqlParser.CREATE_DH_PARAMETERS - 617)) | (1 << (SqlParser.CREATE_DIGEST - 617)) | (1 << (SqlParser.CROSSES - 617)) | (1 << (SqlParser.DATEDIFF - 617)))) != 0) or ((((_la - 681)) & ~0x3f) == 0 and ((1 << (_la - 681)) & ((1 << (SqlParser.DATE_FORMAT - 681)) | (1 << (SqlParser.DAYNAME - 681)) | (1 << (SqlParser.DAYOFMONTH - 681)) | (1 << (SqlParser.DAYOFWEEK - 681)) | (1 << (SqlParser.DAYOFYEAR - 681)) | (1 << (SqlParser.DECODE - 681)) | (1 << (SqlParser.DEGREES - 681)) | (1 << (SqlParser.DES_DECRYPT - 681)) | (1 << (SqlParser.DES_ENCRYPT - 681)) | (1 << (SqlParser.DIMENSION - 681)) | (1 << (SqlParser.DISJOINT - 681)) | (1 << (SqlParser.ELT - 681)) | (1 << (SqlParser.ENCODE - 681)) | (1 << (SqlParser.ENCRYPT - 681)) | (1 << (SqlParser.ENDPOINT - 681)) | (1 << (SqlParser.ENVELOPE - 681)) | (1 << (SqlParser.EQUALS - 681)) | (1 << (SqlParser.EXP - 681)) | (1 << (SqlParser.EXPORT_SET - 681)) | (1 << (SqlParser.EXTERIORRING - 681)) | (1 << (SqlParser.EXTRACTVALUE - 681)) | (1 << (SqlParser.FIELD - 681)) | (1 << (SqlParser.FIND_IN_SET - 681)) | (1 << (SqlParser.FLOOR - 681)) | (1 << (SqlParser.FORMAT - 681)) | (1 << (SqlParser.FOUND_ROWS - 681)) | (1 << (SqlParser.FROM_BASE64 - 681)) | (1 << (SqlParser.FROM_DAYS - 681)) | (1 << (SqlParser.FROM_UNIXTIME - 681)) | (1 << (SqlParser.GEOMCOLLFROMTEXT - 681)) | (1 << (SqlParser.GEOMCOLLFROMWKB - 681)) | (1 << (SqlParser.GEOMETRYCOLLECTIONFROMTEXT - 681)) | (1 << (SqlParser.GEOMETRYCOLLECTIONFROMWKB - 681)) | (1 << (SqlParser.GEOMETRYFROMTEXT - 681)) | (1 << (SqlParser.GEOMETRYFROMWKB - 681)) | (1 << (SqlParser.GEOMETRYN - 681)) | (1 << (SqlParser.GEOMETRYTYPE - 681)) | (1 << (SqlParser.GEOMFROMTEXT - 681)) | (1 << (SqlParser.GEOMFROMWKB - 681)) | (1 << (SqlParser.GET_FORMAT - 681)) | (1 << (SqlParser.GET_LOCK - 681)) | (1 << (SqlParser.GLENGTH - 681)) | (1 << (SqlParser.GREATEST - 681)) | (1 << (SqlParser.GTID_SUBSET - 681)) | (1 << (SqlParser.GTID_SUBTRACT - 681)) | (1 << (SqlParser.HEX - 681)) | (1 << (SqlParser.IFNULL - 681)) | (1 << (SqlParser.INET6_ATON - 681)) | (1 << (SqlParser.INET6_NTOA - 681)) | (1 << (SqlParser.INET_ATON - 681)) | (1 << (SqlParser.INET_NTOA - 681)) | (1 << (SqlParser.INSTR - 681)) | (1 << (SqlParser.INTERIORRINGN - 681)) | (1 << (SqlParser.INTERSECTS - 681)) | (1 << (SqlParser.ISCLOSED - 681)) | (1 << (SqlParser.ISEMPTY - 681)) | (1 << (SqlParser.ISNULL - 681)) | (1 << (SqlParser.ISSIMPLE - 681)) | (1 << (SqlParser.IS_FREE_LOCK - 681)) | (1 << (SqlParser.IS_IPV4 - 681)) | (1 << (SqlParser.IS_IPV4_COMPAT - 681)) | (1 << (SqlParser.IS_IPV4_MAPPED - 681)) | (1 << (SqlParser.IS_IPV6 - 681)) | (1 << (SqlParser.IS_USED_LOCK - 681)))) != 0) or ((((_la - 745)) & ~0x3f) == 0 and ((1 << (_la - 745)) & ((1 << (SqlParser.LAST_INSERT_ID - 745)) | (1 << (SqlParser.LCASE - 745)) | (1 << (SqlParser.LEAST - 745)) | (1 << (SqlParser.LENGTH - 745)) | (1 << (SqlParser.LINEFROMTEXT - 745)) | (1 << (SqlParser.LINEFROMWKB - 745)) | (1 << (SqlParser.LINESTRINGFROMTEXT - 745)) | (1 << (SqlParser.LINESTRINGFROMWKB - 745)) | (1 << (SqlParser.LN - 745)) | (1 << (SqlParser.LOAD_FILE - 745)) | (1 << (SqlParser.LOCATE - 745)) | (1 << (SqlParser.LOG - 745)) | (1 << (SqlParser.LOG10 - 745)) | (1 << (SqlParser.LOG2 - 745)) | (1 << (SqlParser.LOWER - 745)) | (1 << (SqlParser.LPAD - 745)) | (1 << (SqlParser.LTRIM - 745)) | (1 << (SqlParser.MAKEDATE - 745)) | (1 << (SqlParser.MAKETIME - 745)) | (1 << (SqlParser.MAKE_SET - 745)) | (1 << (SqlParser.MASTER_POS_WAIT - 745)) | (1 << (SqlParser.MBRCONTAINS - 745)) | (1 << (SqlParser.MBRDISJOINT - 745)) | (1 << (SqlParser.MBREQUAL - 745)) | (1 << (SqlParser.MBRINTERSECTS - 745)) | (1 << (SqlParser.MBROVERLAPS - 745)) | (1 << (SqlParser.MBRTOUCHES - 745)) | (1 << (SqlParser.MBRWITHIN - 745)) | (1 << (SqlParser.MD5 - 745)) | (1 << (SqlParser.MLINEFROMTEXT - 745)) | (1 << (SqlParser.MLINEFROMWKB - 745)) | (1 << (SqlParser.MONTHNAME - 745)) | (1 << (SqlParser.MPOINTFROMTEXT - 745)) | (1 << (SqlParser.MPOINTFROMWKB - 745)) | (1 << (SqlParser.MPOLYFROMTEXT - 745)) | (1 << (SqlParser.MPOLYFROMWKB - 745)) | (1 << (SqlParser.MULTILINESTRINGFROMTEXT - 745)) | (1 << (SqlParser.MULTILINESTRINGFROMWKB - 745)) | (1 << (SqlParser.MULTIPOINTFROMTEXT - 745)) | (1 << (SqlParser.MULTIPOINTFROMWKB - 745)) | (1 << (SqlParser.MULTIPOLYGONFROMTEXT - 745)) | (1 << (SqlParser.MULTIPOLYGONFROMWKB - 745)) | (1 << (SqlParser.NAME_CONST - 745)) | (1 << (SqlParser.NULLIF - 745)) | (1 << (SqlParser.NUMGEOMETRIES - 745)) | (1 << (SqlParser.NUMINTERIORRINGS - 745)) | (1 << (SqlParser.NUMPOINTS - 745)) | (1 << (SqlParser.OCT - 745)) | (1 << (SqlParser.OCTET_LENGTH - 745)) | (1 << (SqlParser.ORD - 745)) | (1 << (SqlParser.OVERLAPS - 745)) | (1 << (SqlParser.PERIOD_ADD - 745)) | (1 << (SqlParser.PERIOD_DIFF - 745)) | (1 << (SqlParser.PI - 745)) | (1 << (SqlParser.POINTFROMTEXT - 745)) | (1 << (SqlParser.POINTFROMWKB - 745)) | (1 << (SqlParser.POINTN - 745)) | (1 << (SqlParser.POLYFROMTEXT - 745)) | (1 << (SqlParser.POLYFROMWKB - 745)) | (1 << (SqlParser.POLYGONFROMTEXT - 745)) | (1 << (SqlParser.POLYGONFROMWKB - 745)) | (1 << (SqlParser.POW - 745)) | (1 << (SqlParser.POWER - 745)) | (1 << (SqlParser.QUOTE - 745)))) != 0) or ((((_la - 809)) & ~0x3f) == 0 and ((1 << (_la - 809)) & ((1 << (SqlParser.RADIANS - 809)) | (1 << (SqlParser.RAND - 809)) | (1 << (SqlParser.RANDOM_BYTES - 809)) | (1 << (SqlParser.RELEASE_LOCK - 809)) | (1 << (SqlParser.REVERSE - 809)) | (1 << (SqlParser.ROUND - 809)) | (1 << (SqlParser.ROW_COUNT - 809)) | (1 << (SqlParser.RPAD - 809)) | (1 << (SqlParser.RTRIM - 809)) | (1 << (SqlParser.SEC_TO_TIME - 809)) | (1 << (SqlParser.SESSION_USER - 809)) | (1 << (SqlParser.SHA - 809)) | (1 << (SqlParser.SHA1 - 809)) | (1 << (SqlParser.SHA2 - 809)) | (1 << (SqlParser.SIGN - 809)) | (1 << (SqlParser.SIN - 809)) | (1 << (SqlParser.SLEEP - 809)) | (1 << (SqlParser.SOUNDEX - 809)) | (1 << (SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS - 809)) | (1 << (SqlParser.SQRT - 809)) | (1 << (SqlParser.SRID - 809)) | (1 << (SqlParser.STARTPOINT - 809)) | (1 << (SqlParser.STRCMP - 809)) | (1 << (SqlParser.STR_TO_DATE - 809)) | (1 << (SqlParser.ST_AREA - 809)) | (1 << (SqlParser.ST_ASBINARY - 809)) | (1 << (SqlParser.ST_ASTEXT - 809)) | (1 << (SqlParser.ST_ASWKB - 809)) | (1 << (SqlParser.ST_ASWKT - 809)) | (1 << (SqlParser.ST_BUFFER - 809)) | (1 << (SqlParser.ST_CENTROID - 809)) | (1 << (SqlParser.ST_CONTAINS - 809)) | (1 << (SqlParser.ST_CROSSES - 809)) | (1 << (SqlParser.ST_DIFFERENCE - 809)) | (1 << (SqlParser.ST_DIMENSION - 809)) | (1 << (SqlParser.ST_DISJOINT - 809)) | (1 << (SqlParser.ST_DISTANCE - 809)) | (1 << (SqlParser.ST_ENDPOINT - 809)) | (1 << (SqlParser.ST_ENVELOPE - 809)) | (1 << (SqlParser.ST_EQUALS - 809)) | (1 << (SqlParser.ST_EXTERIORRING - 809)) | (1 << (SqlParser.ST_GEOMCOLLFROMTEXT - 809)) | (1 << (SqlParser.ST_GEOMCOLLFROMTXT - 809)) | (1 << (SqlParser.ST_GEOMCOLLFROMWKB - 809)) | (1 << (SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT - 809)) | (1 << (SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB - 809)) | (1 << (SqlParser.ST_GEOMETRYFROMTEXT - 809)) | (1 << (SqlParser.ST_GEOMETRYFROMWKB - 809)) | (1 << (SqlParser.ST_GEOMETRYN - 809)) | (1 << (SqlParser.ST_GEOMETRYTYPE - 809)) | (1 << (SqlParser.ST_GEOMFROMTEXT - 809)) | (1 << (SqlParser.ST_GEOMFROMWKB - 809)) | (1 << (SqlParser.ST_INTERIORRINGN - 809)) | (1 << (SqlParser.ST_INTERSECTION - 809)) | (1 << (SqlParser.ST_INTERSECTS - 809)) | (1 << (SqlParser.ST_ISCLOSED - 809)) | (1 << (SqlParser.ST_ISEMPTY - 809)) | (1 << (SqlParser.ST_ISSIMPLE - 809)) | (1 << (SqlParser.ST_LINEFROMTEXT - 809)) | (1 << (SqlParser.ST_LINEFROMWKB - 809)) | (1 << (SqlParser.ST_LINESTRINGFROMTEXT - 809)) | (1 << (SqlParser.ST_LINESTRINGFROMWKB - 809)) | (1 << (SqlParser.ST_NUMGEOMETRIES - 809)) | (1 << (SqlParser.ST_NUMINTERIORRING - 809)))) != 0) or ((((_la - 873)) & ~0x3f) == 0 and ((1 << (_la - 873)) & ((1 << (SqlParser.ST_NUMINTERIORRINGS - 873)) | (1 << (SqlParser.ST_NUMPOINTS - 873)) | (1 << (SqlParser.ST_OVERLAPS - 873)) | (1 << (SqlParser.ST_POINTFROMTEXT - 873)) | (1 << (SqlParser.ST_POINTFROMWKB - 873)) | (1 << (SqlParser.ST_POINTN - 873)) | (1 << (SqlParser.ST_POLYFROMTEXT - 873)) | (1 << (SqlParser.ST_POLYFROMWKB - 873)) | (1 << (SqlParser.ST_POLYGONFROMTEXT - 873)) | (1 << (SqlParser.ST_POLYGONFROMWKB - 873)) | (1 << (SqlParser.ST_SRID - 873)) | (1 << (SqlParser.ST_STARTPOINT - 873)) | (1 << (SqlParser.ST_SYMDIFFERENCE - 873)) | (1 << (SqlParser.ST_TOUCHES - 873)) | (1 << (SqlParser.ST_UNION - 873)) | (1 << (SqlParser.ST_WITHIN - 873)) | (1 << (SqlParser.ST_X - 873)) | (1 << (SqlParser.ST_Y - 873)) | (1 << (SqlParser.SUBDATE - 873)) | (1 << (SqlParser.SUBSTRING_INDEX - 873)) | (1 << (SqlParser.SUBTIME - 873)) | (1 << (SqlParser.SYSTEM_USER - 873)) | (1 << (SqlParser.TAN - 873)) | (1 << (SqlParser.TIMEDIFF - 873)) | (1 << (SqlParser.TIMESTAMPADD - 873)) | (1 << (SqlParser.TIMESTAMPDIFF - 873)) | (1 << (SqlParser.TIME_FORMAT - 873)) | (1 << (SqlParser.TIME_TO_SEC - 873)) | (1 << (SqlParser.TOUCHES - 873)) | (1 << (SqlParser.TO_BASE64 - 873)) | (1 << (SqlParser.TO_DAYS - 873)) | (1 << (SqlParser.TO_SECONDS - 873)) | (1 << (SqlParser.UCASE - 873)) | (1 << (SqlParser.UNCOMPRESS - 873)) | (1 << (SqlParser.UNCOMPRESSED_LENGTH - 873)) | (1 << (SqlParser.UNHEX - 873)) | (1 << (SqlParser.UNIX_TIMESTAMP - 873)) | (1 << (SqlParser.UPDATEXML - 873)) | (1 << (SqlParser.UPPER - 873)) | (1 << (SqlParser.UUID - 873)) | (1 << (SqlParser.UUID_SHORT - 873)) | (1 << (SqlParser.VALIDATE_PASSWORD_STRENGTH - 873)) | (1 << (SqlParser.VERSION - 873)) | (1 << (SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 873)) | (1 << (SqlParser.WEEKDAY - 873)) | (1 << (SqlParser.WEEKOFYEAR - 873)) | (1 << (SqlParser.WEIGHT_STRING - 873)) | (1 << (SqlParser.WITHIN - 873)) | (1 << (SqlParser.YEARWEEK - 873)) | (1 << (SqlParser.Y_FUNCTION - 873)) | (1 << (SqlParser.X_FUNCTION - 873)) | (1 << (SqlParser.PLUS - 873)))) != 0) or ((((_la - 938)) & ~0x3f) == 0 and ((1 << (_la - 938)) & ((1 << (SqlParser.MINUS - 938)) | (1 << (SqlParser.EXCLAMATION_SYMBOL - 938)) | (1 << (SqlParser.BIT_NOT_OP - 938)) | (1 << (SqlParser.LR_BRACKET - 938)) | (1 << (SqlParser.ZERO_DECIMAL - 938)) | (1 << (SqlParser.ONE_DECIMAL - 938)) | (1 << (SqlParser.TWO_DECIMAL - 938)) | (1 << (SqlParser.CHARSET_REVERSE_QOUTE_STRING - 938)) | (1 << (SqlParser.STRING_LITERAL - 938)) | (1 << (SqlParser.DECIMAL_LITERAL - 938)) | (1 << (SqlParser.HEXADECIMAL_LITERAL - 938)) | (1 << (SqlParser.ID - 938)) | (1 << (SqlParser.REVERSE_QUOTE_ID - 938)) | (1 << (SqlParser.LOCAL_ID - 938)))) != 0):
                    self.state = 569
                    self.functionArgs()


                self.state = 572
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 4:
                localctx = SqlParser.UdfFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 574
                self.fullId()
                self.state = 575
                self.match(SqlParser.LR_BRACKET)
                self.state = 577
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SqlParser.CASE) | (1 << SqlParser.CAST) | (1 << SqlParser.CONVERT) | (1 << SqlParser.CURRENT_USER) | (1 << SqlParser.DATABASE) | (1 << SqlParser.EXISTS) | (1 << SqlParser.FALSE))) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (SqlParser.IF - 66)) | (1 << (SqlParser.INSERT - 66)) | (1 << (SqlParser.INTERVAL - 66)) | (1 << (SqlParser.LEFT - 66)) | (1 << (SqlParser.NOT - 66)) | (1 << (SqlParser.NULL_LITERAL - 66)) | (1 << (SqlParser.REPLACE - 66)) | (1 << (SqlParser.RIGHT - 66)))) != 0) or ((((_la - 153)) & ~0x3f) == 0 and ((1 << (_la - 153)) & ((1 << (SqlParser.TRUE - 153)) | (1 << (SqlParser.VALUES - 153)) | (1 << (SqlParser.DATE - 153)) | (1 << (SqlParser.TIME - 153)) | (1 << (SqlParser.TIMESTAMP - 153)) | (1 << (SqlParser.DATETIME - 153)) | (1 << (SqlParser.YEAR - 153)) | (1 << (SqlParser.CHAR - 153)) | (1 << (SqlParser.BINARY - 153)) | (1 << (SqlParser.TEXT - 153)) | (1 << (SqlParser.ENUM - 153)) | (1 << (SqlParser.SERIAL - 153)) | (1 << (SqlParser.AVG - 153)) | (1 << (SqlParser.BIT_AND - 153)) | (1 << (SqlParser.BIT_OR - 153)) | (1 << (SqlParser.BIT_XOR - 153)) | (1 << (SqlParser.COUNT - 153)))) != 0) or ((((_la - 217)) & ~0x3f) == 0 and ((1 << (_la - 217)) & ((1 << (SqlParser.GROUP_CONCAT - 217)) | (1 << (SqlParser.MAX - 217)) | (1 << (SqlParser.MIN - 217)) | (1 << (SqlParser.STD - 217)) | (1 << (SqlParser.STDDEV - 217)) | (1 << (SqlParser.STDDEV_POP - 217)) | (1 << (SqlParser.STDDEV_SAMP - 217)) | (1 << (SqlParser.SUM - 217)) | (1 << (SqlParser.VAR_POP - 217)) | (1 << (SqlParser.VAR_SAMP - 217)) | (1 << (SqlParser.VARIANCE - 217)) | (1 << (SqlParser.CURRENT_DATE - 217)) | (1 << (SqlParser.CURRENT_TIME - 217)) | (1 << (SqlParser.CURRENT_TIMESTAMP - 217)) | (1 << (SqlParser.LOCALTIME - 217)) | (1 << (SqlParser.CURDATE - 217)) | (1 << (SqlParser.CURTIME - 217)) | (1 << (SqlParser.DATE_ADD - 217)) | (1 << (SqlParser.DATE_SUB - 217)) | (1 << (SqlParser.EXTRACT - 217)) | (1 << (SqlParser.LOCALTIMESTAMP - 217)) | (1 << (SqlParser.NOW - 217)) | (1 << (SqlParser.POSITION - 217)) | (1 << (SqlParser.SUBSTR - 217)) | (1 << (SqlParser.SUBSTRING - 217)) | (1 << (SqlParser.SYSDATE - 217)) | (1 << (SqlParser.TRIM - 217)) | (1 << (SqlParser.UTC_DATE - 217)) | (1 << (SqlParser.UTC_TIME - 217)) | (1 << (SqlParser.UTC_TIMESTAMP - 217)) | (1 << (SqlParser.ACCOUNT - 217)) | (1 << (SqlParser.ACTION - 217)) | (1 << (SqlParser.AFTER - 217)) | (1 << (SqlParser.AGGREGATE - 217)) | (1 << (SqlParser.ALGORITHM - 217)) | (1 << (SqlParser.ANY - 217)) | (1 << (SqlParser.AT - 217)) | (1 << (SqlParser.AUTHORS - 217)) | (1 << (SqlParser.AUTOCOMMIT - 217)) | (1 << (SqlParser.AUTOEXTEND_SIZE - 217)) | (1 << (SqlParser.AUTO_INCREMENT - 217)) | (1 << (SqlParser.AVG_ROW_LENGTH - 217)) | (1 << (SqlParser.BEGIN - 217)) | (1 << (SqlParser.BINLOG - 217)) | (1 << (SqlParser.BIT - 217)) | (1 << (SqlParser.BLOCK - 217)) | (1 << (SqlParser.BOOL - 217)) | (1 << (SqlParser.BOOLEAN - 217)) | (1 << (SqlParser.BTREE - 217)) | (1 << (SqlParser.CACHE - 217)) | (1 << (SqlParser.CASCADED - 217)) | (1 << (SqlParser.CHAIN - 217)) | (1 << (SqlParser.CHANGED - 217)) | (1 << (SqlParser.CHANNEL - 217)) | (1 << (SqlParser.CHECKSUM - 217)) | (1 << (SqlParser.CIPHER - 217)) | (1 << (SqlParser.CLIENT - 217)) | (1 << (SqlParser.CLOSE - 217)) | (1 << (SqlParser.COALESCE - 217)) | (1 << (SqlParser.CODE - 217)) | (1 << (SqlParser.COLUMNS - 217)) | (1 << (SqlParser.COLUMN_FORMAT - 217)) | (1 << (SqlParser.COMMENT - 217)) | (1 << (SqlParser.COMMIT - 217)))) != 0) or ((((_la - 281)) & ~0x3f) == 0 and ((1 << (_la - 281)) & ((1 << (SqlParser.COMPACT - 281)) | (1 << (SqlParser.COMPLETION - 281)) | (1 << (SqlParser.COMPRESSED - 281)) | (1 << (SqlParser.COMPRESSION - 281)) | (1 << (SqlParser.CONCURRENT - 281)) | (1 << (SqlParser.CONNECTION - 281)) | (1 << (SqlParser.CONSISTENT - 281)) | (1 << (SqlParser.CONTAINS - 281)) | (1 << (SqlParser.CONTEXT - 281)) | (1 << (SqlParser.CONTRIBUTORS - 281)) | (1 << (SqlParser.COPY - 281)) | (1 << (SqlParser.CPU - 281)) | (1 << (SqlParser.DATA - 281)) | (1 << (SqlParser.DATAFILE - 281)) | (1 << (SqlParser.DEALLOCATE - 281)) | (1 << (SqlParser.DEFAULT_AUTH - 281)) | (1 << (SqlParser.DEFINER - 281)) | (1 << (SqlParser.DELAY_KEY_WRITE - 281)) | (1 << (SqlParser.DES_KEY_FILE - 281)) | (1 << (SqlParser.DIRECTORY - 281)) | (1 << (SqlParser.DISABLE - 281)) | (1 << (SqlParser.DISCARD - 281)) | (1 << (SqlParser.DISK - 281)) | (1 << (SqlParser.DO - 281)) | (1 << (SqlParser.DUMPFILE - 281)) | (1 << (SqlParser.DUPLICATE - 281)) | (1 << (SqlParser.DYNAMIC - 281)) | (1 << (SqlParser.ENABLE - 281)) | (1 << (SqlParser.ENCRYPTION - 281)) | (1 << (SqlParser.END - 281)) | (1 << (SqlParser.ENDS - 281)) | (1 << (SqlParser.ENGINE - 281)) | (1 << (SqlParser.ENGINES - 281)) | (1 << (SqlParser.ERROR - 281)) | (1 << (SqlParser.ERRORS - 281)) | (1 << (SqlParser.ESCAPE - 281)) | (1 << (SqlParser.EVEN - 281)) | (1 << (SqlParser.EVENT - 281)) | (1 << (SqlParser.EVENTS - 281)) | (1 << (SqlParser.EVERY - 281)) | (1 << (SqlParser.EXCHANGE - 281)) | (1 << (SqlParser.EXCLUSIVE - 281)) | (1 << (SqlParser.EXPIRE - 281)) | (1 << (SqlParser.EXPORT - 281)) | (1 << (SqlParser.EXTENDED - 281)) | (1 << (SqlParser.EXTENT_SIZE - 281)) | (1 << (SqlParser.FAST - 281)) | (1 << (SqlParser.FAULTS - 281)) | (1 << (SqlParser.FIELDS - 281)) | (1 << (SqlParser.FILE_BLOCK_SIZE - 281)) | (1 << (SqlParser.FILTER - 281)) | (1 << (SqlParser.FIRST - 281)) | (1 << (SqlParser.FIXED - 281)) | (1 << (SqlParser.FLUSH - 281)) | (1 << (SqlParser.FOLLOWS - 281)) | (1 << (SqlParser.FOUND - 281)) | (1 << (SqlParser.FULL - 281)) | (1 << (SqlParser.FUNCTION - 281)) | (1 << (SqlParser.GENERAL - 281)) | (1 << (SqlParser.GLOBAL - 281)) | (1 << (SqlParser.GRANTS - 281)) | (1 << (SqlParser.GROUP_REPLICATION - 281)) | (1 << (SqlParser.HANDLER - 281)) | (1 << (SqlParser.HASH - 281)))) != 0) or ((((_la - 345)) & ~0x3f) == 0 and ((1 << (_la - 345)) & ((1 << (SqlParser.HELP - 345)) | (1 << (SqlParser.HOST - 345)) | (1 << (SqlParser.HOSTS - 345)) | (1 << (SqlParser.IDENTIFIED - 345)) | (1 << (SqlParser.IGNORE_SERVER_IDS - 345)) | (1 << (SqlParser.IMPORT - 345)) | (1 << (SqlParser.INDEXES - 345)) | (1 << (SqlParser.INITIAL_SIZE - 345)) | (1 << (SqlParser.INPLACE - 345)) | (1 << (SqlParser.INSERT_METHOD - 345)) | (1 << (SqlParser.INSTALL - 345)) | (1 << (SqlParser.INSTANCE - 345)) | (1 << (SqlParser.INVOKER - 345)) | (1 << (SqlParser.IO - 345)) | (1 << (SqlParser.IO_THREAD - 345)) | (1 << (SqlParser.IPC - 345)) | (1 << (SqlParser.ISOLATION - 345)) | (1 << (SqlParser.ISSUER - 345)) | (1 << (SqlParser.JSON - 345)) | (1 << (SqlParser.KEY_BLOCK_SIZE - 345)) | (1 << (SqlParser.LANGUAGE - 345)) | (1 << (SqlParser.LAST - 345)) | (1 << (SqlParser.LEAVES - 345)) | (1 << (SqlParser.LESS - 345)) | (1 << (SqlParser.LEVEL - 345)) | (1 << (SqlParser.LIST - 345)) | (1 << (SqlParser.LOCAL - 345)) | (1 << (SqlParser.LOGFILE - 345)) | (1 << (SqlParser.LOGS - 345)) | (1 << (SqlParser.MASTER - 345)) | (1 << (SqlParser.MASTER_AUTO_POSITION - 345)) | (1 << (SqlParser.MASTER_CONNECT_RETRY - 345)) | (1 << (SqlParser.MASTER_DELAY - 345)) | (1 << (SqlParser.MASTER_HEARTBEAT_PERIOD - 345)) | (1 << (SqlParser.MASTER_HOST - 345)) | (1 << (SqlParser.MASTER_LOG_FILE - 345)) | (1 << (SqlParser.MASTER_LOG_POS - 345)) | (1 << (SqlParser.MASTER_PASSWORD - 345)) | (1 << (SqlParser.MASTER_PORT - 345)) | (1 << (SqlParser.MASTER_RETRY_COUNT - 345)) | (1 << (SqlParser.MASTER_SSL - 345)) | (1 << (SqlParser.MASTER_SSL_CA - 345)) | (1 << (SqlParser.MASTER_SSL_CAPATH - 345)) | (1 << (SqlParser.MASTER_SSL_CERT - 345)) | (1 << (SqlParser.MASTER_SSL_CIPHER - 345)) | (1 << (SqlParser.MASTER_SSL_CRL - 345)) | (1 << (SqlParser.MASTER_SSL_CRLPATH - 345)) | (1 << (SqlParser.MASTER_SSL_KEY - 345)) | (1 << (SqlParser.MASTER_TLS_VERSION - 345)) | (1 << (SqlParser.MASTER_USER - 345)) | (1 << (SqlParser.MAX_CONNECTIONS_PER_HOUR - 345)) | (1 << (SqlParser.MAX_QUERIES_PER_HOUR - 345)) | (1 << (SqlParser.MAX_ROWS - 345)) | (1 << (SqlParser.MAX_SIZE - 345)) | (1 << (SqlParser.MAX_UPDATES_PER_HOUR - 345)) | (1 << (SqlParser.MAX_USER_CONNECTIONS - 345)) | (1 << (SqlParser.MEDIUM - 345)) | (1 << (SqlParser.MERGE - 345)) | (1 << (SqlParser.MID - 345)) | (1 << (SqlParser.MIGRATE - 345)) | (1 << (SqlParser.MIN_ROWS - 345)) | (1 << (SqlParser.MODE - 345)) | (1 << (SqlParser.MODIFY - 345)) | (1 << (SqlParser.MUTEX - 345)))) != 0) or ((((_la - 409)) & ~0x3f) == 0 and ((1 << (_la - 409)) & ((1 << (SqlParser.MYSQL - 409)) | (1 << (SqlParser.NAME - 409)) | (1 << (SqlParser.NAMES - 409)) | (1 << (SqlParser.NCHAR - 409)) | (1 << (SqlParser.NEVER - 409)) | (1 << (SqlParser.NEXT - 409)) | (1 << (SqlParser.NO - 409)) | (1 << (SqlParser.NODEGROUP - 409)) | (1 << (SqlParser.NONE - 409)) | (1 << (SqlParser.OFFLINE - 409)) | (1 << (SqlParser.OFFSET - 409)) | (1 << (SqlParser.OJ - 409)) | (1 << (SqlParser.OLD_PASSWORD - 409)) | (1 << (SqlParser.ONE - 409)) | (1 << (SqlParser.ONLINE - 409)) | (1 << (SqlParser.ONLY - 409)) | (1 << (SqlParser.OPEN - 409)) | (1 << (SqlParser.OPTIMIZER_COSTS - 409)) | (1 << (SqlParser.OPTIONS - 409)) | (1 << (SqlParser.OWNER - 409)) | (1 << (SqlParser.PACK_KEYS - 409)) | (1 << (SqlParser.PAGE - 409)) | (1 << (SqlParser.PARSER - 409)) | (1 << (SqlParser.PARTIAL - 409)) | (1 << (SqlParser.PARTITIONING - 409)) | (1 << (SqlParser.PARTITIONS - 409)) | (1 << (SqlParser.PASSWORD - 409)) | (1 << (SqlParser.PHASE - 409)) | (1 << (SqlParser.PLUGIN - 409)) | (1 << (SqlParser.PLUGIN_DIR - 409)) | (1 << (SqlParser.PLUGINS - 409)) | (1 << (SqlParser.PORT - 409)) | (1 << (SqlParser.PRECEDES - 409)) | (1 << (SqlParser.PREPARE - 409)) | (1 << (SqlParser.PRESERVE - 409)) | (1 << (SqlParser.PREV - 409)) | (1 << (SqlParser.PROCESSLIST - 409)) | (1 << (SqlParser.PROFILE - 409)) | (1 << (SqlParser.PROFILES - 409)) | (1 << (SqlParser.PROXY - 409)) | (1 << (SqlParser.QUERY - 409)) | (1 << (SqlParser.QUICK - 409)) | (1 << (SqlParser.REBUILD - 409)) | (1 << (SqlParser.RECOVER - 409)) | (1 << (SqlParser.REDO_BUFFER_SIZE - 409)) | (1 << (SqlParser.REDUNDANT - 409)) | (1 << (SqlParser.RELAY - 409)) | (1 << (SqlParser.RELAY_LOG_FILE - 409)) | (1 << (SqlParser.RELAY_LOG_POS - 409)) | (1 << (SqlParser.RELAYLOG - 409)) | (1 << (SqlParser.REMOVE - 409)) | (1 << (SqlParser.REORGANIZE - 409)) | (1 << (SqlParser.REPAIR - 409)) | (1 << (SqlParser.REPLICATE_DO_DB - 409)) | (1 << (SqlParser.REPLICATE_DO_TABLE - 409)) | (1 << (SqlParser.REPLICATE_IGNORE_DB - 409)) | (1 << (SqlParser.REPLICATE_IGNORE_TABLE - 409)) | (1 << (SqlParser.REPLICATE_REWRITE_DB - 409)) | (1 << (SqlParser.REPLICATE_WILD_DO_TABLE - 409)) | (1 << (SqlParser.REPLICATE_WILD_IGNORE_TABLE - 409)) | (1 << (SqlParser.REPLICATION - 409)) | (1 << (SqlParser.RESET - 409)) | (1 << (SqlParser.RESUME - 409)) | (1 << (SqlParser.RETURNS - 409)))) != 0) or ((((_la - 473)) & ~0x3f) == 0 and ((1 << (_la - 473)) & ((1 << (SqlParser.ROLLBACK - 473)) | (1 << (SqlParser.ROLLUP - 473)) | (1 << (SqlParser.ROTATE - 473)) | (1 << (SqlParser.ROW - 473)) | (1 << (SqlParser.ROWS - 473)) | (1 << (SqlParser.ROW_FORMAT - 473)) | (1 << (SqlParser.SAVEPOINT - 473)) | (1 << (SqlParser.SCHEDULE - 473)) | (1 << (SqlParser.SECURITY - 473)) | (1 << (SqlParser.SERVER - 473)) | (1 << (SqlParser.SESSION - 473)) | (1 << (SqlParser.SHARE - 473)) | (1 << (SqlParser.SHARED - 473)) | (1 << (SqlParser.SIGNED - 473)) | (1 << (SqlParser.SIMPLE - 473)) | (1 << (SqlParser.SLAVE - 473)) | (1 << (SqlParser.SLOW - 473)) | (1 << (SqlParser.SNAPSHOT - 473)) | (1 << (SqlParser.SOCKET - 473)) | (1 << (SqlParser.SOME - 473)) | (1 << (SqlParser.SONAME - 473)) | (1 << (SqlParser.SOUNDS - 473)) | (1 << (SqlParser.SOURCE - 473)) | (1 << (SqlParser.SQL_AFTER_GTIDS - 473)) | (1 << (SqlParser.SQL_AFTER_MTS_GAPS - 473)) | (1 << (SqlParser.SQL_BEFORE_GTIDS - 473)) | (1 << (SqlParser.SQL_BUFFER_RESULT - 473)) | (1 << (SqlParser.SQL_CACHE - 473)) | (1 << (SqlParser.SQL_NO_CACHE - 473)) | (1 << (SqlParser.SQL_THREAD - 473)) | (1 << (SqlParser.START - 473)) | (1 << (SqlParser.STARTS - 473)) | (1 << (SqlParser.STATS_AUTO_RECALC - 473)) | (1 << (SqlParser.STATS_PERSISTENT - 473)) | (1 << (SqlParser.STATS_SAMPLE_PAGES - 473)) | (1 << (SqlParser.STATUS - 473)) | (1 << (SqlParser.STOP - 473)) | (1 << (SqlParser.STORAGE - 473)) | (1 << (SqlParser.STRING - 473)) | (1 << (SqlParser.SUBJECT - 473)) | (1 << (SqlParser.SUBPARTITION - 473)) | (1 << (SqlParser.SUBPARTITIONS - 473)) | (1 << (SqlParser.SUSPEND - 473)) | (1 << (SqlParser.SWAPS - 473)) | (1 << (SqlParser.SWITCHES - 473)) | (1 << (SqlParser.TABLESPACE - 473)) | (1 << (SqlParser.TEMPORARY - 473)) | (1 << (SqlParser.TEMPTABLE - 473)) | (1 << (SqlParser.THAN - 473)) | (1 << (SqlParser.TRADITIONAL - 473)) | (1 << (SqlParser.TRANSACTION - 473)) | (1 << (SqlParser.TRIGGERS - 473)) | (1 << (SqlParser.TRUNCATE - 473)) | (1 << (SqlParser.UNDEFINED - 473)) | (1 << (SqlParser.UNDOFILE - 473)) | (1 << (SqlParser.UNDO_BUFFER_SIZE - 473)) | (1 << (SqlParser.UNINSTALL - 473)) | (1 << (SqlParser.UNKNOWN - 473)) | (1 << (SqlParser.UNTIL - 473)) | (1 << (SqlParser.UPGRADE - 473)) | (1 << (SqlParser.USER - 473)) | (1 << (SqlParser.USE_FRM - 473)) | (1 << (SqlParser.USER_RESOURCES - 473)))) != 0) or ((((_la - 537)) & ~0x3f) == 0 and ((1 << (_la - 537)) & ((1 << (SqlParser.VALIDATION - 537)) | (1 << (SqlParser.VALUE - 537)) | (1 << (SqlParser.VARIABLES - 537)) | (1 << (SqlParser.VIEW - 537)) | (1 << (SqlParser.WAIT - 537)) | (1 << (SqlParser.WARNINGS - 537)) | (1 << (SqlParser.WITHOUT - 537)) | (1 << (SqlParser.WORK - 537)) | (1 << (SqlParser.WRAPPER - 537)) | (1 << (SqlParser.X509 - 537)) | (1 << (SqlParser.XA - 537)) | (1 << (SqlParser.XML - 537)) | (1 << (SqlParser.QUARTER - 537)) | (1 << (SqlParser.MONTH - 537)) | (1 << (SqlParser.DAY - 537)) | (1 << (SqlParser.HOUR - 537)) | (1 << (SqlParser.MINUTE - 537)) | (1 << (SqlParser.WEEK - 537)) | (1 << (SqlParser.SECOND - 537)) | (1 << (SqlParser.MICROSECOND - 537)) | (1 << (SqlParser.ASCII - 537)))) != 0) or ((((_la - 617)) & ~0x3f) == 0 and ((1 << (_la - 617)) & ((1 << (SqlParser.MEMORY - 617)) | (1 << (SqlParser.GEOMETRYCOLLECTION - 617)) | (1 << (SqlParser.LINESTRING - 617)) | (1 << (SqlParser.MULTILINESTRING - 617)) | (1 << (SqlParser.MULTIPOINT - 617)) | (1 << (SqlParser.MULTIPOLYGON - 617)) | (1 << (SqlParser.POINT - 617)) | (1 << (SqlParser.POLYGON - 617)) | (1 << (SqlParser.ABS - 617)) | (1 << (SqlParser.ACOS - 617)) | (1 << (SqlParser.ADDDATE - 617)) | (1 << (SqlParser.ADDTIME - 617)) | (1 << (SqlParser.AES_DECRYPT - 617)) | (1 << (SqlParser.AES_ENCRYPT - 617)) | (1 << (SqlParser.AREA - 617)) | (1 << (SqlParser.ASBINARY - 617)) | (1 << (SqlParser.ASIN - 617)) | (1 << (SqlParser.ASTEXT - 617)) | (1 << (SqlParser.ASWKB - 617)) | (1 << (SqlParser.ASWKT - 617)) | (1 << (SqlParser.ASYMMETRIC_DECRYPT - 617)) | (1 << (SqlParser.ASYMMETRIC_DERIVE - 617)) | (1 << (SqlParser.ASYMMETRIC_ENCRYPT - 617)) | (1 << (SqlParser.ASYMMETRIC_SIGN - 617)) | (1 << (SqlParser.ASYMMETRIC_VERIFY - 617)) | (1 << (SqlParser.ATAN - 617)) | (1 << (SqlParser.ATAN2 - 617)) | (1 << (SqlParser.BENCHMARK - 617)) | (1 << (SqlParser.BIN - 617)) | (1 << (SqlParser.BIT_COUNT - 617)) | (1 << (SqlParser.BIT_LENGTH - 617)) | (1 << (SqlParser.BUFFER - 617)) | (1 << (SqlParser.CEIL - 617)) | (1 << (SqlParser.CEILING - 617)) | (1 << (SqlParser.CENTROID - 617)) | (1 << (SqlParser.CHARACTER_LENGTH - 617)) | (1 << (SqlParser.CHARSET - 617)) | (1 << (SqlParser.CHAR_LENGTH - 617)) | (1 << (SqlParser.COERCIBILITY - 617)) | (1 << (SqlParser.COLLATION - 617)) | (1 << (SqlParser.COMPRESS - 617)) | (1 << (SqlParser.CONCAT - 617)) | (1 << (SqlParser.CONCAT_WS - 617)) | (1 << (SqlParser.CONNECTION_ID - 617)) | (1 << (SqlParser.CONV - 617)) | (1 << (SqlParser.CONVERT_TZ - 617)) | (1 << (SqlParser.COS - 617)) | (1 << (SqlParser.COT - 617)) | (1 << (SqlParser.CRC32 - 617)) | (1 << (SqlParser.CREATE_ASYMMETRIC_PRIV_KEY - 617)) | (1 << (SqlParser.CREATE_ASYMMETRIC_PUB_KEY - 617)) | (1 << (SqlParser.CREATE_DH_PARAMETERS - 617)) | (1 << (SqlParser.CREATE_DIGEST - 617)) | (1 << (SqlParser.CROSSES - 617)) | (1 << (SqlParser.DATEDIFF - 617)))) != 0) or ((((_la - 681)) & ~0x3f) == 0 and ((1 << (_la - 681)) & ((1 << (SqlParser.DATE_FORMAT - 681)) | (1 << (SqlParser.DAYNAME - 681)) | (1 << (SqlParser.DAYOFMONTH - 681)) | (1 << (SqlParser.DAYOFWEEK - 681)) | (1 << (SqlParser.DAYOFYEAR - 681)) | (1 << (SqlParser.DECODE - 681)) | (1 << (SqlParser.DEGREES - 681)) | (1 << (SqlParser.DES_DECRYPT - 681)) | (1 << (SqlParser.DES_ENCRYPT - 681)) | (1 << (SqlParser.DIMENSION - 681)) | (1 << (SqlParser.DISJOINT - 681)) | (1 << (SqlParser.ELT - 681)) | (1 << (SqlParser.ENCODE - 681)) | (1 << (SqlParser.ENCRYPT - 681)) | (1 << (SqlParser.ENDPOINT - 681)) | (1 << (SqlParser.ENVELOPE - 681)) | (1 << (SqlParser.EQUALS - 681)) | (1 << (SqlParser.EXP - 681)) | (1 << (SqlParser.EXPORT_SET - 681)) | (1 << (SqlParser.EXTERIORRING - 681)) | (1 << (SqlParser.EXTRACTVALUE - 681)) | (1 << (SqlParser.FIELD - 681)) | (1 << (SqlParser.FIND_IN_SET - 681)) | (1 << (SqlParser.FLOOR - 681)) | (1 << (SqlParser.FORMAT - 681)) | (1 << (SqlParser.FOUND_ROWS - 681)) | (1 << (SqlParser.FROM_BASE64 - 681)) | (1 << (SqlParser.FROM_DAYS - 681)) | (1 << (SqlParser.FROM_UNIXTIME - 681)) | (1 << (SqlParser.GEOMCOLLFROMTEXT - 681)) | (1 << (SqlParser.GEOMCOLLFROMWKB - 681)) | (1 << (SqlParser.GEOMETRYCOLLECTIONFROMTEXT - 681)) | (1 << (SqlParser.GEOMETRYCOLLECTIONFROMWKB - 681)) | (1 << (SqlParser.GEOMETRYFROMTEXT - 681)) | (1 << (SqlParser.GEOMETRYFROMWKB - 681)) | (1 << (SqlParser.GEOMETRYN - 681)) | (1 << (SqlParser.GEOMETRYTYPE - 681)) | (1 << (SqlParser.GEOMFROMTEXT - 681)) | (1 << (SqlParser.GEOMFROMWKB - 681)) | (1 << (SqlParser.GET_FORMAT - 681)) | (1 << (SqlParser.GET_LOCK - 681)) | (1 << (SqlParser.GLENGTH - 681)) | (1 << (SqlParser.GREATEST - 681)) | (1 << (SqlParser.GTID_SUBSET - 681)) | (1 << (SqlParser.GTID_SUBTRACT - 681)) | (1 << (SqlParser.HEX - 681)) | (1 << (SqlParser.IFNULL - 681)) | (1 << (SqlParser.INET6_ATON - 681)) | (1 << (SqlParser.INET6_NTOA - 681)) | (1 << (SqlParser.INET_ATON - 681)) | (1 << (SqlParser.INET_NTOA - 681)) | (1 << (SqlParser.INSTR - 681)) | (1 << (SqlParser.INTERIORRINGN - 681)) | (1 << (SqlParser.INTERSECTS - 681)) | (1 << (SqlParser.ISCLOSED - 681)) | (1 << (SqlParser.ISEMPTY - 681)) | (1 << (SqlParser.ISNULL - 681)) | (1 << (SqlParser.ISSIMPLE - 681)) | (1 << (SqlParser.IS_FREE_LOCK - 681)) | (1 << (SqlParser.IS_IPV4 - 681)) | (1 << (SqlParser.IS_IPV4_COMPAT - 681)) | (1 << (SqlParser.IS_IPV4_MAPPED - 681)) | (1 << (SqlParser.IS_IPV6 - 681)) | (1 << (SqlParser.IS_USED_LOCK - 681)))) != 0) or ((((_la - 745)) & ~0x3f) == 0 and ((1 << (_la - 745)) & ((1 << (SqlParser.LAST_INSERT_ID - 745)) | (1 << (SqlParser.LCASE - 745)) | (1 << (SqlParser.LEAST - 745)) | (1 << (SqlParser.LENGTH - 745)) | (1 << (SqlParser.LINEFROMTEXT - 745)) | (1 << (SqlParser.LINEFROMWKB - 745)) | (1 << (SqlParser.LINESTRINGFROMTEXT - 745)) | (1 << (SqlParser.LINESTRINGFROMWKB - 745)) | (1 << (SqlParser.LN - 745)) | (1 << (SqlParser.LOAD_FILE - 745)) | (1 << (SqlParser.LOCATE - 745)) | (1 << (SqlParser.LOG - 745)) | (1 << (SqlParser.LOG10 - 745)) | (1 << (SqlParser.LOG2 - 745)) | (1 << (SqlParser.LOWER - 745)) | (1 << (SqlParser.LPAD - 745)) | (1 << (SqlParser.LTRIM - 745)) | (1 << (SqlParser.MAKEDATE - 745)) | (1 << (SqlParser.MAKETIME - 745)) | (1 << (SqlParser.MAKE_SET - 745)) | (1 << (SqlParser.MASTER_POS_WAIT - 745)) | (1 << (SqlParser.MBRCONTAINS - 745)) | (1 << (SqlParser.MBRDISJOINT - 745)) | (1 << (SqlParser.MBREQUAL - 745)) | (1 << (SqlParser.MBRINTERSECTS - 745)) | (1 << (SqlParser.MBROVERLAPS - 745)) | (1 << (SqlParser.MBRTOUCHES - 745)) | (1 << (SqlParser.MBRWITHIN - 745)) | (1 << (SqlParser.MD5 - 745)) | (1 << (SqlParser.MLINEFROMTEXT - 745)) | (1 << (SqlParser.MLINEFROMWKB - 745)) | (1 << (SqlParser.MONTHNAME - 745)) | (1 << (SqlParser.MPOINTFROMTEXT - 745)) | (1 << (SqlParser.MPOINTFROMWKB - 745)) | (1 << (SqlParser.MPOLYFROMTEXT - 745)) | (1 << (SqlParser.MPOLYFROMWKB - 745)) | (1 << (SqlParser.MULTILINESTRINGFROMTEXT - 745)) | (1 << (SqlParser.MULTILINESTRINGFROMWKB - 745)) | (1 << (SqlParser.MULTIPOINTFROMTEXT - 745)) | (1 << (SqlParser.MULTIPOINTFROMWKB - 745)) | (1 << (SqlParser.MULTIPOLYGONFROMTEXT - 745)) | (1 << (SqlParser.MULTIPOLYGONFROMWKB - 745)) | (1 << (SqlParser.NAME_CONST - 745)) | (1 << (SqlParser.NULLIF - 745)) | (1 << (SqlParser.NUMGEOMETRIES - 745)) | (1 << (SqlParser.NUMINTERIORRINGS - 745)) | (1 << (SqlParser.NUMPOINTS - 745)) | (1 << (SqlParser.OCT - 745)) | (1 << (SqlParser.OCTET_LENGTH - 745)) | (1 << (SqlParser.ORD - 745)) | (1 << (SqlParser.OVERLAPS - 745)) | (1 << (SqlParser.PERIOD_ADD - 745)) | (1 << (SqlParser.PERIOD_DIFF - 745)) | (1 << (SqlParser.PI - 745)) | (1 << (SqlParser.POINTFROMTEXT - 745)) | (1 << (SqlParser.POINTFROMWKB - 745)) | (1 << (SqlParser.POINTN - 745)) | (1 << (SqlParser.POLYFROMTEXT - 745)) | (1 << (SqlParser.POLYFROMWKB - 745)) | (1 << (SqlParser.POLYGONFROMTEXT - 745)) | (1 << (SqlParser.POLYGONFROMWKB - 745)) | (1 << (SqlParser.POW - 745)) | (1 << (SqlParser.POWER - 745)) | (1 << (SqlParser.QUOTE - 745)))) != 0) or ((((_la - 809)) & ~0x3f) == 0 and ((1 << (_la - 809)) & ((1 << (SqlParser.RADIANS - 809)) | (1 << (SqlParser.RAND - 809)) | (1 << (SqlParser.RANDOM_BYTES - 809)) | (1 << (SqlParser.RELEASE_LOCK - 809)) | (1 << (SqlParser.REVERSE - 809)) | (1 << (SqlParser.ROUND - 809)) | (1 << (SqlParser.ROW_COUNT - 809)) | (1 << (SqlParser.RPAD - 809)) | (1 << (SqlParser.RTRIM - 809)) | (1 << (SqlParser.SEC_TO_TIME - 809)) | (1 << (SqlParser.SESSION_USER - 809)) | (1 << (SqlParser.SHA - 809)) | (1 << (SqlParser.SHA1 - 809)) | (1 << (SqlParser.SHA2 - 809)) | (1 << (SqlParser.SIGN - 809)) | (1 << (SqlParser.SIN - 809)) | (1 << (SqlParser.SLEEP - 809)) | (1 << (SqlParser.SOUNDEX - 809)) | (1 << (SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS - 809)) | (1 << (SqlParser.SQRT - 809)) | (1 << (SqlParser.SRID - 809)) | (1 << (SqlParser.STARTPOINT - 809)) | (1 << (SqlParser.STRCMP - 809)) | (1 << (SqlParser.STR_TO_DATE - 809)) | (1 << (SqlParser.ST_AREA - 809)) | (1 << (SqlParser.ST_ASBINARY - 809)) | (1 << (SqlParser.ST_ASTEXT - 809)) | (1 << (SqlParser.ST_ASWKB - 809)) | (1 << (SqlParser.ST_ASWKT - 809)) | (1 << (SqlParser.ST_BUFFER - 809)) | (1 << (SqlParser.ST_CENTROID - 809)) | (1 << (SqlParser.ST_CONTAINS - 809)) | (1 << (SqlParser.ST_CROSSES - 809)) | (1 << (SqlParser.ST_DIFFERENCE - 809)) | (1 << (SqlParser.ST_DIMENSION - 809)) | (1 << (SqlParser.ST_DISJOINT - 809)) | (1 << (SqlParser.ST_DISTANCE - 809)) | (1 << (SqlParser.ST_ENDPOINT - 809)) | (1 << (SqlParser.ST_ENVELOPE - 809)) | (1 << (SqlParser.ST_EQUALS - 809)) | (1 << (SqlParser.ST_EXTERIORRING - 809)) | (1 << (SqlParser.ST_GEOMCOLLFROMTEXT - 809)) | (1 << (SqlParser.ST_GEOMCOLLFROMTXT - 809)) | (1 << (SqlParser.ST_GEOMCOLLFROMWKB - 809)) | (1 << (SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT - 809)) | (1 << (SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB - 809)) | (1 << (SqlParser.ST_GEOMETRYFROMTEXT - 809)) | (1 << (SqlParser.ST_GEOMETRYFROMWKB - 809)) | (1 << (SqlParser.ST_GEOMETRYN - 809)) | (1 << (SqlParser.ST_GEOMETRYTYPE - 809)) | (1 << (SqlParser.ST_GEOMFROMTEXT - 809)) | (1 << (SqlParser.ST_GEOMFROMWKB - 809)) | (1 << (SqlParser.ST_INTERIORRINGN - 809)) | (1 << (SqlParser.ST_INTERSECTION - 809)) | (1 << (SqlParser.ST_INTERSECTS - 809)) | (1 << (SqlParser.ST_ISCLOSED - 809)) | (1 << (SqlParser.ST_ISEMPTY - 809)) | (1 << (SqlParser.ST_ISSIMPLE - 809)) | (1 << (SqlParser.ST_LINEFROMTEXT - 809)) | (1 << (SqlParser.ST_LINEFROMWKB - 809)) | (1 << (SqlParser.ST_LINESTRINGFROMTEXT - 809)) | (1 << (SqlParser.ST_LINESTRINGFROMWKB - 809)) | (1 << (SqlParser.ST_NUMGEOMETRIES - 809)) | (1 << (SqlParser.ST_NUMINTERIORRING - 809)))) != 0) or ((((_la - 873)) & ~0x3f) == 0 and ((1 << (_la - 873)) & ((1 << (SqlParser.ST_NUMINTERIORRINGS - 873)) | (1 << (SqlParser.ST_NUMPOINTS - 873)) | (1 << (SqlParser.ST_OVERLAPS - 873)) | (1 << (SqlParser.ST_POINTFROMTEXT - 873)) | (1 << (SqlParser.ST_POINTFROMWKB - 873)) | (1 << (SqlParser.ST_POINTN - 873)) | (1 << (SqlParser.ST_POLYFROMTEXT - 873)) | (1 << (SqlParser.ST_POLYFROMWKB - 873)) | (1 << (SqlParser.ST_POLYGONFROMTEXT - 873)) | (1 << (SqlParser.ST_POLYGONFROMWKB - 873)) | (1 << (SqlParser.ST_SRID - 873)) | (1 << (SqlParser.ST_STARTPOINT - 873)) | (1 << (SqlParser.ST_SYMDIFFERENCE - 873)) | (1 << (SqlParser.ST_TOUCHES - 873)) | (1 << (SqlParser.ST_UNION - 873)) | (1 << (SqlParser.ST_WITHIN - 873)) | (1 << (SqlParser.ST_X - 873)) | (1 << (SqlParser.ST_Y - 873)) | (1 << (SqlParser.SUBDATE - 873)) | (1 << (SqlParser.SUBSTRING_INDEX - 873)) | (1 << (SqlParser.SUBTIME - 873)) | (1 << (SqlParser.SYSTEM_USER - 873)) | (1 << (SqlParser.TAN - 873)) | (1 << (SqlParser.TIMEDIFF - 873)) | (1 << (SqlParser.TIMESTAMPADD - 873)) | (1 << (SqlParser.TIMESTAMPDIFF - 873)) | (1 << (SqlParser.TIME_FORMAT - 873)) | (1 << (SqlParser.TIME_TO_SEC - 873)) | (1 << (SqlParser.TOUCHES - 873)) | (1 << (SqlParser.TO_BASE64 - 873)) | (1 << (SqlParser.TO_DAYS - 873)) | (1 << (SqlParser.TO_SECONDS - 873)) | (1 << (SqlParser.UCASE - 873)) | (1 << (SqlParser.UNCOMPRESS - 873)) | (1 << (SqlParser.UNCOMPRESSED_LENGTH - 873)) | (1 << (SqlParser.UNHEX - 873)) | (1 << (SqlParser.UNIX_TIMESTAMP - 873)) | (1 << (SqlParser.UPDATEXML - 873)) | (1 << (SqlParser.UPPER - 873)) | (1 << (SqlParser.UUID - 873)) | (1 << (SqlParser.UUID_SHORT - 873)) | (1 << (SqlParser.VALIDATE_PASSWORD_STRENGTH - 873)) | (1 << (SqlParser.VERSION - 873)) | (1 << (SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 873)) | (1 << (SqlParser.WEEKDAY - 873)) | (1 << (SqlParser.WEEKOFYEAR - 873)) | (1 << (SqlParser.WEIGHT_STRING - 873)) | (1 << (SqlParser.WITHIN - 873)) | (1 << (SqlParser.YEARWEEK - 873)) | (1 << (SqlParser.Y_FUNCTION - 873)) | (1 << (SqlParser.X_FUNCTION - 873)) | (1 << (SqlParser.PLUS - 873)))) != 0) or ((((_la - 938)) & ~0x3f) == 0 and ((1 << (_la - 938)) & ((1 << (SqlParser.MINUS - 938)) | (1 << (SqlParser.EXCLAMATION_SYMBOL - 938)) | (1 << (SqlParser.BIT_NOT_OP - 938)) | (1 << (SqlParser.LR_BRACKET - 938)) | (1 << (SqlParser.ZERO_DECIMAL - 938)) | (1 << (SqlParser.ONE_DECIMAL - 938)) | (1 << (SqlParser.TWO_DECIMAL - 938)) | (1 << (SqlParser.CHARSET_REVERSE_QOUTE_STRING - 938)) | (1 << (SqlParser.STRING_LITERAL - 938)) | (1 << (SqlParser.DECIMAL_LITERAL - 938)) | (1 << (SqlParser.HEXADECIMAL_LITERAL - 938)) | (1 << (SqlParser.ID - 938)) | (1 << (SqlParser.REVERSE_QUOTE_ID - 938)) | (1 << (SqlParser.LOCAL_ID - 938)))) != 0):
                    self.state = 576
                    self.functionArgs()


                self.state = 579
                self.match(SqlParser.RR_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SpecificFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_specificFunction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PositionFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.positionString = None # StringLiteralContext
            self.positionExpression = None # ExpressionContext
            self.inString = None # StringLiteralContext
            self.inExpression = None # ExpressionContext
            self.copyFrom(ctx)

        def POSITION(self):
            return self.getToken(SqlParser.POSITION, 0)
        def IN(self):
            return self.getToken(SqlParser.IN, 0)
        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(SqlParser.StringLiteralContext,i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPositionFunctionCall" ):
                listener.enterPositionFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPositionFunctionCall" ):
                listener.exitPositionFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPositionFunctionCall" ):
                return visitor.visitPositionFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class TrimFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.positioinForm = None # Token
            self.sourceString = None # StringLiteralContext
            self.sourceExpression = None # ExpressionContext
            self.fromString = None # StringLiteralContext
            self.fromExpression = None # ExpressionContext
            self.copyFrom(ctx)

        def TRIM(self):
            return self.getToken(SqlParser.TRIM, 0)
        def FROM(self):
            return self.getToken(SqlParser.FROM, 0)
        def BOTH(self):
            return self.getToken(SqlParser.BOTH, 0)
        def LEADING(self):
            return self.getToken(SqlParser.LEADING, 0)
        def TRAILING(self):
            return self.getToken(SqlParser.TRAILING, 0)
        def stringLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.StringLiteralContext)
            else:
                return self.getTypedRuleContext(SqlParser.StringLiteralContext,i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrimFunctionCall" ):
                listener.enterTrimFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrimFunctionCall" ):
                listener.exitTrimFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrimFunctionCall" ):
                return visitor.visitTrimFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class SimpleFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CURRENT_DATE(self):
            return self.getToken(SqlParser.CURRENT_DATE, 0)
        def CURRENT_TIME(self):
            return self.getToken(SqlParser.CURRENT_TIME, 0)
        def CURRENT_TIMESTAMP(self):
            return self.getToken(SqlParser.CURRENT_TIMESTAMP, 0)
        def CURRENT_USER(self):
            return self.getToken(SqlParser.CURRENT_USER, 0)
        def LOCALTIME(self):
            return self.getToken(SqlParser.LOCALTIME, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleFunctionCall" ):
                listener.enterSimpleFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleFunctionCall" ):
                listener.exitSimpleFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleFunctionCall" ):
                return visitor.visitSimpleFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class CharFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CHAR(self):
            return self.getToken(SqlParser.CHAR, 0)
        def functionArgs(self):
            return self.getTypedRuleContext(SqlParser.FunctionArgsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharFunctionCall" ):
                listener.enterCharFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharFunctionCall" ):
                listener.exitCharFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCharFunctionCall" ):
                return visitor.visitCharFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class WeightFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.stringFormat = None # Token
            self.copyFrom(ctx)

        def WEIGHT_STRING(self):
            return self.getToken(SqlParser.WEIGHT_STRING, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(SqlParser.StringLiteralContext,0)

        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)

        def AS(self):
            return self.getToken(SqlParser.AS, 0)
        def decimalLiteral(self):
            return self.getTypedRuleContext(SqlParser.DecimalLiteralContext,0)

        def CHAR(self):
            return self.getToken(SqlParser.CHAR, 0)
        def BINARY(self):
            return self.getToken(SqlParser.BINARY, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeightFunctionCall" ):
                listener.enterWeightFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeightFunctionCall" ):
                listener.exitWeightFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWeightFunctionCall" ):
                return visitor.visitWeightFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class GetFormatFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.datetimeFormat = None # Token
            self.copyFrom(ctx)

        def GET_FORMAT(self):
            return self.getToken(SqlParser.GET_FORMAT, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(SqlParser.StringLiteralContext,0)

        def DATE(self):
            return self.getToken(SqlParser.DATE, 0)
        def TIME(self):
            return self.getToken(SqlParser.TIME, 0)
        def DATETIME(self):
            return self.getToken(SqlParser.DATETIME, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetFormatFunctionCall" ):
                listener.enterGetFormatFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetFormatFunctionCall" ):
                listener.exitGetFormatFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetFormatFunctionCall" ):
                return visitor.visitGetFormatFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class CaseFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.elseArg = None # FunctionArgContext
            self.copyFrom(ctx)

        def CASE(self):
            return self.getToken(SqlParser.CASE, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)

        def END(self):
            return self.getToken(SqlParser.END, 0)
        def caseFuncAlternative(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.CaseFuncAlternativeContext)
            else:
                return self.getTypedRuleContext(SqlParser.CaseFuncAlternativeContext,i)

        def ELSE(self):
            return self.getToken(SqlParser.ELSE, 0)
        def functionArg(self):
            return self.getTypedRuleContext(SqlParser.FunctionArgContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseFunctionCall" ):
                listener.enterCaseFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseFunctionCall" ):
                listener.exitCaseFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseFunctionCall" ):
                return visitor.visitCaseFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class ExtractFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.sourceString = None # StringLiteralContext
            self.sourceExpression = None # ExpressionContext
            self.copyFrom(ctx)

        def EXTRACT(self):
            return self.getToken(SqlParser.EXTRACT, 0)
        def intervalType(self):
            return self.getTypedRuleContext(SqlParser.IntervalTypeContext,0)

        def FROM(self):
            return self.getToken(SqlParser.FROM, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(SqlParser.StringLiteralContext,0)

        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtractFunctionCall" ):
                listener.enterExtractFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtractFunctionCall" ):
                listener.exitExtractFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtractFunctionCall" ):
                return visitor.visitExtractFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class DataTypeFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.separator = None # Token
            self.copyFrom(ctx)

        def CONVERT(self):
            return self.getToken(SqlParser.CONVERT, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)

        def convertedDataType(self):
            return self.getTypedRuleContext(SqlParser.ConvertedDataTypeContext,0)

        def CAST(self):
            return self.getToken(SqlParser.CAST, 0)
        def AS(self):
            return self.getToken(SqlParser.AS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataTypeFunctionCall" ):
                listener.enterDataTypeFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataTypeFunctionCall" ):
                listener.exitDataTypeFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataTypeFunctionCall" ):
                return visitor.visitDataTypeFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class ValuesFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def VALUES(self):
            return self.getToken(SqlParser.VALUES, 0)
        def fullColumnName(self):
            return self.getTypedRuleContext(SqlParser.FullColumnNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValuesFunctionCall" ):
                listener.enterValuesFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValuesFunctionCall" ):
                listener.exitValuesFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValuesFunctionCall" ):
                return visitor.visitValuesFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class SubstrFunctionCallContext(SpecificFunctionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.SpecificFunctionContext
            super().__init__(parser)
            self.sourceString = None # StringLiteralContext
            self.sourceExpression = None # ExpressionContext
            self.fromDecimal = None # DecimalLiteralContext
            self.fromExpression = None # ExpressionContext
            self.forDecimal = None # DecimalLiteralContext
            self.forExpression = None # ExpressionContext
            self.copyFrom(ctx)

        def FROM(self):
            return self.getToken(SqlParser.FROM, 0)
        def SUBSTR(self):
            return self.getToken(SqlParser.SUBSTR, 0)
        def SUBSTRING(self):
            return self.getToken(SqlParser.SUBSTRING, 0)
        def stringLiteral(self):
            return self.getTypedRuleContext(SqlParser.StringLiteralContext,0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionContext,i)

        def decimalLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.DecimalLiteralContext)
            else:
                return self.getTypedRuleContext(SqlParser.DecimalLiteralContext,i)

        def FOR(self):
            return self.getToken(SqlParser.FOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubstrFunctionCall" ):
                listener.enterSubstrFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubstrFunctionCall" ):
                listener.exitSubstrFunctionCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubstrFunctionCall" ):
                return visitor.visitSubstrFunctionCall(self)
            else:
                return visitor.visitChildren(self)



    def specificFunction(self):

        localctx = SqlParser.SpecificFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_specificFunction)
        self._la = 0 # Token type
        try:
            self.state = 731
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                localctx = SqlParser.SimpleFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 583
                _la = self._input.LA(1)
                if not(_la==SqlParser.CURRENT_USER or ((((_la - 228)) & ~0x3f) == 0 and ((1 << (_la - 228)) & ((1 << (SqlParser.CURRENT_DATE - 228)) | (1 << (SqlParser.CURRENT_TIME - 228)) | (1 << (SqlParser.CURRENT_TIMESTAMP - 228)) | (1 << (SqlParser.LOCALTIME - 228)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = SqlParser.DataTypeFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 584
                self.match(SqlParser.CONVERT)
                self.state = 585
                self.match(SqlParser.LR_BRACKET)
                self.state = 586
                self.expression(0)
                self.state = 587
                localctx.separator = self.match(SqlParser.COMMA)
                self.state = 588
                self.convertedDataType()
                self.state = 589
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 3:
                localctx = SqlParser.DataTypeFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 591
                self.match(SqlParser.CONVERT)
                self.state = 592
                self.match(SqlParser.LR_BRACKET)
                self.state = 593
                self.expression(0)
                self.state = 594
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 4:
                localctx = SqlParser.DataTypeFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 596
                self.match(SqlParser.CAST)
                self.state = 597
                self.match(SqlParser.LR_BRACKET)
                self.state = 598
                self.expression(0)
                self.state = 599
                self.match(SqlParser.AS)
                self.state = 600
                self.convertedDataType()
                self.state = 601
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 5:
                localctx = SqlParser.ValuesFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 603
                self.match(SqlParser.VALUES)
                self.state = 604
                self.match(SqlParser.LR_BRACKET)
                self.state = 605
                self.fullColumnName()
                self.state = 606
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 6:
                localctx = SqlParser.CaseFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 608
                self.match(SqlParser.CASE)
                self.state = 609
                self.expression(0)
                self.state = 611 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 610
                    self.caseFuncAlternative()
                    self.state = 613 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==SqlParser.WHEN):
                        break

                self.state = 617
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.ELSE:
                    self.state = 615
                    self.match(SqlParser.ELSE)
                    self.state = 616
                    localctx.elseArg = self.functionArg()


                self.state = 619
                self.match(SqlParser.END)
                pass

            elif la_ == 7:
                localctx = SqlParser.CaseFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 621
                self.match(SqlParser.CASE)
                self.state = 623 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 622
                    self.caseFuncAlternative()
                    self.state = 625 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==SqlParser.WHEN):
                        break

                self.state = 629
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.ELSE:
                    self.state = 627
                    self.match(SqlParser.ELSE)
                    self.state = 628
                    localctx.elseArg = self.functionArg()


                self.state = 631
                self.match(SqlParser.END)
                pass

            elif la_ == 8:
                localctx = SqlParser.CharFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 633
                self.match(SqlParser.CHAR)
                self.state = 634
                self.match(SqlParser.LR_BRACKET)
                self.state = 635
                self.functionArgs()
                self.state = 636
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 9:
                localctx = SqlParser.PositionFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 638
                self.match(SqlParser.POSITION)
                self.state = 639
                self.match(SqlParser.LR_BRACKET)
                self.state = 642
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                if la_ == 1:
                    self.state = 640
                    localctx.positionString = self.stringLiteral()
                    pass

                elif la_ == 2:
                    self.state = 641
                    localctx.positionExpression = self.expression(0)
                    pass


                self.state = 644
                self.match(SqlParser.IN)
                self.state = 647
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                if la_ == 1:
                    self.state = 645
                    localctx.inString = self.stringLiteral()
                    pass

                elif la_ == 2:
                    self.state = 646
                    localctx.inExpression = self.expression(0)
                    pass


                self.state = 649
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 10:
                localctx = SqlParser.SubstrFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 651
                _la = self._input.LA(1)
                if not(_la==SqlParser.SUBSTR or _la==SqlParser.SUBSTRING):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 652
                self.match(SqlParser.LR_BRACKET)
                self.state = 655
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                if la_ == 1:
                    self.state = 653
                    localctx.sourceString = self.stringLiteral()
                    pass

                elif la_ == 2:
                    self.state = 654
                    localctx.sourceExpression = self.expression(0)
                    pass


                self.state = 657
                self.match(SqlParser.FROM)
                self.state = 660
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                if la_ == 1:
                    self.state = 658
                    localctx.fromDecimal = self.decimalLiteral()
                    pass

                elif la_ == 2:
                    self.state = 659
                    localctx.fromExpression = self.expression(0)
                    pass


                self.state = 667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.FOR:
                    self.state = 662
                    self.match(SqlParser.FOR)
                    self.state = 665
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                    if la_ == 1:
                        self.state = 663
                        localctx.forDecimal = self.decimalLiteral()
                        pass

                    elif la_ == 2:
                        self.state = 664
                        localctx.forExpression = self.expression(0)
                        pass




                self.state = 669
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 11:
                localctx = SqlParser.TrimFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 671
                self.match(SqlParser.TRIM)
                self.state = 672
                self.match(SqlParser.LR_BRACKET)
                self.state = 673
                localctx.positioinForm = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlParser.BOTH or _la==SqlParser.LEADING or _la==SqlParser.TRAILING):
                    localctx.positioinForm = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 676
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
                if la_ == 1:
                    self.state = 674
                    localctx.sourceString = self.stringLiteral()

                elif la_ == 2:
                    self.state = 675
                    localctx.sourceExpression = self.expression(0)


                self.state = 678
                self.match(SqlParser.FROM)
                self.state = 681
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
                if la_ == 1:
                    self.state = 679
                    localctx.fromString = self.stringLiteral()
                    pass

                elif la_ == 2:
                    self.state = 680
                    localctx.fromExpression = self.expression(0)
                    pass


                self.state = 683
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 12:
                localctx = SqlParser.TrimFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 685
                self.match(SqlParser.TRIM)
                self.state = 686
                self.match(SqlParser.LR_BRACKET)
                self.state = 689
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
                if la_ == 1:
                    self.state = 687
                    localctx.sourceString = self.stringLiteral()
                    pass

                elif la_ == 2:
                    self.state = 688
                    localctx.sourceExpression = self.expression(0)
                    pass


                self.state = 691
                self.match(SqlParser.FROM)
                self.state = 694
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                if la_ == 1:
                    self.state = 692
                    localctx.fromString = self.stringLiteral()
                    pass

                elif la_ == 2:
                    self.state = 693
                    localctx.fromExpression = self.expression(0)
                    pass


                self.state = 696
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 13:
                localctx = SqlParser.WeightFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 698
                self.match(SqlParser.WEIGHT_STRING)
                self.state = 699
                self.match(SqlParser.LR_BRACKET)
                self.state = 702
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
                if la_ == 1:
                    self.state = 700
                    self.stringLiteral()
                    pass

                elif la_ == 2:
                    self.state = 701
                    self.expression(0)
                    pass


                self.state = 710
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.AS:
                    self.state = 704
                    self.match(SqlParser.AS)
                    self.state = 705
                    localctx.stringFormat = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==SqlParser.CHAR or _la==SqlParser.BINARY):
                        localctx.stringFormat = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 706
                    self.match(SqlParser.LR_BRACKET)
                    self.state = 707
                    self.decimalLiteral()
                    self.state = 708
                    self.match(SqlParser.RR_BRACKET)


                self.state = 712
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 14:
                localctx = SqlParser.ExtractFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 714
                self.match(SqlParser.EXTRACT)
                self.state = 715
                self.match(SqlParser.LR_BRACKET)
                self.state = 716
                self.intervalType()
                self.state = 717
                self.match(SqlParser.FROM)
                self.state = 720
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
                if la_ == 1:
                    self.state = 718
                    localctx.sourceString = self.stringLiteral()
                    pass

                elif la_ == 2:
                    self.state = 719
                    localctx.sourceExpression = self.expression(0)
                    pass


                self.state = 722
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 15:
                localctx = SqlParser.GetFormatFunctionCallContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 724
                self.match(SqlParser.GET_FORMAT)
                self.state = 725
                self.match(SqlParser.LR_BRACKET)
                self.state = 726
                localctx.datetimeFormat = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & ((1 << (SqlParser.DATE - 182)) | (1 << (SqlParser.TIME - 182)) | (1 << (SqlParser.DATETIME - 182)))) != 0)):
                    localctx.datetimeFormat = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 727
                self.match(SqlParser.COMMA)
                self.state = 728
                self.stringLiteral()
                self.state = 729
                self.match(SqlParser.RR_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CaseFuncAlternativeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # FunctionArgContext
            self.consequent = None # FunctionArgContext

        def WHEN(self):
            return self.getToken(SqlParser.WHEN, 0)

        def THEN(self):
            return self.getToken(SqlParser.THEN, 0)

        def functionArg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.FunctionArgContext)
            else:
                return self.getTypedRuleContext(SqlParser.FunctionArgContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_caseFuncAlternative

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseFuncAlternative" ):
                listener.enterCaseFuncAlternative(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseFuncAlternative" ):
                listener.exitCaseFuncAlternative(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseFuncAlternative" ):
                return visitor.visitCaseFuncAlternative(self)
            else:
                return visitor.visitChildren(self)




    def caseFuncAlternative(self):

        localctx = SqlParser.CaseFuncAlternativeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_caseFuncAlternative)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 733
            self.match(SqlParser.WHEN)
            self.state = 734
            localctx.condition = self.functionArg()
            self.state = 735
            self.match(SqlParser.THEN)
            self.state = 736
            localctx.consequent = self.functionArg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AggregateWindowedFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.aggregator = None # Token
            self.starArg = None # Token
            self.separator = None # Token

        def functionArg(self):
            return self.getTypedRuleContext(SqlParser.FunctionArgContext,0)


        def AVG(self):
            return self.getToken(SqlParser.AVG, 0)

        def MAX(self):
            return self.getToken(SqlParser.MAX, 0)

        def MIN(self):
            return self.getToken(SqlParser.MIN, 0)

        def SUM(self):
            return self.getToken(SqlParser.SUM, 0)

        def ALL(self):
            return self.getToken(SqlParser.ALL, 0)

        def DISTINCT(self):
            return self.getToken(SqlParser.DISTINCT, 0)

        def COUNT(self):
            return self.getToken(SqlParser.COUNT, 0)

        def functionArgs(self):
            return self.getTypedRuleContext(SqlParser.FunctionArgsContext,0)


        def BIT_AND(self):
            return self.getToken(SqlParser.BIT_AND, 0)

        def BIT_OR(self):
            return self.getToken(SqlParser.BIT_OR, 0)

        def BIT_XOR(self):
            return self.getToken(SqlParser.BIT_XOR, 0)

        def STD(self):
            return self.getToken(SqlParser.STD, 0)

        def STDDEV(self):
            return self.getToken(SqlParser.STDDEV, 0)

        def STDDEV_POP(self):
            return self.getToken(SqlParser.STDDEV_POP, 0)

        def STDDEV_SAMP(self):
            return self.getToken(SqlParser.STDDEV_SAMP, 0)

        def VAR_POP(self):
            return self.getToken(SqlParser.VAR_POP, 0)

        def VAR_SAMP(self):
            return self.getToken(SqlParser.VAR_SAMP, 0)

        def VARIANCE(self):
            return self.getToken(SqlParser.VARIANCE, 0)

        def GROUP_CONCAT(self):
            return self.getToken(SqlParser.GROUP_CONCAT, 0)

        def ORDER(self):
            return self.getToken(SqlParser.ORDER, 0)

        def BY(self):
            return self.getToken(SqlParser.BY, 0)

        def orderByExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.OrderByExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.OrderByExpressionContext,i)


        def SEPARATOR(self):
            return self.getToken(SqlParser.SEPARATOR, 0)

        def STRING_LITERAL(self):
            return self.getToken(SqlParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_aggregateWindowedFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregateWindowedFunction" ):
                listener.enterAggregateWindowedFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregateWindowedFunction" ):
                listener.exitAggregateWindowedFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregateWindowedFunction" ):
                return visitor.visitAggregateWindowedFunction(self)
            else:
                return visitor.visitChildren(self)




    def aggregateWindowedFunction(self):

        localctx = SqlParser.AggregateWindowedFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_aggregateWindowedFunction)
        self._la = 0 # Token type
        try:
            self.state = 794
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 738
                _la = self._input.LA(1)
                if not(((((_la - 212)) & ~0x3f) == 0 and ((1 << (_la - 212)) & ((1 << (SqlParser.AVG - 212)) | (1 << (SqlParser.MAX - 212)) | (1 << (SqlParser.MIN - 212)) | (1 << (SqlParser.SUM - 212)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 739
                self.match(SqlParser.LR_BRACKET)
                self.state = 741
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.ALL or _la==SqlParser.DISTINCT:
                    self.state = 740
                    localctx.aggregator = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==SqlParser.ALL or _la==SqlParser.DISTINCT):
                        localctx.aggregator = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 743
                self.functionArg()
                self.state = 744
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 746
                self.match(SqlParser.COUNT)
                self.state = 747
                self.match(SqlParser.LR_BRACKET)
                self.state = 753
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SqlParser.STAR]:
                    self.state = 748
                    localctx.starArg = self.match(SqlParser.STAR)
                    pass
                elif token in [SqlParser.ALL, SqlParser.CASE, SqlParser.CAST, SqlParser.CONVERT, SqlParser.CURRENT_USER, SqlParser.DATABASE, SqlParser.EXISTS, SqlParser.FALSE, SqlParser.IF, SqlParser.INSERT, SqlParser.INTERVAL, SqlParser.LEFT, SqlParser.NOT, SqlParser.NULL_LITERAL, SqlParser.REPLACE, SqlParser.RIGHT, SqlParser.TRUE, SqlParser.VALUES, SqlParser.DATE, SqlParser.TIME, SqlParser.TIMESTAMP, SqlParser.DATETIME, SqlParser.YEAR, SqlParser.CHAR, SqlParser.BINARY, SqlParser.TEXT, SqlParser.ENUM, SqlParser.SERIAL, SqlParser.AVG, SqlParser.BIT_AND, SqlParser.BIT_OR, SqlParser.BIT_XOR, SqlParser.COUNT, SqlParser.GROUP_CONCAT, SqlParser.MAX, SqlParser.MIN, SqlParser.STD, SqlParser.STDDEV, SqlParser.STDDEV_POP, SqlParser.STDDEV_SAMP, SqlParser.SUM, SqlParser.VAR_POP, SqlParser.VAR_SAMP, SqlParser.VARIANCE, SqlParser.CURRENT_DATE, SqlParser.CURRENT_TIME, SqlParser.CURRENT_TIMESTAMP, SqlParser.LOCALTIME, SqlParser.CURDATE, SqlParser.CURTIME, SqlParser.DATE_ADD, SqlParser.DATE_SUB, SqlParser.EXTRACT, SqlParser.LOCALTIMESTAMP, SqlParser.NOW, SqlParser.POSITION, SqlParser.SUBSTR, SqlParser.SUBSTRING, SqlParser.SYSDATE, SqlParser.TRIM, SqlParser.UTC_DATE, SqlParser.UTC_TIME, SqlParser.UTC_TIMESTAMP, SqlParser.ACCOUNT, SqlParser.ACTION, SqlParser.AFTER, SqlParser.AGGREGATE, SqlParser.ALGORITHM, SqlParser.ANY, SqlParser.AT, SqlParser.AUTHORS, SqlParser.AUTOCOMMIT, SqlParser.AUTOEXTEND_SIZE, SqlParser.AUTO_INCREMENT, SqlParser.AVG_ROW_LENGTH, SqlParser.BEGIN, SqlParser.BINLOG, SqlParser.BIT, SqlParser.BLOCK, SqlParser.BOOL, SqlParser.BOOLEAN, SqlParser.BTREE, SqlParser.CACHE, SqlParser.CASCADED, SqlParser.CHAIN, SqlParser.CHANGED, SqlParser.CHANNEL, SqlParser.CHECKSUM, SqlParser.CIPHER, SqlParser.CLIENT, SqlParser.CLOSE, SqlParser.COALESCE, SqlParser.CODE, SqlParser.COLUMNS, SqlParser.COLUMN_FORMAT, SqlParser.COMMENT, SqlParser.COMMIT, SqlParser.COMPACT, SqlParser.COMPLETION, SqlParser.COMPRESSED, SqlParser.COMPRESSION, SqlParser.CONCURRENT, SqlParser.CONNECTION, SqlParser.CONSISTENT, SqlParser.CONTAINS, SqlParser.CONTEXT, SqlParser.CONTRIBUTORS, SqlParser.COPY, SqlParser.CPU, SqlParser.DATA, SqlParser.DATAFILE, SqlParser.DEALLOCATE, SqlParser.DEFAULT_AUTH, SqlParser.DEFINER, SqlParser.DELAY_KEY_WRITE, SqlParser.DES_KEY_FILE, SqlParser.DIRECTORY, SqlParser.DISABLE, SqlParser.DISCARD, SqlParser.DISK, SqlParser.DO, SqlParser.DUMPFILE, SqlParser.DUPLICATE, SqlParser.DYNAMIC, SqlParser.ENABLE, SqlParser.ENCRYPTION, SqlParser.END, SqlParser.ENDS, SqlParser.ENGINE, SqlParser.ENGINES, SqlParser.ERROR, SqlParser.ERRORS, SqlParser.ESCAPE, SqlParser.EVEN, SqlParser.EVENT, SqlParser.EVENTS, SqlParser.EVERY, SqlParser.EXCHANGE, SqlParser.EXCLUSIVE, SqlParser.EXPIRE, SqlParser.EXPORT, SqlParser.EXTENDED, SqlParser.EXTENT_SIZE, SqlParser.FAST, SqlParser.FAULTS, SqlParser.FIELDS, SqlParser.FILE_BLOCK_SIZE, SqlParser.FILTER, SqlParser.FIRST, SqlParser.FIXED, SqlParser.FLUSH, SqlParser.FOLLOWS, SqlParser.FOUND, SqlParser.FULL, SqlParser.FUNCTION, SqlParser.GENERAL, SqlParser.GLOBAL, SqlParser.GRANTS, SqlParser.GROUP_REPLICATION, SqlParser.HANDLER, SqlParser.HASH, SqlParser.HELP, SqlParser.HOST, SqlParser.HOSTS, SqlParser.IDENTIFIED, SqlParser.IGNORE_SERVER_IDS, SqlParser.IMPORT, SqlParser.INDEXES, SqlParser.INITIAL_SIZE, SqlParser.INPLACE, SqlParser.INSERT_METHOD, SqlParser.INSTALL, SqlParser.INSTANCE, SqlParser.INVOKER, SqlParser.IO, SqlParser.IO_THREAD, SqlParser.IPC, SqlParser.ISOLATION, SqlParser.ISSUER, SqlParser.JSON, SqlParser.KEY_BLOCK_SIZE, SqlParser.LANGUAGE, SqlParser.LAST, SqlParser.LEAVES, SqlParser.LESS, SqlParser.LEVEL, SqlParser.LIST, SqlParser.LOCAL, SqlParser.LOGFILE, SqlParser.LOGS, SqlParser.MASTER, SqlParser.MASTER_AUTO_POSITION, SqlParser.MASTER_CONNECT_RETRY, SqlParser.MASTER_DELAY, SqlParser.MASTER_HEARTBEAT_PERIOD, SqlParser.MASTER_HOST, SqlParser.MASTER_LOG_FILE, SqlParser.MASTER_LOG_POS, SqlParser.MASTER_PASSWORD, SqlParser.MASTER_PORT, SqlParser.MASTER_RETRY_COUNT, SqlParser.MASTER_SSL, SqlParser.MASTER_SSL_CA, SqlParser.MASTER_SSL_CAPATH, SqlParser.MASTER_SSL_CERT, SqlParser.MASTER_SSL_CIPHER, SqlParser.MASTER_SSL_CRL, SqlParser.MASTER_SSL_CRLPATH, SqlParser.MASTER_SSL_KEY, SqlParser.MASTER_TLS_VERSION, SqlParser.MASTER_USER, SqlParser.MAX_CONNECTIONS_PER_HOUR, SqlParser.MAX_QUERIES_PER_HOUR, SqlParser.MAX_ROWS, SqlParser.MAX_SIZE, SqlParser.MAX_UPDATES_PER_HOUR, SqlParser.MAX_USER_CONNECTIONS, SqlParser.MEDIUM, SqlParser.MERGE, SqlParser.MID, SqlParser.MIGRATE, SqlParser.MIN_ROWS, SqlParser.MODE, SqlParser.MODIFY, SqlParser.MUTEX, SqlParser.MYSQL, SqlParser.NAME, SqlParser.NAMES, SqlParser.NCHAR, SqlParser.NEVER, SqlParser.NEXT, SqlParser.NO, SqlParser.NODEGROUP, SqlParser.NONE, SqlParser.OFFLINE, SqlParser.OFFSET, SqlParser.OJ, SqlParser.OLD_PASSWORD, SqlParser.ONE, SqlParser.ONLINE, SqlParser.ONLY, SqlParser.OPEN, SqlParser.OPTIMIZER_COSTS, SqlParser.OPTIONS, SqlParser.OWNER, SqlParser.PACK_KEYS, SqlParser.PAGE, SqlParser.PARSER, SqlParser.PARTIAL, SqlParser.PARTITIONING, SqlParser.PARTITIONS, SqlParser.PASSWORD, SqlParser.PHASE, SqlParser.PLUGIN, SqlParser.PLUGIN_DIR, SqlParser.PLUGINS, SqlParser.PORT, SqlParser.PRECEDES, SqlParser.PREPARE, SqlParser.PRESERVE, SqlParser.PREV, SqlParser.PROCESSLIST, SqlParser.PROFILE, SqlParser.PROFILES, SqlParser.PROXY, SqlParser.QUERY, SqlParser.QUICK, SqlParser.REBUILD, SqlParser.RECOVER, SqlParser.REDO_BUFFER_SIZE, SqlParser.REDUNDANT, SqlParser.RELAY, SqlParser.RELAY_LOG_FILE, SqlParser.RELAY_LOG_POS, SqlParser.RELAYLOG, SqlParser.REMOVE, SqlParser.REORGANIZE, SqlParser.REPAIR, SqlParser.REPLICATE_DO_DB, SqlParser.REPLICATE_DO_TABLE, SqlParser.REPLICATE_IGNORE_DB, SqlParser.REPLICATE_IGNORE_TABLE, SqlParser.REPLICATE_REWRITE_DB, SqlParser.REPLICATE_WILD_DO_TABLE, SqlParser.REPLICATE_WILD_IGNORE_TABLE, SqlParser.REPLICATION, SqlParser.RESET, SqlParser.RESUME, SqlParser.RETURNS, SqlParser.ROLLBACK, SqlParser.ROLLUP, SqlParser.ROTATE, SqlParser.ROW, SqlParser.ROWS, SqlParser.ROW_FORMAT, SqlParser.SAVEPOINT, SqlParser.SCHEDULE, SqlParser.SECURITY, SqlParser.SERVER, SqlParser.SESSION, SqlParser.SHARE, SqlParser.SHARED, SqlParser.SIGNED, SqlParser.SIMPLE, SqlParser.SLAVE, SqlParser.SLOW, SqlParser.SNAPSHOT, SqlParser.SOCKET, SqlParser.SOME, SqlParser.SONAME, SqlParser.SOUNDS, SqlParser.SOURCE, SqlParser.SQL_AFTER_GTIDS, SqlParser.SQL_AFTER_MTS_GAPS, SqlParser.SQL_BEFORE_GTIDS, SqlParser.SQL_BUFFER_RESULT, SqlParser.SQL_CACHE, SqlParser.SQL_NO_CACHE, SqlParser.SQL_THREAD, SqlParser.START, SqlParser.STARTS, SqlParser.STATS_AUTO_RECALC, SqlParser.STATS_PERSISTENT, SqlParser.STATS_SAMPLE_PAGES, SqlParser.STATUS, SqlParser.STOP, SqlParser.STORAGE, SqlParser.STRING, SqlParser.SUBJECT, SqlParser.SUBPARTITION, SqlParser.SUBPARTITIONS, SqlParser.SUSPEND, SqlParser.SWAPS, SqlParser.SWITCHES, SqlParser.TABLESPACE, SqlParser.TEMPORARY, SqlParser.TEMPTABLE, SqlParser.THAN, SqlParser.TRADITIONAL, SqlParser.TRANSACTION, SqlParser.TRIGGERS, SqlParser.TRUNCATE, SqlParser.UNDEFINED, SqlParser.UNDOFILE, SqlParser.UNDO_BUFFER_SIZE, SqlParser.UNINSTALL, SqlParser.UNKNOWN, SqlParser.UNTIL, SqlParser.UPGRADE, SqlParser.USER, SqlParser.USE_FRM, SqlParser.USER_RESOURCES, SqlParser.VALIDATION, SqlParser.VALUE, SqlParser.VARIABLES, SqlParser.VIEW, SqlParser.WAIT, SqlParser.WARNINGS, SqlParser.WITHOUT, SqlParser.WORK, SqlParser.WRAPPER, SqlParser.X509, SqlParser.XA, SqlParser.XML, SqlParser.QUARTER, SqlParser.MONTH, SqlParser.DAY, SqlParser.HOUR, SqlParser.MINUTE, SqlParser.WEEK, SqlParser.SECOND, SqlParser.MICROSECOND, SqlParser.ASCII, SqlParser.MEMORY, SqlParser.GEOMETRYCOLLECTION, SqlParser.LINESTRING, SqlParser.MULTILINESTRING, SqlParser.MULTIPOINT, SqlParser.MULTIPOLYGON, SqlParser.POINT, SqlParser.POLYGON, SqlParser.ABS, SqlParser.ACOS, SqlParser.ADDDATE, SqlParser.ADDTIME, SqlParser.AES_DECRYPT, SqlParser.AES_ENCRYPT, SqlParser.AREA, SqlParser.ASBINARY, SqlParser.ASIN, SqlParser.ASTEXT, SqlParser.ASWKB, SqlParser.ASWKT, SqlParser.ASYMMETRIC_DECRYPT, SqlParser.ASYMMETRIC_DERIVE, SqlParser.ASYMMETRIC_ENCRYPT, SqlParser.ASYMMETRIC_SIGN, SqlParser.ASYMMETRIC_VERIFY, SqlParser.ATAN, SqlParser.ATAN2, SqlParser.BENCHMARK, SqlParser.BIN, SqlParser.BIT_COUNT, SqlParser.BIT_LENGTH, SqlParser.BUFFER, SqlParser.CEIL, SqlParser.CEILING, SqlParser.CENTROID, SqlParser.CHARACTER_LENGTH, SqlParser.CHARSET, SqlParser.CHAR_LENGTH, SqlParser.COERCIBILITY, SqlParser.COLLATION, SqlParser.COMPRESS, SqlParser.CONCAT, SqlParser.CONCAT_WS, SqlParser.CONNECTION_ID, SqlParser.CONV, SqlParser.CONVERT_TZ, SqlParser.COS, SqlParser.COT, SqlParser.CRC32, SqlParser.CREATE_ASYMMETRIC_PRIV_KEY, SqlParser.CREATE_ASYMMETRIC_PUB_KEY, SqlParser.CREATE_DH_PARAMETERS, SqlParser.CREATE_DIGEST, SqlParser.CROSSES, SqlParser.DATEDIFF, SqlParser.DATE_FORMAT, SqlParser.DAYNAME, SqlParser.DAYOFMONTH, SqlParser.DAYOFWEEK, SqlParser.DAYOFYEAR, SqlParser.DECODE, SqlParser.DEGREES, SqlParser.DES_DECRYPT, SqlParser.DES_ENCRYPT, SqlParser.DIMENSION, SqlParser.DISJOINT, SqlParser.ELT, SqlParser.ENCODE, SqlParser.ENCRYPT, SqlParser.ENDPOINT, SqlParser.ENVELOPE, SqlParser.EQUALS, SqlParser.EXP, SqlParser.EXPORT_SET, SqlParser.EXTERIORRING, SqlParser.EXTRACTVALUE, SqlParser.FIELD, SqlParser.FIND_IN_SET, SqlParser.FLOOR, SqlParser.FORMAT, SqlParser.FOUND_ROWS, SqlParser.FROM_BASE64, SqlParser.FROM_DAYS, SqlParser.FROM_UNIXTIME, SqlParser.GEOMCOLLFROMTEXT, SqlParser.GEOMCOLLFROMWKB, SqlParser.GEOMETRYCOLLECTIONFROMTEXT, SqlParser.GEOMETRYCOLLECTIONFROMWKB, SqlParser.GEOMETRYFROMTEXT, SqlParser.GEOMETRYFROMWKB, SqlParser.GEOMETRYN, SqlParser.GEOMETRYTYPE, SqlParser.GEOMFROMTEXT, SqlParser.GEOMFROMWKB, SqlParser.GET_FORMAT, SqlParser.GET_LOCK, SqlParser.GLENGTH, SqlParser.GREATEST, SqlParser.GTID_SUBSET, SqlParser.GTID_SUBTRACT, SqlParser.HEX, SqlParser.IFNULL, SqlParser.INET6_ATON, SqlParser.INET6_NTOA, SqlParser.INET_ATON, SqlParser.INET_NTOA, SqlParser.INSTR, SqlParser.INTERIORRINGN, SqlParser.INTERSECTS, SqlParser.ISCLOSED, SqlParser.ISEMPTY, SqlParser.ISNULL, SqlParser.ISSIMPLE, SqlParser.IS_FREE_LOCK, SqlParser.IS_IPV4, SqlParser.IS_IPV4_COMPAT, SqlParser.IS_IPV4_MAPPED, SqlParser.IS_IPV6, SqlParser.IS_USED_LOCK, SqlParser.LAST_INSERT_ID, SqlParser.LCASE, SqlParser.LEAST, SqlParser.LENGTH, SqlParser.LINEFROMTEXT, SqlParser.LINEFROMWKB, SqlParser.LINESTRINGFROMTEXT, SqlParser.LINESTRINGFROMWKB, SqlParser.LN, SqlParser.LOAD_FILE, SqlParser.LOCATE, SqlParser.LOG, SqlParser.LOG10, SqlParser.LOG2, SqlParser.LOWER, SqlParser.LPAD, SqlParser.LTRIM, SqlParser.MAKEDATE, SqlParser.MAKETIME, SqlParser.MAKE_SET, SqlParser.MASTER_POS_WAIT, SqlParser.MBRCONTAINS, SqlParser.MBRDISJOINT, SqlParser.MBREQUAL, SqlParser.MBRINTERSECTS, SqlParser.MBROVERLAPS, SqlParser.MBRTOUCHES, SqlParser.MBRWITHIN, SqlParser.MD5, SqlParser.MLINEFROMTEXT, SqlParser.MLINEFROMWKB, SqlParser.MONTHNAME, SqlParser.MPOINTFROMTEXT, SqlParser.MPOINTFROMWKB, SqlParser.MPOLYFROMTEXT, SqlParser.MPOLYFROMWKB, SqlParser.MULTILINESTRINGFROMTEXT, SqlParser.MULTILINESTRINGFROMWKB, SqlParser.MULTIPOINTFROMTEXT, SqlParser.MULTIPOINTFROMWKB, SqlParser.MULTIPOLYGONFROMTEXT, SqlParser.MULTIPOLYGONFROMWKB, SqlParser.NAME_CONST, SqlParser.NULLIF, SqlParser.NUMGEOMETRIES, SqlParser.NUMINTERIORRINGS, SqlParser.NUMPOINTS, SqlParser.OCT, SqlParser.OCTET_LENGTH, SqlParser.ORD, SqlParser.OVERLAPS, SqlParser.PERIOD_ADD, SqlParser.PERIOD_DIFF, SqlParser.PI, SqlParser.POINTFROMTEXT, SqlParser.POINTFROMWKB, SqlParser.POINTN, SqlParser.POLYFROMTEXT, SqlParser.POLYFROMWKB, SqlParser.POLYGONFROMTEXT, SqlParser.POLYGONFROMWKB, SqlParser.POW, SqlParser.POWER, SqlParser.QUOTE, SqlParser.RADIANS, SqlParser.RAND, SqlParser.RANDOM_BYTES, SqlParser.RELEASE_LOCK, SqlParser.REVERSE, SqlParser.ROUND, SqlParser.ROW_COUNT, SqlParser.RPAD, SqlParser.RTRIM, SqlParser.SEC_TO_TIME, SqlParser.SESSION_USER, SqlParser.SHA, SqlParser.SHA1, SqlParser.SHA2, SqlParser.SIGN, SqlParser.SIN, SqlParser.SLEEP, SqlParser.SOUNDEX, SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, SqlParser.SQRT, SqlParser.SRID, SqlParser.STARTPOINT, SqlParser.STRCMP, SqlParser.STR_TO_DATE, SqlParser.ST_AREA, SqlParser.ST_ASBINARY, SqlParser.ST_ASTEXT, SqlParser.ST_ASWKB, SqlParser.ST_ASWKT, SqlParser.ST_BUFFER, SqlParser.ST_CENTROID, SqlParser.ST_CONTAINS, SqlParser.ST_CROSSES, SqlParser.ST_DIFFERENCE, SqlParser.ST_DIMENSION, SqlParser.ST_DISJOINT, SqlParser.ST_DISTANCE, SqlParser.ST_ENDPOINT, SqlParser.ST_ENVELOPE, SqlParser.ST_EQUALS, SqlParser.ST_EXTERIORRING, SqlParser.ST_GEOMCOLLFROMTEXT, SqlParser.ST_GEOMCOLLFROMTXT, SqlParser.ST_GEOMCOLLFROMWKB, SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, SqlParser.ST_GEOMETRYFROMTEXT, SqlParser.ST_GEOMETRYFROMWKB, SqlParser.ST_GEOMETRYN, SqlParser.ST_GEOMETRYTYPE, SqlParser.ST_GEOMFROMTEXT, SqlParser.ST_GEOMFROMWKB, SqlParser.ST_INTERIORRINGN, SqlParser.ST_INTERSECTION, SqlParser.ST_INTERSECTS, SqlParser.ST_ISCLOSED, SqlParser.ST_ISEMPTY, SqlParser.ST_ISSIMPLE, SqlParser.ST_LINEFROMTEXT, SqlParser.ST_LINEFROMWKB, SqlParser.ST_LINESTRINGFROMTEXT, SqlParser.ST_LINESTRINGFROMWKB, SqlParser.ST_NUMGEOMETRIES, SqlParser.ST_NUMINTERIORRING, SqlParser.ST_NUMINTERIORRINGS, SqlParser.ST_NUMPOINTS, SqlParser.ST_OVERLAPS, SqlParser.ST_POINTFROMTEXT, SqlParser.ST_POINTFROMWKB, SqlParser.ST_POINTN, SqlParser.ST_POLYFROMTEXT, SqlParser.ST_POLYFROMWKB, SqlParser.ST_POLYGONFROMTEXT, SqlParser.ST_POLYGONFROMWKB, SqlParser.ST_SRID, SqlParser.ST_STARTPOINT, SqlParser.ST_SYMDIFFERENCE, SqlParser.ST_TOUCHES, SqlParser.ST_UNION, SqlParser.ST_WITHIN, SqlParser.ST_X, SqlParser.ST_Y, SqlParser.SUBDATE, SqlParser.SUBSTRING_INDEX, SqlParser.SUBTIME, SqlParser.SYSTEM_USER, SqlParser.TAN, SqlParser.TIMEDIFF, SqlParser.TIMESTAMPADD, SqlParser.TIMESTAMPDIFF, SqlParser.TIME_FORMAT, SqlParser.TIME_TO_SEC, SqlParser.TOUCHES, SqlParser.TO_BASE64, SqlParser.TO_DAYS, SqlParser.TO_SECONDS, SqlParser.UCASE, SqlParser.UNCOMPRESS, SqlParser.UNCOMPRESSED_LENGTH, SqlParser.UNHEX, SqlParser.UNIX_TIMESTAMP, SqlParser.UPDATEXML, SqlParser.UPPER, SqlParser.UUID, SqlParser.UUID_SHORT, SqlParser.VALIDATE_PASSWORD_STRENGTH, SqlParser.VERSION, SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, SqlParser.WEEKDAY, SqlParser.WEEKOFYEAR, SqlParser.WEIGHT_STRING, SqlParser.WITHIN, SqlParser.YEARWEEK, SqlParser.Y_FUNCTION, SqlParser.X_FUNCTION, SqlParser.PLUS, SqlParser.MINUS, SqlParser.EXCLAMATION_SYMBOL, SqlParser.BIT_NOT_OP, SqlParser.LR_BRACKET, SqlParser.ZERO_DECIMAL, SqlParser.ONE_DECIMAL, SqlParser.TWO_DECIMAL, SqlParser.CHARSET_REVERSE_QOUTE_STRING, SqlParser.STRING_LITERAL, SqlParser.DECIMAL_LITERAL, SqlParser.HEXADECIMAL_LITERAL, SqlParser.ID, SqlParser.REVERSE_QUOTE_ID, SqlParser.LOCAL_ID]:
                    self.state = 750
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==SqlParser.ALL:
                        self.state = 749
                        localctx.aggregator = self.match(SqlParser.ALL)


                    self.state = 752
                    self.functionArg()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 755
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 756
                self.match(SqlParser.COUNT)
                self.state = 757
                self.match(SqlParser.LR_BRACKET)
                self.state = 758
                localctx.aggregator = self.match(SqlParser.DISTINCT)
                self.state = 759
                self.functionArgs()
                self.state = 760
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 762
                _la = self._input.LA(1)
                if not(((((_la - 213)) & ~0x3f) == 0 and ((1 << (_la - 213)) & ((1 << (SqlParser.BIT_AND - 213)) | (1 << (SqlParser.BIT_OR - 213)) | (1 << (SqlParser.BIT_XOR - 213)) | (1 << (SqlParser.STD - 213)) | (1 << (SqlParser.STDDEV - 213)) | (1 << (SqlParser.STDDEV_POP - 213)) | (1 << (SqlParser.STDDEV_SAMP - 213)) | (1 << (SqlParser.VAR_POP - 213)) | (1 << (SqlParser.VAR_SAMP - 213)) | (1 << (SqlParser.VARIANCE - 213)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 763
                self.match(SqlParser.LR_BRACKET)
                self.state = 765
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.ALL:
                    self.state = 764
                    localctx.aggregator = self.match(SqlParser.ALL)


                self.state = 767
                self.functionArg()
                self.state = 768
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 770
                self.match(SqlParser.GROUP_CONCAT)
                self.state = 771
                self.match(SqlParser.LR_BRACKET)
                self.state = 773
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.DISTINCT:
                    self.state = 772
                    localctx.aggregator = self.match(SqlParser.DISTINCT)


                self.state = 775
                self.functionArgs()
                self.state = 786
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.ORDER:
                    self.state = 776
                    self.match(SqlParser.ORDER)
                    self.state = 777
                    self.match(SqlParser.BY)
                    self.state = 778
                    self.orderByExpression()
                    self.state = 783
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==SqlParser.COMMA:
                        self.state = 779
                        self.match(SqlParser.COMMA)
                        self.state = 780
                        self.orderByExpression()
                        self.state = 785
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 790
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.SEPARATOR:
                    self.state = 788
                    self.match(SqlParser.SEPARATOR)
                    self.state = 789
                    localctx.separator = self.match(SqlParser.STRING_LITERAL)


                self.state = 792
                self.match(SqlParser.RR_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ScalarFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionNameBase(self):
            return self.getTypedRuleContext(SqlParser.FunctionNameBaseContext,0)


        def ASCII(self):
            return self.getToken(SqlParser.ASCII, 0)

        def CURDATE(self):
            return self.getToken(SqlParser.CURDATE, 0)

        def CURRENT_DATE(self):
            return self.getToken(SqlParser.CURRENT_DATE, 0)

        def CURRENT_TIME(self):
            return self.getToken(SqlParser.CURRENT_TIME, 0)

        def CURRENT_TIMESTAMP(self):
            return self.getToken(SqlParser.CURRENT_TIMESTAMP, 0)

        def CURTIME(self):
            return self.getToken(SqlParser.CURTIME, 0)

        def DATE_ADD(self):
            return self.getToken(SqlParser.DATE_ADD, 0)

        def DATE_SUB(self):
            return self.getToken(SqlParser.DATE_SUB, 0)

        def IF(self):
            return self.getToken(SqlParser.IF, 0)

        def INSERT(self):
            return self.getToken(SqlParser.INSERT, 0)

        def LOCALTIME(self):
            return self.getToken(SqlParser.LOCALTIME, 0)

        def LOCALTIMESTAMP(self):
            return self.getToken(SqlParser.LOCALTIMESTAMP, 0)

        def MID(self):
            return self.getToken(SqlParser.MID, 0)

        def NOW(self):
            return self.getToken(SqlParser.NOW, 0)

        def REPLACE(self):
            return self.getToken(SqlParser.REPLACE, 0)

        def SUBSTR(self):
            return self.getToken(SqlParser.SUBSTR, 0)

        def SUBSTRING(self):
            return self.getToken(SqlParser.SUBSTRING, 0)

        def SYSDATE(self):
            return self.getToken(SqlParser.SYSDATE, 0)

        def TRIM(self):
            return self.getToken(SqlParser.TRIM, 0)

        def UTC_DATE(self):
            return self.getToken(SqlParser.UTC_DATE, 0)

        def UTC_TIME(self):
            return self.getToken(SqlParser.UTC_TIME, 0)

        def UTC_TIMESTAMP(self):
            return self.getToken(SqlParser.UTC_TIMESTAMP, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_scalarFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScalarFunctionName" ):
                listener.enterScalarFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScalarFunctionName" ):
                listener.exitScalarFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScalarFunctionName" ):
                return visitor.visitScalarFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def scalarFunctionName(self):

        localctx = SqlParser.ScalarFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_scalarFunctionName)
        try:
            self.state = 819
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.DATABASE, SqlParser.LEFT, SqlParser.RIGHT, SqlParser.DATE, SqlParser.TIME, SqlParser.TIMESTAMP, SqlParser.YEAR, SqlParser.COUNT, SqlParser.POSITION, SqlParser.QUARTER, SqlParser.MONTH, SqlParser.DAY, SqlParser.HOUR, SqlParser.MINUTE, SqlParser.WEEK, SqlParser.SECOND, SqlParser.MICROSECOND, SqlParser.GEOMETRYCOLLECTION, SqlParser.LINESTRING, SqlParser.MULTILINESTRING, SqlParser.MULTIPOINT, SqlParser.MULTIPOLYGON, SqlParser.POINT, SqlParser.POLYGON, SqlParser.ABS, SqlParser.ACOS, SqlParser.ADDDATE, SqlParser.ADDTIME, SqlParser.AES_DECRYPT, SqlParser.AES_ENCRYPT, SqlParser.AREA, SqlParser.ASBINARY, SqlParser.ASIN, SqlParser.ASTEXT, SqlParser.ASWKB, SqlParser.ASWKT, SqlParser.ASYMMETRIC_DECRYPT, SqlParser.ASYMMETRIC_DERIVE, SqlParser.ASYMMETRIC_ENCRYPT, SqlParser.ASYMMETRIC_SIGN, SqlParser.ASYMMETRIC_VERIFY, SqlParser.ATAN, SqlParser.ATAN2, SqlParser.BENCHMARK, SqlParser.BIN, SqlParser.BIT_COUNT, SqlParser.BIT_LENGTH, SqlParser.BUFFER, SqlParser.CEIL, SqlParser.CEILING, SqlParser.CENTROID, SqlParser.CHARACTER_LENGTH, SqlParser.CHARSET, SqlParser.CHAR_LENGTH, SqlParser.COERCIBILITY, SqlParser.COLLATION, SqlParser.COMPRESS, SqlParser.CONCAT, SqlParser.CONCAT_WS, SqlParser.CONNECTION_ID, SqlParser.CONV, SqlParser.CONVERT_TZ, SqlParser.COS, SqlParser.COT, SqlParser.CRC32, SqlParser.CREATE_ASYMMETRIC_PRIV_KEY, SqlParser.CREATE_ASYMMETRIC_PUB_KEY, SqlParser.CREATE_DH_PARAMETERS, SqlParser.CREATE_DIGEST, SqlParser.CROSSES, SqlParser.DATEDIFF, SqlParser.DATE_FORMAT, SqlParser.DAYNAME, SqlParser.DAYOFMONTH, SqlParser.DAYOFWEEK, SqlParser.DAYOFYEAR, SqlParser.DECODE, SqlParser.DEGREES, SqlParser.DES_DECRYPT, SqlParser.DES_ENCRYPT, SqlParser.DIMENSION, SqlParser.DISJOINT, SqlParser.ELT, SqlParser.ENCODE, SqlParser.ENCRYPT, SqlParser.ENDPOINT, SqlParser.ENVELOPE, SqlParser.EQUALS, SqlParser.EXP, SqlParser.EXPORT_SET, SqlParser.EXTERIORRING, SqlParser.EXTRACTVALUE, SqlParser.FIELD, SqlParser.FIND_IN_SET, SqlParser.FLOOR, SqlParser.FORMAT, SqlParser.FOUND_ROWS, SqlParser.FROM_BASE64, SqlParser.FROM_DAYS, SqlParser.FROM_UNIXTIME, SqlParser.GEOMCOLLFROMTEXT, SqlParser.GEOMCOLLFROMWKB, SqlParser.GEOMETRYCOLLECTIONFROMTEXT, SqlParser.GEOMETRYCOLLECTIONFROMWKB, SqlParser.GEOMETRYFROMTEXT, SqlParser.GEOMETRYFROMWKB, SqlParser.GEOMETRYN, SqlParser.GEOMETRYTYPE, SqlParser.GEOMFROMTEXT, SqlParser.GEOMFROMWKB, SqlParser.GET_FORMAT, SqlParser.GET_LOCK, SqlParser.GLENGTH, SqlParser.GREATEST, SqlParser.GTID_SUBSET, SqlParser.GTID_SUBTRACT, SqlParser.HEX, SqlParser.IFNULL, SqlParser.INET6_ATON, SqlParser.INET6_NTOA, SqlParser.INET_ATON, SqlParser.INET_NTOA, SqlParser.INSTR, SqlParser.INTERIORRINGN, SqlParser.INTERSECTS, SqlParser.ISCLOSED, SqlParser.ISEMPTY, SqlParser.ISNULL, SqlParser.ISSIMPLE, SqlParser.IS_FREE_LOCK, SqlParser.IS_IPV4, SqlParser.IS_IPV4_COMPAT, SqlParser.IS_IPV4_MAPPED, SqlParser.IS_IPV6, SqlParser.IS_USED_LOCK, SqlParser.LAST_INSERT_ID, SqlParser.LCASE, SqlParser.LEAST, SqlParser.LENGTH, SqlParser.LINEFROMTEXT, SqlParser.LINEFROMWKB, SqlParser.LINESTRINGFROMTEXT, SqlParser.LINESTRINGFROMWKB, SqlParser.LN, SqlParser.LOAD_FILE, SqlParser.LOCATE, SqlParser.LOG, SqlParser.LOG10, SqlParser.LOG2, SqlParser.LOWER, SqlParser.LPAD, SqlParser.LTRIM, SqlParser.MAKEDATE, SqlParser.MAKETIME, SqlParser.MAKE_SET, SqlParser.MASTER_POS_WAIT, SqlParser.MBRCONTAINS, SqlParser.MBRDISJOINT, SqlParser.MBREQUAL, SqlParser.MBRINTERSECTS, SqlParser.MBROVERLAPS, SqlParser.MBRTOUCHES, SqlParser.MBRWITHIN, SqlParser.MD5, SqlParser.MLINEFROMTEXT, SqlParser.MLINEFROMWKB, SqlParser.MONTHNAME, SqlParser.MPOINTFROMTEXT, SqlParser.MPOINTFROMWKB, SqlParser.MPOLYFROMTEXT, SqlParser.MPOLYFROMWKB, SqlParser.MULTILINESTRINGFROMTEXT, SqlParser.MULTILINESTRINGFROMWKB, SqlParser.MULTIPOINTFROMTEXT, SqlParser.MULTIPOINTFROMWKB, SqlParser.MULTIPOLYGONFROMTEXT, SqlParser.MULTIPOLYGONFROMWKB, SqlParser.NAME_CONST, SqlParser.NULLIF, SqlParser.NUMGEOMETRIES, SqlParser.NUMINTERIORRINGS, SqlParser.NUMPOINTS, SqlParser.OCT, SqlParser.OCTET_LENGTH, SqlParser.ORD, SqlParser.OVERLAPS, SqlParser.PERIOD_ADD, SqlParser.PERIOD_DIFF, SqlParser.PI, SqlParser.POINTFROMTEXT, SqlParser.POINTFROMWKB, SqlParser.POINTN, SqlParser.POLYFROMTEXT, SqlParser.POLYFROMWKB, SqlParser.POLYGONFROMTEXT, SqlParser.POLYGONFROMWKB, SqlParser.POW, SqlParser.POWER, SqlParser.QUOTE, SqlParser.RADIANS, SqlParser.RAND, SqlParser.RANDOM_BYTES, SqlParser.RELEASE_LOCK, SqlParser.REVERSE, SqlParser.ROUND, SqlParser.ROW_COUNT, SqlParser.RPAD, SqlParser.RTRIM, SqlParser.SEC_TO_TIME, SqlParser.SESSION_USER, SqlParser.SHA, SqlParser.SHA1, SqlParser.SHA2, SqlParser.SIGN, SqlParser.SIN, SqlParser.SLEEP, SqlParser.SOUNDEX, SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, SqlParser.SQRT, SqlParser.SRID, SqlParser.STARTPOINT, SqlParser.STRCMP, SqlParser.STR_TO_DATE, SqlParser.ST_AREA, SqlParser.ST_ASBINARY, SqlParser.ST_ASTEXT, SqlParser.ST_ASWKB, SqlParser.ST_ASWKT, SqlParser.ST_BUFFER, SqlParser.ST_CENTROID, SqlParser.ST_CONTAINS, SqlParser.ST_CROSSES, SqlParser.ST_DIFFERENCE, SqlParser.ST_DIMENSION, SqlParser.ST_DISJOINT, SqlParser.ST_DISTANCE, SqlParser.ST_ENDPOINT, SqlParser.ST_ENVELOPE, SqlParser.ST_EQUALS, SqlParser.ST_EXTERIORRING, SqlParser.ST_GEOMCOLLFROMTEXT, SqlParser.ST_GEOMCOLLFROMTXT, SqlParser.ST_GEOMCOLLFROMWKB, SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, SqlParser.ST_GEOMETRYFROMTEXT, SqlParser.ST_GEOMETRYFROMWKB, SqlParser.ST_GEOMETRYN, SqlParser.ST_GEOMETRYTYPE, SqlParser.ST_GEOMFROMTEXT, SqlParser.ST_GEOMFROMWKB, SqlParser.ST_INTERIORRINGN, SqlParser.ST_INTERSECTION, SqlParser.ST_INTERSECTS, SqlParser.ST_ISCLOSED, SqlParser.ST_ISEMPTY, SqlParser.ST_ISSIMPLE, SqlParser.ST_LINEFROMTEXT, SqlParser.ST_LINEFROMWKB, SqlParser.ST_LINESTRINGFROMTEXT, SqlParser.ST_LINESTRINGFROMWKB, SqlParser.ST_NUMGEOMETRIES, SqlParser.ST_NUMINTERIORRING, SqlParser.ST_NUMINTERIORRINGS, SqlParser.ST_NUMPOINTS, SqlParser.ST_OVERLAPS, SqlParser.ST_POINTFROMTEXT, SqlParser.ST_POINTFROMWKB, SqlParser.ST_POINTN, SqlParser.ST_POLYFROMTEXT, SqlParser.ST_POLYFROMWKB, SqlParser.ST_POLYGONFROMTEXT, SqlParser.ST_POLYGONFROMWKB, SqlParser.ST_SRID, SqlParser.ST_STARTPOINT, SqlParser.ST_SYMDIFFERENCE, SqlParser.ST_TOUCHES, SqlParser.ST_UNION, SqlParser.ST_WITHIN, SqlParser.ST_X, SqlParser.ST_Y, SqlParser.SUBDATE, SqlParser.SUBSTRING_INDEX, SqlParser.SUBTIME, SqlParser.SYSTEM_USER, SqlParser.TAN, SqlParser.TIMEDIFF, SqlParser.TIMESTAMPADD, SqlParser.TIMESTAMPDIFF, SqlParser.TIME_FORMAT, SqlParser.TIME_TO_SEC, SqlParser.TOUCHES, SqlParser.TO_BASE64, SqlParser.TO_DAYS, SqlParser.TO_SECONDS, SqlParser.UCASE, SqlParser.UNCOMPRESS, SqlParser.UNCOMPRESSED_LENGTH, SqlParser.UNHEX, SqlParser.UNIX_TIMESTAMP, SqlParser.UPDATEXML, SqlParser.UPPER, SqlParser.UUID, SqlParser.UUID_SHORT, SqlParser.VALIDATE_PASSWORD_STRENGTH, SqlParser.VERSION, SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, SqlParser.WEEKDAY, SqlParser.WEEKOFYEAR, SqlParser.WEIGHT_STRING, SqlParser.WITHIN, SqlParser.YEARWEEK, SqlParser.Y_FUNCTION, SqlParser.X_FUNCTION]:
                self.enterOuterAlt(localctx, 1)
                self.state = 796
                self.functionNameBase()
                pass
            elif token in [SqlParser.ASCII]:
                self.enterOuterAlt(localctx, 2)
                self.state = 797
                self.match(SqlParser.ASCII)
                pass
            elif token in [SqlParser.CURDATE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 798
                self.match(SqlParser.CURDATE)
                pass
            elif token in [SqlParser.CURRENT_DATE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 799
                self.match(SqlParser.CURRENT_DATE)
                pass
            elif token in [SqlParser.CURRENT_TIME]:
                self.enterOuterAlt(localctx, 5)
                self.state = 800
                self.match(SqlParser.CURRENT_TIME)
                pass
            elif token in [SqlParser.CURRENT_TIMESTAMP]:
                self.enterOuterAlt(localctx, 6)
                self.state = 801
                self.match(SqlParser.CURRENT_TIMESTAMP)
                pass
            elif token in [SqlParser.CURTIME]:
                self.enterOuterAlt(localctx, 7)
                self.state = 802
                self.match(SqlParser.CURTIME)
                pass
            elif token in [SqlParser.DATE_ADD]:
                self.enterOuterAlt(localctx, 8)
                self.state = 803
                self.match(SqlParser.DATE_ADD)
                pass
            elif token in [SqlParser.DATE_SUB]:
                self.enterOuterAlt(localctx, 9)
                self.state = 804
                self.match(SqlParser.DATE_SUB)
                pass
            elif token in [SqlParser.IF]:
                self.enterOuterAlt(localctx, 10)
                self.state = 805
                self.match(SqlParser.IF)
                pass
            elif token in [SqlParser.INSERT]:
                self.enterOuterAlt(localctx, 11)
                self.state = 806
                self.match(SqlParser.INSERT)
                pass
            elif token in [SqlParser.LOCALTIME]:
                self.enterOuterAlt(localctx, 12)
                self.state = 807
                self.match(SqlParser.LOCALTIME)
                pass
            elif token in [SqlParser.LOCALTIMESTAMP]:
                self.enterOuterAlt(localctx, 13)
                self.state = 808
                self.match(SqlParser.LOCALTIMESTAMP)
                pass
            elif token in [SqlParser.MID]:
                self.enterOuterAlt(localctx, 14)
                self.state = 809
                self.match(SqlParser.MID)
                pass
            elif token in [SqlParser.NOW]:
                self.enterOuterAlt(localctx, 15)
                self.state = 810
                self.match(SqlParser.NOW)
                pass
            elif token in [SqlParser.REPLACE]:
                self.enterOuterAlt(localctx, 16)
                self.state = 811
                self.match(SqlParser.REPLACE)
                pass
            elif token in [SqlParser.SUBSTR]:
                self.enterOuterAlt(localctx, 17)
                self.state = 812
                self.match(SqlParser.SUBSTR)
                pass
            elif token in [SqlParser.SUBSTRING]:
                self.enterOuterAlt(localctx, 18)
                self.state = 813
                self.match(SqlParser.SUBSTRING)
                pass
            elif token in [SqlParser.SYSDATE]:
                self.enterOuterAlt(localctx, 19)
                self.state = 814
                self.match(SqlParser.SYSDATE)
                pass
            elif token in [SqlParser.TRIM]:
                self.enterOuterAlt(localctx, 20)
                self.state = 815
                self.match(SqlParser.TRIM)
                pass
            elif token in [SqlParser.UTC_DATE]:
                self.enterOuterAlt(localctx, 21)
                self.state = 816
                self.match(SqlParser.UTC_DATE)
                pass
            elif token in [SqlParser.UTC_TIME]:
                self.enterOuterAlt(localctx, 22)
                self.state = 817
                self.match(SqlParser.UTC_TIME)
                pass
            elif token in [SqlParser.UTC_TIMESTAMP]:
                self.enterOuterAlt(localctx, 23)
                self.state = 818
                self.match(SqlParser.UTC_TIMESTAMP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionArgsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionArg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.FunctionArgContext)
            else:
                return self.getTypedRuleContext(SqlParser.FunctionArgContext,i)


        def getRuleIndex(self):
            return SqlParser.RULE_functionArgs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionArgs" ):
                listener.enterFunctionArgs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionArgs" ):
                listener.exitFunctionArgs(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionArgs" ):
                return visitor.visitFunctionArgs(self)
            else:
                return visitor.visitChildren(self)




    def functionArgs(self):

        localctx = SqlParser.FunctionArgsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_functionArgs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 821
            self.functionArg()
            self.state = 826
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlParser.COMMA:
                self.state = 822
                self.match(SqlParser.COMMA)
                self.state = 823
                self.functionArg()
                self.state = 828
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self):
            return self.getTypedRuleContext(SqlParser.ConstantContext,0)


        def fullColumnName(self):
            return self.getTypedRuleContext(SqlParser.FullColumnNameContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(SqlParser.FunctionCallContext,0)


        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SqlParser.RULE_functionArg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionArg" ):
                listener.enterFunctionArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionArg" ):
                listener.exitFunctionArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionArg" ):
                return visitor.visitFunctionArg(self)
            else:
                return visitor.visitChildren(self)




    def functionArg(self):

        localctx = SqlParser.FunctionArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_functionArg)
        try:
            self.state = 833
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 829
                self.constant()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 830
                self.fullColumnName()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 831
                self.functionCall()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 832
                self.expression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class IsExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionContext
            super().__init__(parser)
            self.testValue = None # Token
            self.copyFrom(ctx)

        def predicate(self):
            return self.getTypedRuleContext(SqlParser.PredicateContext,0)

        def IS(self):
            return self.getToken(SqlParser.IS, 0)
        def TRUE(self):
            return self.getToken(SqlParser.TRUE, 0)
        def FALSE(self):
            return self.getToken(SqlParser.FALSE, 0)
        def UNKNOWN(self):
            return self.getToken(SqlParser.UNKNOWN, 0)
        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsExpression" ):
                listener.enterIsExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsExpression" ):
                listener.exitIsExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsExpression" ):
                return visitor.visitIsExpression(self)
            else:
                return visitor.visitChildren(self)


    class NotExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionContext
            super().__init__(parser)
            self.notOperator = None # Token
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)

        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotExpression" ):
                listener.enterNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotExpression" ):
                listener.exitNotExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotExpression" ):
                return visitor.visitNotExpression(self)
            else:
                return visitor.visitChildren(self)


    class LogicalExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionContext,i)

        def logicalOperator(self):
            return self.getTypedRuleContext(SqlParser.LogicalOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalExpression" ):
                listener.enterLogicalExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalExpression" ):
                listener.exitLogicalExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalExpression" ):
                return visitor.visitLogicalExpression(self)
            else:
                return visitor.visitChildren(self)


    class PredicateExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate(self):
            return self.getTypedRuleContext(SqlParser.PredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateExpression" ):
                listener.enterPredicateExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateExpression" ):
                listener.exitPredicateExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateExpression" ):
                return visitor.visitPredicateExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 116
        self.enterRecursionRule(localctx, 116, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 846
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
            if la_ == 1:
                localctx = SqlParser.NotExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 836
                localctx.notOperator = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlParser.NOT or _la==SqlParser.EXCLAMATION_SYMBOL):
                    localctx.notOperator = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 837
                self.expression(4)
                pass

            elif la_ == 2:
                localctx = SqlParser.IsExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 838
                self.predicate(0)
                self.state = 839
                self.match(SqlParser.IS)
                self.state = 841
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlParser.NOT:
                    self.state = 840
                    self.match(SqlParser.NOT)


                self.state = 843
                localctx.testValue = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlParser.FALSE or _la==SqlParser.TRUE or _la==SqlParser.UNKNOWN):
                    localctx.testValue = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 3:
                localctx = SqlParser.PredicateExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 845
                self.predicate(0)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 854
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,110,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = SqlParser.LogicalExpressionContext(self, SqlParser.ExpressionContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 848
                    if not self.precpred(self._ctx, 3):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                    self.state = 849
                    self.logicalOperator()
                    self.state = 850
                    self.expression(4) 
                self.state = 856
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,110,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_predicate

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class SoundsLikePredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.PredicateContext)
            else:
                return self.getTypedRuleContext(SqlParser.PredicateContext,i)

        def SOUNDS(self):
            return self.getToken(SqlParser.SOUNDS, 0)
        def LIKE(self):
            return self.getToken(SqlParser.LIKE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSoundsLikePredicate" ):
                listener.enterSoundsLikePredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSoundsLikePredicate" ):
                listener.exitSoundsLikePredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSoundsLikePredicate" ):
                return visitor.visitSoundsLikePredicate(self)
            else:
                return visitor.visitChildren(self)


    class ExpressionAtomPredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expressionAtom(self):
            return self.getTypedRuleContext(SqlParser.ExpressionAtomContext,0)

        def LOCAL_ID(self):
            return self.getToken(SqlParser.LOCAL_ID, 0)
        def VAR_ASSIGN(self):
            return self.getToken(SqlParser.VAR_ASSIGN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpressionAtomPredicate" ):
                listener.enterExpressionAtomPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpressionAtomPredicate" ):
                listener.exitExpressionAtomPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpressionAtomPredicate" ):
                return visitor.visitExpressionAtomPredicate(self)
            else:
                return visitor.visitChildren(self)


    class InPredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate(self):
            return self.getTypedRuleContext(SqlParser.PredicateContext,0)

        def IN(self):
            return self.getToken(SqlParser.IN, 0)
        def selectStatement(self):
            return self.getTypedRuleContext(SqlParser.SelectStatementContext,0)

        def expressions(self):
            return self.getTypedRuleContext(SqlParser.ExpressionsContext,0)

        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInPredicate" ):
                listener.enterInPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInPredicate" ):
                listener.exitInPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInPredicate" ):
                return visitor.visitInPredicate(self)
            else:
                return visitor.visitChildren(self)


    class SubqueryComparasionPredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.quantifier = None # Token
            self.copyFrom(ctx)

        def predicate(self):
            return self.getTypedRuleContext(SqlParser.PredicateContext,0)

        def comparisonOperator(self):
            return self.getTypedRuleContext(SqlParser.ComparisonOperatorContext,0)

        def selectStatement(self):
            return self.getTypedRuleContext(SqlParser.SelectStatementContext,0)

        def ALL(self):
            return self.getToken(SqlParser.ALL, 0)
        def ANY(self):
            return self.getToken(SqlParser.ANY, 0)
        def SOME(self):
            return self.getToken(SqlParser.SOME, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubqueryComparasionPredicate" ):
                listener.enterSubqueryComparasionPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubqueryComparasionPredicate" ):
                listener.exitSubqueryComparasionPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubqueryComparasionPredicate" ):
                return visitor.visitSubqueryComparasionPredicate(self)
            else:
                return visitor.visitChildren(self)


    class BinaryComparationPredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.left = None # PredicateContext
            self.right = None # PredicateContext
            self.copyFrom(ctx)

        def comparisonOperator(self):
            return self.getTypedRuleContext(SqlParser.ComparisonOperatorContext,0)

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.PredicateContext)
            else:
                return self.getTypedRuleContext(SqlParser.PredicateContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryComparationPredicate" ):
                listener.enterBinaryComparationPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryComparationPredicate" ):
                listener.exitBinaryComparationPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryComparationPredicate" ):
                return visitor.visitBinaryComparationPredicate(self)
            else:
                return visitor.visitChildren(self)


    class BetweenPredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.PredicateContext)
            else:
                return self.getTypedRuleContext(SqlParser.PredicateContext,i)

        def BETWEEN(self):
            return self.getToken(SqlParser.BETWEEN, 0)
        def AND(self):
            return self.getToken(SqlParser.AND, 0)
        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBetweenPredicate" ):
                listener.enterBetweenPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBetweenPredicate" ):
                listener.exitBetweenPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBetweenPredicate" ):
                return visitor.visitBetweenPredicate(self)
            else:
                return visitor.visitChildren(self)


    class IsNullPredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate(self):
            return self.getTypedRuleContext(SqlParser.PredicateContext,0)

        def IS(self):
            return self.getToken(SqlParser.IS, 0)
        def nullNotnull(self):
            return self.getTypedRuleContext(SqlParser.NullNotnullContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIsNullPredicate" ):
                listener.enterIsNullPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIsNullPredicate" ):
                listener.exitIsNullPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIsNullPredicate" ):
                return visitor.visitIsNullPredicate(self)
            else:
                return visitor.visitChildren(self)


    class LikePredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.PredicateContext)
            else:
                return self.getTypedRuleContext(SqlParser.PredicateContext,i)

        def LIKE(self):
            return self.getToken(SqlParser.LIKE, 0)
        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)
        def ESCAPE(self):
            return self.getToken(SqlParser.ESCAPE, 0)
        def STRING_LITERAL(self):
            return self.getToken(SqlParser.STRING_LITERAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLikePredicate" ):
                listener.enterLikePredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLikePredicate" ):
                listener.exitLikePredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLikePredicate" ):
                return visitor.visitLikePredicate(self)
            else:
                return visitor.visitChildren(self)


    class RegexpPredicateContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.PredicateContext
            super().__init__(parser)
            self.regex = None # Token
            self.copyFrom(ctx)

        def predicate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.PredicateContext)
            else:
                return self.getTypedRuleContext(SqlParser.PredicateContext,i)

        def REGEXP(self):
            return self.getToken(SqlParser.REGEXP, 0)
        def RLIKE(self):
            return self.getToken(SqlParser.RLIKE, 0)
        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegexpPredicate" ):
                listener.enterRegexpPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegexpPredicate" ):
                listener.exitRegexpPredicate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegexpPredicate" ):
                return visitor.visitRegexpPredicate(self)
            else:
                return visitor.visitChildren(self)



    def predicate(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlParser.PredicateContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 118
        self.enterRecursionRule(localctx, 118, self.RULE_predicate, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = SqlParser.ExpressionAtomPredicateContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 860
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlParser.LOCAL_ID:
                self.state = 858
                self.match(SqlParser.LOCAL_ID)
                self.state = 859
                self.match(SqlParser.VAR_ASSIGN)


            self.state = 862
            self.expressionAtom(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 921
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,119,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 919
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                    if la_ == 1:
                        localctx = SqlParser.BinaryComparationPredicateContext(self, SqlParser.PredicateContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_predicate)
                        self.state = 864
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 865
                        self.comparisonOperator()
                        self.state = 866
                        localctx.right = self.predicate(8)
                        pass

                    elif la_ == 2:
                        localctx = SqlParser.BetweenPredicateContext(self, SqlParser.PredicateContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_predicate)
                        self.state = 868
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 870
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlParser.NOT:
                            self.state = 869
                            self.match(SqlParser.NOT)


                        self.state = 872
                        self.match(SqlParser.BETWEEN)
                        self.state = 873
                        self.predicate(0)
                        self.state = 874
                        self.match(SqlParser.AND)
                        self.state = 875
                        self.predicate(6)
                        pass

                    elif la_ == 3:
                        localctx = SqlParser.SoundsLikePredicateContext(self, SqlParser.PredicateContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_predicate)
                        self.state = 877
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 878
                        self.match(SqlParser.SOUNDS)
                        self.state = 879
                        self.match(SqlParser.LIKE)
                        self.state = 880
                        self.predicate(5)
                        pass

                    elif la_ == 4:
                        localctx = SqlParser.RegexpPredicateContext(self, SqlParser.PredicateContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_predicate)
                        self.state = 881
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 883
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlParser.NOT:
                            self.state = 882
                            self.match(SqlParser.NOT)


                        self.state = 885
                        localctx.regex = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==SqlParser.REGEXP or _la==SqlParser.RLIKE):
                            localctx.regex = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 886
                        self.predicate(3)
                        pass

                    elif la_ == 5:
                        localctx = SqlParser.InPredicateContext(self, SqlParser.PredicateContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_predicate)
                        self.state = 887
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 889
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlParser.NOT:
                            self.state = 888
                            self.match(SqlParser.NOT)


                        self.state = 891
                        self.match(SqlParser.IN)
                        self.state = 892
                        self.match(SqlParser.LR_BRACKET)
                        self.state = 895
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
                        if la_ == 1:
                            self.state = 893
                            self.selectStatement()
                            pass

                        elif la_ == 2:
                            self.state = 894
                            self.expressions()
                            pass


                        self.state = 897
                        self.match(SqlParser.RR_BRACKET)
                        pass

                    elif la_ == 6:
                        localctx = SqlParser.IsNullPredicateContext(self, SqlParser.PredicateContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_predicate)
                        self.state = 899
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 900
                        self.match(SqlParser.IS)
                        self.state = 901
                        self.nullNotnull()
                        pass

                    elif la_ == 7:
                        localctx = SqlParser.SubqueryComparasionPredicateContext(self, SqlParser.PredicateContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_predicate)
                        self.state = 902
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 903
                        self.comparisonOperator()
                        self.state = 904
                        localctx.quantifier = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==SqlParser.ALL or _la==SqlParser.ANY or _la==SqlParser.SOME):
                            localctx.quantifier = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 905
                        self.match(SqlParser.LR_BRACKET)
                        self.state = 906
                        self.selectStatement()
                        self.state = 907
                        self.match(SqlParser.RR_BRACKET)
                        pass

                    elif la_ == 8:
                        localctx = SqlParser.LikePredicateContext(self, SqlParser.PredicateContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_predicate)
                        self.state = 909
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 911
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==SqlParser.NOT:
                            self.state = 910
                            self.match(SqlParser.NOT)


                        self.state = 913
                        self.match(SqlParser.LIKE)
                        self.state = 914
                        self.predicate(0)
                        self.state = 917
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
                        if la_ == 1:
                            self.state = 915
                            self.match(SqlParser.ESCAPE)
                            self.state = 916
                            self.match(SqlParser.STRING_LITERAL)


                        pass

             
                self.state = 923
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,119,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ExpressionAtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_expressionAtom

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class UnaryExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unaryOperator(self):
            return self.getTypedRuleContext(SqlParser.UnaryOperatorContext,0)

        def expressionAtom(self):
            return self.getTypedRuleContext(SqlParser.ExpressionAtomContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryExpressionAtom" ):
                listener.enterUnaryExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryExpressionAtom" ):
                listener.exitUnaryExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryExpressionAtom" ):
                return visitor.visitUnaryExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class SubqueryExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def selectStatement(self):
            return self.getTypedRuleContext(SqlParser.SelectStatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubqueryExpressionAtom" ):
                listener.enterSubqueryExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubqueryExpressionAtom" ):
                listener.exitSubqueryExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubqueryExpressionAtom" ):
                return visitor.visitSubqueryExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class ConstantExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def constant(self):
            return self.getTypedRuleContext(SqlParser.ConstantContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantExpressionAtom" ):
                listener.enterConstantExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantExpressionAtom" ):
                listener.exitConstantExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstantExpressionAtom" ):
                return visitor.visitConstantExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class FunctionCallExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionCall(self):
            return self.getTypedRuleContext(SqlParser.FunctionCallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCallExpressionAtom" ):
                listener.enterFunctionCallExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCallExpressionAtom" ):
                listener.exitFunctionCallExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCallExpressionAtom" ):
                return visitor.visitFunctionCallExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class BinaryExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BINARY(self):
            return self.getToken(SqlParser.BINARY, 0)
        def expressionAtom(self):
            return self.getTypedRuleContext(SqlParser.ExpressionAtomContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBinaryExpressionAtom" ):
                listener.enterBinaryExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBinaryExpressionAtom" ):
                listener.exitBinaryExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBinaryExpressionAtom" ):
                return visitor.visitBinaryExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class FullColumnNameExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fullColumnName(self):
            return self.getTypedRuleContext(SqlParser.FullColumnNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFullColumnNameExpressionAtom" ):
                listener.enterFullColumnNameExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFullColumnNameExpressionAtom" ):
                listener.exitFullColumnNameExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFullColumnNameExpressionAtom" ):
                return visitor.visitFullColumnNameExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class BitExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.left = None # ExpressionAtomContext
            self.right = None # ExpressionAtomContext
            self.copyFrom(ctx)

        def bitOperator(self):
            return self.getTypedRuleContext(SqlParser.BitOperatorContext,0)

        def expressionAtom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionAtomContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionAtomContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitExpressionAtom" ):
                listener.enterBitExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitExpressionAtom" ):
                listener.exitBitExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitExpressionAtom" ):
                return visitor.visitBitExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class NestedExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedExpressionAtom" ):
                listener.enterNestedExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedExpressionAtom" ):
                listener.exitNestedExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNestedExpressionAtom" ):
                return visitor.visitNestedExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class MathExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.left = None # ExpressionAtomContext
            self.right = None # ExpressionAtomContext
            self.copyFrom(ctx)

        def mathOperator(self):
            return self.getTypedRuleContext(SqlParser.MathOperatorContext,0)

        def expressionAtom(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlParser.ExpressionAtomContext)
            else:
                return self.getTypedRuleContext(SqlParser.ExpressionAtomContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMathExpressionAtom" ):
                listener.enterMathExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMathExpressionAtom" ):
                listener.exitMathExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMathExpressionAtom" ):
                return visitor.visitMathExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class ExistsExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXISTS(self):
            return self.getToken(SqlParser.EXISTS, 0)
        def selectStatement(self):
            return self.getTypedRuleContext(SqlParser.SelectStatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExistsExpressionAtom" ):
                listener.enterExistsExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExistsExpressionAtom" ):
                listener.exitExistsExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExistsExpressionAtom" ):
                return visitor.visitExistsExpressionAtom(self)
            else:
                return visitor.visitChildren(self)


    class IntervalExpressionAtomContext(ExpressionAtomContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlParser.ExpressionAtomContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTERVAL(self):
            return self.getToken(SqlParser.INTERVAL, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlParser.ExpressionContext,0)

        def intervalType(self):
            return self.getTypedRuleContext(SqlParser.IntervalTypeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalExpressionAtom" ):
                listener.enterIntervalExpressionAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalExpressionAtom" ):
                listener.exitIntervalExpressionAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalExpressionAtom" ):
                return visitor.visitIntervalExpressionAtom(self)
            else:
                return visitor.visitChildren(self)



    def expressionAtom(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlParser.ExpressionAtomContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 120
        self.enterRecursionRule(localctx, 120, self.RULE_expressionAtom, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 957
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                localctx = SqlParser.ConstantExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 925
                self.constant()
                pass

            elif la_ == 2:
                localctx = SqlParser.FullColumnNameExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 926
                self.fullColumnName()
                pass

            elif la_ == 3:
                localctx = SqlParser.FunctionCallExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 927
                self.functionCall()
                pass

            elif la_ == 4:
                localctx = SqlParser.UnaryExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 928
                self.unaryOperator()
                self.state = 929
                self.expressionAtom(8)
                pass

            elif la_ == 5:
                localctx = SqlParser.BinaryExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 931
                self.match(SqlParser.BINARY)
                self.state = 932
                self.expressionAtom(7)
                pass

            elif la_ == 6:
                localctx = SqlParser.NestedExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 933
                self.match(SqlParser.LR_BRACKET)
                self.state = 934
                self.expression(0)
                self.state = 939
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlParser.COMMA:
                    self.state = 935
                    self.match(SqlParser.COMMA)
                    self.state = 936
                    self.expression(0)
                    self.state = 941
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 942
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 7:
                localctx = SqlParser.ExistsExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 944
                self.match(SqlParser.EXISTS)
                self.state = 945
                self.match(SqlParser.LR_BRACKET)
                self.state = 946
                self.selectStatement()
                self.state = 947
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 8:
                localctx = SqlParser.SubqueryExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 949
                self.match(SqlParser.LR_BRACKET)
                self.state = 950
                self.selectStatement()
                self.state = 951
                self.match(SqlParser.RR_BRACKET)
                pass

            elif la_ == 9:
                localctx = SqlParser.IntervalExpressionAtomContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 953
                self.match(SqlParser.INTERVAL)
                self.state = 954
                self.expression(0)
                self.state = 955
                self.intervalType()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 969
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,123,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 967
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
                    if la_ == 1:
                        localctx = SqlParser.BitExpressionAtomContext(self, SqlParser.ExpressionAtomContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expressionAtom)
                        self.state = 959
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 960
                        self.bitOperator()
                        self.state = 961
                        localctx.right = self.expressionAtom(3)
                        pass

                    elif la_ == 2:
                        localctx = SqlParser.MathExpressionAtomContext(self, SqlParser.ExpressionAtomContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expressionAtom)
                        self.state = 963
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 964
                        self.mathOperator()
                        self.state = 965
                        localctx.right = self.expressionAtom(2)
                        pass

             
                self.state = 971
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,123,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class UnaryOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(SqlParser.NOT, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_unaryOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryOperator" ):
                listener.enterUnaryOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryOperator" ):
                listener.exitUnaryOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryOperator" ):
                return visitor.visitUnaryOperator(self)
            else:
                return visitor.visitChildren(self)




    def unaryOperator(self):

        localctx = SqlParser.UnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_unaryOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 972
            _la = self._input.LA(1)
            if not(_la==SqlParser.NOT or ((((_la - 936)) & ~0x3f) == 0 and ((1 << (_la - 936)) & ((1 << (SqlParser.PLUS - 936)) | (1 << (SqlParser.MINUS - 936)) | (1 << (SqlParser.EXCLAMATION_SYMBOL - 936)) | (1 << (SqlParser.BIT_NOT_OP - 936)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComparisonOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = SqlParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_comparisonOperator)
        try:
            self.state = 988
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 974
                self.match(SqlParser.EQUAL_SYMBOL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 975
                self.match(SqlParser.GREATER_SYMBOL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 976
                self.match(SqlParser.LESS_SYMBOL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 977
                self.match(SqlParser.LESS_SYMBOL)
                self.state = 978
                self.match(SqlParser.EQUAL_SYMBOL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 979
                self.match(SqlParser.GREATER_SYMBOL)
                self.state = 980
                self.match(SqlParser.EQUAL_SYMBOL)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 981
                self.match(SqlParser.LESS_SYMBOL)
                self.state = 982
                self.match(SqlParser.GREATER_SYMBOL)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 983
                self.match(SqlParser.EXCLAMATION_SYMBOL)
                self.state = 984
                self.match(SqlParser.EQUAL_SYMBOL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 985
                self.match(SqlParser.LESS_SYMBOL)
                self.state = 986
                self.match(SqlParser.EQUAL_SYMBOL)
                self.state = 987
                self.match(SqlParser.GREATER_SYMBOL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LogicalOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(SqlParser.AND, 0)

        def XOR(self):
            return self.getToken(SqlParser.XOR, 0)

        def OR(self):
            return self.getToken(SqlParser.OR, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_logicalOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalOperator" ):
                listener.enterLogicalOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalOperator" ):
                listener.exitLogicalOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalOperator" ):
                return visitor.visitLogicalOperator(self)
            else:
                return visitor.visitChildren(self)




    def logicalOperator(self):

        localctx = SqlParser.LogicalOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_logicalOperator)
        try:
            self.state = 997
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.AND]:
                self.enterOuterAlt(localctx, 1)
                self.state = 990
                self.match(SqlParser.AND)
                pass
            elif token in [SqlParser.BIT_AND_OP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 991
                self.match(SqlParser.BIT_AND_OP)
                self.state = 992
                self.match(SqlParser.BIT_AND_OP)
                pass
            elif token in [SqlParser.XOR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 993
                self.match(SqlParser.XOR)
                pass
            elif token in [SqlParser.OR]:
                self.enterOuterAlt(localctx, 4)
                self.state = 994
                self.match(SqlParser.OR)
                pass
            elif token in [SqlParser.BIT_OR_OP]:
                self.enterOuterAlt(localctx, 5)
                self.state = 995
                self.match(SqlParser.BIT_OR_OP)
                self.state = 996
                self.match(SqlParser.BIT_OR_OP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BitOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlParser.RULE_bitOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitOperator" ):
                listener.enterBitOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitOperator" ):
                listener.exitBitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitOperator" ):
                return visitor.visitBitOperator(self)
            else:
                return visitor.visitChildren(self)




    def bitOperator(self):

        localctx = SqlParser.BitOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_bitOperator)
        try:
            self.state = 1006
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlParser.LESS_SYMBOL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 999
                self.match(SqlParser.LESS_SYMBOL)
                self.state = 1000
                self.match(SqlParser.LESS_SYMBOL)
                pass
            elif token in [SqlParser.GREATER_SYMBOL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1001
                self.match(SqlParser.GREATER_SYMBOL)
                self.state = 1002
                self.match(SqlParser.GREATER_SYMBOL)
                pass
            elif token in [SqlParser.BIT_AND_OP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1003
                self.match(SqlParser.BIT_AND_OP)
                pass
            elif token in [SqlParser.BIT_XOR_OP]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1004
                self.match(SqlParser.BIT_XOR_OP)
                pass
            elif token in [SqlParser.BIT_OR_OP]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1005
                self.match(SqlParser.BIT_OR_OP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MathOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIV(self):
            return self.getToken(SqlParser.DIV, 0)

        def MOD(self):
            return self.getToken(SqlParser.MOD, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_mathOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMathOperator" ):
                listener.enterMathOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMathOperator" ):
                listener.exitMathOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMathOperator" ):
                return visitor.visitMathOperator(self)
            else:
                return visitor.visitChildren(self)




    def mathOperator(self):

        localctx = SqlParser.MathOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_mathOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1008
            _la = self._input.LA(1)
            if not(((((_la - 933)) & ~0x3f) == 0 and ((1 << (_la - 933)) & ((1 << (SqlParser.STAR - 933)) | (1 << (SqlParser.DIVIDE - 933)) | (1 << (SqlParser.MODULE - 933)) | (1 << (SqlParser.PLUS - 933)) | (1 << (SqlParser.MINUSMINUS - 933)) | (1 << (SqlParser.MINUS - 933)) | (1 << (SqlParser.DIV - 933)) | (1 << (SqlParser.MOD - 933)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntervalTypeBaseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUARTER(self):
            return self.getToken(SqlParser.QUARTER, 0)

        def MONTH(self):
            return self.getToken(SqlParser.MONTH, 0)

        def DAY(self):
            return self.getToken(SqlParser.DAY, 0)

        def HOUR(self):
            return self.getToken(SqlParser.HOUR, 0)

        def MINUTE(self):
            return self.getToken(SqlParser.MINUTE, 0)

        def WEEK(self):
            return self.getToken(SqlParser.WEEK, 0)

        def SECOND(self):
            return self.getToken(SqlParser.SECOND, 0)

        def MICROSECOND(self):
            return self.getToken(SqlParser.MICROSECOND, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_intervalTypeBase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalTypeBase" ):
                listener.enterIntervalTypeBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalTypeBase" ):
                listener.exitIntervalTypeBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalTypeBase" ):
                return visitor.visitIntervalTypeBase(self)
            else:
                return visitor.visitChildren(self)




    def intervalTypeBase(self):

        localctx = SqlParser.IntervalTypeBaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_intervalTypeBase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1010
            _la = self._input.LA(1)
            if not(((((_la - 555)) & ~0x3f) == 0 and ((1 << (_la - 555)) & ((1 << (SqlParser.QUARTER - 555)) | (1 << (SqlParser.MONTH - 555)) | (1 << (SqlParser.DAY - 555)) | (1 << (SqlParser.HOUR - 555)) | (1 << (SqlParser.MINUTE - 555)) | (1 << (SqlParser.WEEK - 555)) | (1 << (SqlParser.SECOND - 555)) | (1 << (SqlParser.MICROSECOND - 555)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DataTypeBaseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(SqlParser.DATE, 0)

        def TIME(self):
            return self.getToken(SqlParser.TIME, 0)

        def TIMESTAMP(self):
            return self.getToken(SqlParser.TIMESTAMP, 0)

        def DATETIME(self):
            return self.getToken(SqlParser.DATETIME, 0)

        def YEAR(self):
            return self.getToken(SqlParser.YEAR, 0)

        def ENUM(self):
            return self.getToken(SqlParser.ENUM, 0)

        def TEXT(self):
            return self.getToken(SqlParser.TEXT, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_dataTypeBase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDataTypeBase" ):
                listener.enterDataTypeBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDataTypeBase" ):
                listener.exitDataTypeBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataTypeBase" ):
                return visitor.visitDataTypeBase(self)
            else:
                return visitor.visitChildren(self)




    def dataTypeBase(self):

        localctx = SqlParser.DataTypeBaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_dataTypeBase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1012
            _la = self._input.LA(1)
            if not(((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & ((1 << (SqlParser.DATE - 182)) | (1 << (SqlParser.TIME - 182)) | (1 << (SqlParser.TIMESTAMP - 182)) | (1 << (SqlParser.DATETIME - 182)) | (1 << (SqlParser.YEAR - 182)) | (1 << (SqlParser.TEXT - 182)) | (1 << (SqlParser.ENUM - 182)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KeywordsCanBeIdContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCOUNT(self):
            return self.getToken(SqlParser.ACCOUNT, 0)

        def ACTION(self):
            return self.getToken(SqlParser.ACTION, 0)

        def AFTER(self):
            return self.getToken(SqlParser.AFTER, 0)

        def AGGREGATE(self):
            return self.getToken(SqlParser.AGGREGATE, 0)

        def ALGORITHM(self):
            return self.getToken(SqlParser.ALGORITHM, 0)

        def ANY(self):
            return self.getToken(SqlParser.ANY, 0)

        def AT(self):
            return self.getToken(SqlParser.AT, 0)

        def AUTHORS(self):
            return self.getToken(SqlParser.AUTHORS, 0)

        def AUTOCOMMIT(self):
            return self.getToken(SqlParser.AUTOCOMMIT, 0)

        def AUTOEXTEND_SIZE(self):
            return self.getToken(SqlParser.AUTOEXTEND_SIZE, 0)

        def AUTO_INCREMENT(self):
            return self.getToken(SqlParser.AUTO_INCREMENT, 0)

        def AVG_ROW_LENGTH(self):
            return self.getToken(SqlParser.AVG_ROW_LENGTH, 0)

        def BEGIN(self):
            return self.getToken(SqlParser.BEGIN, 0)

        def BINLOG(self):
            return self.getToken(SqlParser.BINLOG, 0)

        def BIT(self):
            return self.getToken(SqlParser.BIT, 0)

        def BLOCK(self):
            return self.getToken(SqlParser.BLOCK, 0)

        def BOOL(self):
            return self.getToken(SqlParser.BOOL, 0)

        def BOOLEAN(self):
            return self.getToken(SqlParser.BOOLEAN, 0)

        def BTREE(self):
            return self.getToken(SqlParser.BTREE, 0)

        def CACHE(self):
            return self.getToken(SqlParser.CACHE, 0)

        def CASCADED(self):
            return self.getToken(SqlParser.CASCADED, 0)

        def CHAIN(self):
            return self.getToken(SqlParser.CHAIN, 0)

        def CHANGED(self):
            return self.getToken(SqlParser.CHANGED, 0)

        def CHANNEL(self):
            return self.getToken(SqlParser.CHANNEL, 0)

        def CHECKSUM(self):
            return self.getToken(SqlParser.CHECKSUM, 0)

        def CIPHER(self):
            return self.getToken(SqlParser.CIPHER, 0)

        def CLIENT(self):
            return self.getToken(SqlParser.CLIENT, 0)

        def CLOSE(self):
            return self.getToken(SqlParser.CLOSE, 0)

        def COALESCE(self):
            return self.getToken(SqlParser.COALESCE, 0)

        def CODE(self):
            return self.getToken(SqlParser.CODE, 0)

        def COLUMNS(self):
            return self.getToken(SqlParser.COLUMNS, 0)

        def COLUMN_FORMAT(self):
            return self.getToken(SqlParser.COLUMN_FORMAT, 0)

        def COMMENT(self):
            return self.getToken(SqlParser.COMMENT, 0)

        def COMMIT(self):
            return self.getToken(SqlParser.COMMIT, 0)

        def COMPACT(self):
            return self.getToken(SqlParser.COMPACT, 0)

        def COMPLETION(self):
            return self.getToken(SqlParser.COMPLETION, 0)

        def COMPRESSED(self):
            return self.getToken(SqlParser.COMPRESSED, 0)

        def COMPRESSION(self):
            return self.getToken(SqlParser.COMPRESSION, 0)

        def CONCURRENT(self):
            return self.getToken(SqlParser.CONCURRENT, 0)

        def CONNECTION(self):
            return self.getToken(SqlParser.CONNECTION, 0)

        def CONSISTENT(self):
            return self.getToken(SqlParser.CONSISTENT, 0)

        def CONTAINS(self):
            return self.getToken(SqlParser.CONTAINS, 0)

        def CONTEXT(self):
            return self.getToken(SqlParser.CONTEXT, 0)

        def CONTRIBUTORS(self):
            return self.getToken(SqlParser.CONTRIBUTORS, 0)

        def COPY(self):
            return self.getToken(SqlParser.COPY, 0)

        def CPU(self):
            return self.getToken(SqlParser.CPU, 0)

        def DATA(self):
            return self.getToken(SqlParser.DATA, 0)

        def DATAFILE(self):
            return self.getToken(SqlParser.DATAFILE, 0)

        def DEALLOCATE(self):
            return self.getToken(SqlParser.DEALLOCATE, 0)

        def DEFAULT_AUTH(self):
            return self.getToken(SqlParser.DEFAULT_AUTH, 0)

        def DEFINER(self):
            return self.getToken(SqlParser.DEFINER, 0)

        def DELAY_KEY_WRITE(self):
            return self.getToken(SqlParser.DELAY_KEY_WRITE, 0)

        def DES_KEY_FILE(self):
            return self.getToken(SqlParser.DES_KEY_FILE, 0)

        def DIRECTORY(self):
            return self.getToken(SqlParser.DIRECTORY, 0)

        def DISABLE(self):
            return self.getToken(SqlParser.DISABLE, 0)

        def DISCARD(self):
            return self.getToken(SqlParser.DISCARD, 0)

        def DISK(self):
            return self.getToken(SqlParser.DISK, 0)

        def DO(self):
            return self.getToken(SqlParser.DO, 0)

        def DUMPFILE(self):
            return self.getToken(SqlParser.DUMPFILE, 0)

        def DUPLICATE(self):
            return self.getToken(SqlParser.DUPLICATE, 0)

        def DYNAMIC(self):
            return self.getToken(SqlParser.DYNAMIC, 0)

        def ENABLE(self):
            return self.getToken(SqlParser.ENABLE, 0)

        def ENCRYPTION(self):
            return self.getToken(SqlParser.ENCRYPTION, 0)

        def END(self):
            return self.getToken(SqlParser.END, 0)

        def ENDS(self):
            return self.getToken(SqlParser.ENDS, 0)

        def ENGINE(self):
            return self.getToken(SqlParser.ENGINE, 0)

        def ENGINES(self):
            return self.getToken(SqlParser.ENGINES, 0)

        def ERROR(self):
            return self.getToken(SqlParser.ERROR, 0)

        def ERRORS(self):
            return self.getToken(SqlParser.ERRORS, 0)

        def ESCAPE(self):
            return self.getToken(SqlParser.ESCAPE, 0)

        def EVEN(self):
            return self.getToken(SqlParser.EVEN, 0)

        def EVENT(self):
            return self.getToken(SqlParser.EVENT, 0)

        def EVENTS(self):
            return self.getToken(SqlParser.EVENTS, 0)

        def EVERY(self):
            return self.getToken(SqlParser.EVERY, 0)

        def EXCHANGE(self):
            return self.getToken(SqlParser.EXCHANGE, 0)

        def EXCLUSIVE(self):
            return self.getToken(SqlParser.EXCLUSIVE, 0)

        def EXPIRE(self):
            return self.getToken(SqlParser.EXPIRE, 0)

        def EXPORT(self):
            return self.getToken(SqlParser.EXPORT, 0)

        def EXTENDED(self):
            return self.getToken(SqlParser.EXTENDED, 0)

        def EXTENT_SIZE(self):
            return self.getToken(SqlParser.EXTENT_SIZE, 0)

        def FAST(self):
            return self.getToken(SqlParser.FAST, 0)

        def FAULTS(self):
            return self.getToken(SqlParser.FAULTS, 0)

        def FIELDS(self):
            return self.getToken(SqlParser.FIELDS, 0)

        def FILE_BLOCK_SIZE(self):
            return self.getToken(SqlParser.FILE_BLOCK_SIZE, 0)

        def FILTER(self):
            return self.getToken(SqlParser.FILTER, 0)

        def FIRST(self):
            return self.getToken(SqlParser.FIRST, 0)

        def FIXED(self):
            return self.getToken(SqlParser.FIXED, 0)

        def FLUSH(self):
            return self.getToken(SqlParser.FLUSH, 0)

        def FOLLOWS(self):
            return self.getToken(SqlParser.FOLLOWS, 0)

        def FOUND(self):
            return self.getToken(SqlParser.FOUND, 0)

        def FULL(self):
            return self.getToken(SqlParser.FULL, 0)

        def FUNCTION(self):
            return self.getToken(SqlParser.FUNCTION, 0)

        def GENERAL(self):
            return self.getToken(SqlParser.GENERAL, 0)

        def GLOBAL(self):
            return self.getToken(SqlParser.GLOBAL, 0)

        def GRANTS(self):
            return self.getToken(SqlParser.GRANTS, 0)

        def GROUP_REPLICATION(self):
            return self.getToken(SqlParser.GROUP_REPLICATION, 0)

        def HANDLER(self):
            return self.getToken(SqlParser.HANDLER, 0)

        def HASH(self):
            return self.getToken(SqlParser.HASH, 0)

        def HELP(self):
            return self.getToken(SqlParser.HELP, 0)

        def HOST(self):
            return self.getToken(SqlParser.HOST, 0)

        def HOSTS(self):
            return self.getToken(SqlParser.HOSTS, 0)

        def IDENTIFIED(self):
            return self.getToken(SqlParser.IDENTIFIED, 0)

        def IGNORE_SERVER_IDS(self):
            return self.getToken(SqlParser.IGNORE_SERVER_IDS, 0)

        def IMPORT(self):
            return self.getToken(SqlParser.IMPORT, 0)

        def INDEXES(self):
            return self.getToken(SqlParser.INDEXES, 0)

        def INITIAL_SIZE(self):
            return self.getToken(SqlParser.INITIAL_SIZE, 0)

        def INPLACE(self):
            return self.getToken(SqlParser.INPLACE, 0)

        def INSERT_METHOD(self):
            return self.getToken(SqlParser.INSERT_METHOD, 0)

        def INSTALL(self):
            return self.getToken(SqlParser.INSTALL, 0)

        def INSTANCE(self):
            return self.getToken(SqlParser.INSTANCE, 0)

        def INVOKER(self):
            return self.getToken(SqlParser.INVOKER, 0)

        def IO(self):
            return self.getToken(SqlParser.IO, 0)

        def IO_THREAD(self):
            return self.getToken(SqlParser.IO_THREAD, 0)

        def IPC(self):
            return self.getToken(SqlParser.IPC, 0)

        def ISOLATION(self):
            return self.getToken(SqlParser.ISOLATION, 0)

        def ISSUER(self):
            return self.getToken(SqlParser.ISSUER, 0)

        def JSON(self):
            return self.getToken(SqlParser.JSON, 0)

        def KEY_BLOCK_SIZE(self):
            return self.getToken(SqlParser.KEY_BLOCK_SIZE, 0)

        def LANGUAGE(self):
            return self.getToken(SqlParser.LANGUAGE, 0)

        def LAST(self):
            return self.getToken(SqlParser.LAST, 0)

        def LEAVES(self):
            return self.getToken(SqlParser.LEAVES, 0)

        def LESS(self):
            return self.getToken(SqlParser.LESS, 0)

        def LEVEL(self):
            return self.getToken(SqlParser.LEVEL, 0)

        def LIST(self):
            return self.getToken(SqlParser.LIST, 0)

        def LOCAL(self):
            return self.getToken(SqlParser.LOCAL, 0)

        def LOGFILE(self):
            return self.getToken(SqlParser.LOGFILE, 0)

        def LOGS(self):
            return self.getToken(SqlParser.LOGS, 0)

        def MASTER(self):
            return self.getToken(SqlParser.MASTER, 0)

        def MASTER_AUTO_POSITION(self):
            return self.getToken(SqlParser.MASTER_AUTO_POSITION, 0)

        def MASTER_CONNECT_RETRY(self):
            return self.getToken(SqlParser.MASTER_CONNECT_RETRY, 0)

        def MASTER_DELAY(self):
            return self.getToken(SqlParser.MASTER_DELAY, 0)

        def MASTER_HEARTBEAT_PERIOD(self):
            return self.getToken(SqlParser.MASTER_HEARTBEAT_PERIOD, 0)

        def MASTER_HOST(self):
            return self.getToken(SqlParser.MASTER_HOST, 0)

        def MASTER_LOG_FILE(self):
            return self.getToken(SqlParser.MASTER_LOG_FILE, 0)

        def MASTER_LOG_POS(self):
            return self.getToken(SqlParser.MASTER_LOG_POS, 0)

        def MASTER_PASSWORD(self):
            return self.getToken(SqlParser.MASTER_PASSWORD, 0)

        def MASTER_PORT(self):
            return self.getToken(SqlParser.MASTER_PORT, 0)

        def MASTER_RETRY_COUNT(self):
            return self.getToken(SqlParser.MASTER_RETRY_COUNT, 0)

        def MASTER_SSL(self):
            return self.getToken(SqlParser.MASTER_SSL, 0)

        def MASTER_SSL_CA(self):
            return self.getToken(SqlParser.MASTER_SSL_CA, 0)

        def MASTER_SSL_CAPATH(self):
            return self.getToken(SqlParser.MASTER_SSL_CAPATH, 0)

        def MASTER_SSL_CERT(self):
            return self.getToken(SqlParser.MASTER_SSL_CERT, 0)

        def MASTER_SSL_CIPHER(self):
            return self.getToken(SqlParser.MASTER_SSL_CIPHER, 0)

        def MASTER_SSL_CRL(self):
            return self.getToken(SqlParser.MASTER_SSL_CRL, 0)

        def MASTER_SSL_CRLPATH(self):
            return self.getToken(SqlParser.MASTER_SSL_CRLPATH, 0)

        def MASTER_SSL_KEY(self):
            return self.getToken(SqlParser.MASTER_SSL_KEY, 0)

        def MASTER_TLS_VERSION(self):
            return self.getToken(SqlParser.MASTER_TLS_VERSION, 0)

        def MASTER_USER(self):
            return self.getToken(SqlParser.MASTER_USER, 0)

        def MAX_CONNECTIONS_PER_HOUR(self):
            return self.getToken(SqlParser.MAX_CONNECTIONS_PER_HOUR, 0)

        def MAX_QUERIES_PER_HOUR(self):
            return self.getToken(SqlParser.MAX_QUERIES_PER_HOUR, 0)

        def MAX_ROWS(self):
            return self.getToken(SqlParser.MAX_ROWS, 0)

        def MAX_SIZE(self):
            return self.getToken(SqlParser.MAX_SIZE, 0)

        def MAX_UPDATES_PER_HOUR(self):
            return self.getToken(SqlParser.MAX_UPDATES_PER_HOUR, 0)

        def MAX_USER_CONNECTIONS(self):
            return self.getToken(SqlParser.MAX_USER_CONNECTIONS, 0)

        def MEDIUM(self):
            return self.getToken(SqlParser.MEDIUM, 0)

        def MEMORY(self):
            return self.getToken(SqlParser.MEMORY, 0)

        def MERGE(self):
            return self.getToken(SqlParser.MERGE, 0)

        def MID(self):
            return self.getToken(SqlParser.MID, 0)

        def MIGRATE(self):
            return self.getToken(SqlParser.MIGRATE, 0)

        def MIN_ROWS(self):
            return self.getToken(SqlParser.MIN_ROWS, 0)

        def MODE(self):
            return self.getToken(SqlParser.MODE, 0)

        def MODIFY(self):
            return self.getToken(SqlParser.MODIFY, 0)

        def MUTEX(self):
            return self.getToken(SqlParser.MUTEX, 0)

        def MYSQL(self):
            return self.getToken(SqlParser.MYSQL, 0)

        def NAME(self):
            return self.getToken(SqlParser.NAME, 0)

        def NAMES(self):
            return self.getToken(SqlParser.NAMES, 0)

        def NCHAR(self):
            return self.getToken(SqlParser.NCHAR, 0)

        def NEVER(self):
            return self.getToken(SqlParser.NEVER, 0)

        def NEXT(self):
            return self.getToken(SqlParser.NEXT, 0)

        def NO(self):
            return self.getToken(SqlParser.NO, 0)

        def NODEGROUP(self):
            return self.getToken(SqlParser.NODEGROUP, 0)

        def NONE(self):
            return self.getToken(SqlParser.NONE, 0)

        def OFFLINE(self):
            return self.getToken(SqlParser.OFFLINE, 0)

        def OFFSET(self):
            return self.getToken(SqlParser.OFFSET, 0)

        def OJ(self):
            return self.getToken(SqlParser.OJ, 0)

        def OLD_PASSWORD(self):
            return self.getToken(SqlParser.OLD_PASSWORD, 0)

        def ONE(self):
            return self.getToken(SqlParser.ONE, 0)

        def ONLINE(self):
            return self.getToken(SqlParser.ONLINE, 0)

        def ONLY(self):
            return self.getToken(SqlParser.ONLY, 0)

        def OPEN(self):
            return self.getToken(SqlParser.OPEN, 0)

        def OPTIMIZER_COSTS(self):
            return self.getToken(SqlParser.OPTIMIZER_COSTS, 0)

        def OPTIONS(self):
            return self.getToken(SqlParser.OPTIONS, 0)

        def OWNER(self):
            return self.getToken(SqlParser.OWNER, 0)

        def PACK_KEYS(self):
            return self.getToken(SqlParser.PACK_KEYS, 0)

        def PAGE(self):
            return self.getToken(SqlParser.PAGE, 0)

        def PARSER(self):
            return self.getToken(SqlParser.PARSER, 0)

        def PARTIAL(self):
            return self.getToken(SqlParser.PARTIAL, 0)

        def PARTITIONING(self):
            return self.getToken(SqlParser.PARTITIONING, 0)

        def PARTITIONS(self):
            return self.getToken(SqlParser.PARTITIONS, 0)

        def PASSWORD(self):
            return self.getToken(SqlParser.PASSWORD, 0)

        def PHASE(self):
            return self.getToken(SqlParser.PHASE, 0)

        def PLUGINS(self):
            return self.getToken(SqlParser.PLUGINS, 0)

        def PLUGIN_DIR(self):
            return self.getToken(SqlParser.PLUGIN_DIR, 0)

        def PLUGIN(self):
            return self.getToken(SqlParser.PLUGIN, 0)

        def PORT(self):
            return self.getToken(SqlParser.PORT, 0)

        def PRECEDES(self):
            return self.getToken(SqlParser.PRECEDES, 0)

        def PREPARE(self):
            return self.getToken(SqlParser.PREPARE, 0)

        def PRESERVE(self):
            return self.getToken(SqlParser.PRESERVE, 0)

        def PREV(self):
            return self.getToken(SqlParser.PREV, 0)

        def PROCESSLIST(self):
            return self.getToken(SqlParser.PROCESSLIST, 0)

        def PROFILE(self):
            return self.getToken(SqlParser.PROFILE, 0)

        def PROFILES(self):
            return self.getToken(SqlParser.PROFILES, 0)

        def PROXY(self):
            return self.getToken(SqlParser.PROXY, 0)

        def QUERY(self):
            return self.getToken(SqlParser.QUERY, 0)

        def QUICK(self):
            return self.getToken(SqlParser.QUICK, 0)

        def REBUILD(self):
            return self.getToken(SqlParser.REBUILD, 0)

        def RECOVER(self):
            return self.getToken(SqlParser.RECOVER, 0)

        def REDO_BUFFER_SIZE(self):
            return self.getToken(SqlParser.REDO_BUFFER_SIZE, 0)

        def REDUNDANT(self):
            return self.getToken(SqlParser.REDUNDANT, 0)

        def RELAY(self):
            return self.getToken(SqlParser.RELAY, 0)

        def RELAYLOG(self):
            return self.getToken(SqlParser.RELAYLOG, 0)

        def RELAY_LOG_FILE(self):
            return self.getToken(SqlParser.RELAY_LOG_FILE, 0)

        def RELAY_LOG_POS(self):
            return self.getToken(SqlParser.RELAY_LOG_POS, 0)

        def REMOVE(self):
            return self.getToken(SqlParser.REMOVE, 0)

        def REORGANIZE(self):
            return self.getToken(SqlParser.REORGANIZE, 0)

        def REPAIR(self):
            return self.getToken(SqlParser.REPAIR, 0)

        def REPLICATE_DO_DB(self):
            return self.getToken(SqlParser.REPLICATE_DO_DB, 0)

        def REPLICATE_DO_TABLE(self):
            return self.getToken(SqlParser.REPLICATE_DO_TABLE, 0)

        def REPLICATE_IGNORE_DB(self):
            return self.getToken(SqlParser.REPLICATE_IGNORE_DB, 0)

        def REPLICATE_IGNORE_TABLE(self):
            return self.getToken(SqlParser.REPLICATE_IGNORE_TABLE, 0)

        def REPLICATE_REWRITE_DB(self):
            return self.getToken(SqlParser.REPLICATE_REWRITE_DB, 0)

        def REPLICATE_WILD_DO_TABLE(self):
            return self.getToken(SqlParser.REPLICATE_WILD_DO_TABLE, 0)

        def REPLICATE_WILD_IGNORE_TABLE(self):
            return self.getToken(SqlParser.REPLICATE_WILD_IGNORE_TABLE, 0)

        def REPLICATION(self):
            return self.getToken(SqlParser.REPLICATION, 0)

        def RESET(self):
            return self.getToken(SqlParser.RESET, 0)

        def RESUME(self):
            return self.getToken(SqlParser.RESUME, 0)

        def RETURNS(self):
            return self.getToken(SqlParser.RETURNS, 0)

        def ROLLBACK(self):
            return self.getToken(SqlParser.ROLLBACK, 0)

        def ROLLUP(self):
            return self.getToken(SqlParser.ROLLUP, 0)

        def ROTATE(self):
            return self.getToken(SqlParser.ROTATE, 0)

        def ROW(self):
            return self.getToken(SqlParser.ROW, 0)

        def ROWS(self):
            return self.getToken(SqlParser.ROWS, 0)

        def ROW_FORMAT(self):
            return self.getToken(SqlParser.ROW_FORMAT, 0)

        def SAVEPOINT(self):
            return self.getToken(SqlParser.SAVEPOINT, 0)

        def SCHEDULE(self):
            return self.getToken(SqlParser.SCHEDULE, 0)

        def SECURITY(self):
            return self.getToken(SqlParser.SECURITY, 0)

        def SERIAL(self):
            return self.getToken(SqlParser.SERIAL, 0)

        def SERVER(self):
            return self.getToken(SqlParser.SERVER, 0)

        def SESSION(self):
            return self.getToken(SqlParser.SESSION, 0)

        def SHARE(self):
            return self.getToken(SqlParser.SHARE, 0)

        def SHARED(self):
            return self.getToken(SqlParser.SHARED, 0)

        def SIGNED(self):
            return self.getToken(SqlParser.SIGNED, 0)

        def SIMPLE(self):
            return self.getToken(SqlParser.SIMPLE, 0)

        def SLAVE(self):
            return self.getToken(SqlParser.SLAVE, 0)

        def SLOW(self):
            return self.getToken(SqlParser.SLOW, 0)

        def SNAPSHOT(self):
            return self.getToken(SqlParser.SNAPSHOT, 0)

        def SOCKET(self):
            return self.getToken(SqlParser.SOCKET, 0)

        def SOME(self):
            return self.getToken(SqlParser.SOME, 0)

        def SONAME(self):
            return self.getToken(SqlParser.SONAME, 0)

        def SOUNDS(self):
            return self.getToken(SqlParser.SOUNDS, 0)

        def SOURCE(self):
            return self.getToken(SqlParser.SOURCE, 0)

        def SQL_AFTER_GTIDS(self):
            return self.getToken(SqlParser.SQL_AFTER_GTIDS, 0)

        def SQL_AFTER_MTS_GAPS(self):
            return self.getToken(SqlParser.SQL_AFTER_MTS_GAPS, 0)

        def SQL_BEFORE_GTIDS(self):
            return self.getToken(SqlParser.SQL_BEFORE_GTIDS, 0)

        def SQL_BUFFER_RESULT(self):
            return self.getToken(SqlParser.SQL_BUFFER_RESULT, 0)

        def SQL_CACHE(self):
            return self.getToken(SqlParser.SQL_CACHE, 0)

        def SQL_NO_CACHE(self):
            return self.getToken(SqlParser.SQL_NO_CACHE, 0)

        def SQL_THREAD(self):
            return self.getToken(SqlParser.SQL_THREAD, 0)

        def START(self):
            return self.getToken(SqlParser.START, 0)

        def STARTS(self):
            return self.getToken(SqlParser.STARTS, 0)

        def STATS_AUTO_RECALC(self):
            return self.getToken(SqlParser.STATS_AUTO_RECALC, 0)

        def STATS_PERSISTENT(self):
            return self.getToken(SqlParser.STATS_PERSISTENT, 0)

        def STATS_SAMPLE_PAGES(self):
            return self.getToken(SqlParser.STATS_SAMPLE_PAGES, 0)

        def STATUS(self):
            return self.getToken(SqlParser.STATUS, 0)

        def STOP(self):
            return self.getToken(SqlParser.STOP, 0)

        def STORAGE(self):
            return self.getToken(SqlParser.STORAGE, 0)

        def STRING(self):
            return self.getToken(SqlParser.STRING, 0)

        def SUBJECT(self):
            return self.getToken(SqlParser.SUBJECT, 0)

        def SUBPARTITION(self):
            return self.getToken(SqlParser.SUBPARTITION, 0)

        def SUBPARTITIONS(self):
            return self.getToken(SqlParser.SUBPARTITIONS, 0)

        def SUSPEND(self):
            return self.getToken(SqlParser.SUSPEND, 0)

        def SWAPS(self):
            return self.getToken(SqlParser.SWAPS, 0)

        def SWITCHES(self):
            return self.getToken(SqlParser.SWITCHES, 0)

        def TABLESPACE(self):
            return self.getToken(SqlParser.TABLESPACE, 0)

        def TEMPORARY(self):
            return self.getToken(SqlParser.TEMPORARY, 0)

        def TEMPTABLE(self):
            return self.getToken(SqlParser.TEMPTABLE, 0)

        def THAN(self):
            return self.getToken(SqlParser.THAN, 0)

        def TRADITIONAL(self):
            return self.getToken(SqlParser.TRADITIONAL, 0)

        def TRANSACTION(self):
            return self.getToken(SqlParser.TRANSACTION, 0)

        def TRIGGERS(self):
            return self.getToken(SqlParser.TRIGGERS, 0)

        def TRUNCATE(self):
            return self.getToken(SqlParser.TRUNCATE, 0)

        def UNDEFINED(self):
            return self.getToken(SqlParser.UNDEFINED, 0)

        def UNDOFILE(self):
            return self.getToken(SqlParser.UNDOFILE, 0)

        def UNDO_BUFFER_SIZE(self):
            return self.getToken(SqlParser.UNDO_BUFFER_SIZE, 0)

        def UNINSTALL(self):
            return self.getToken(SqlParser.UNINSTALL, 0)

        def UNKNOWN(self):
            return self.getToken(SqlParser.UNKNOWN, 0)

        def UNTIL(self):
            return self.getToken(SqlParser.UNTIL, 0)

        def UPGRADE(self):
            return self.getToken(SqlParser.UPGRADE, 0)

        def USER(self):
            return self.getToken(SqlParser.USER, 0)

        def USE_FRM(self):
            return self.getToken(SqlParser.USE_FRM, 0)

        def USER_RESOURCES(self):
            return self.getToken(SqlParser.USER_RESOURCES, 0)

        def VALIDATION(self):
            return self.getToken(SqlParser.VALIDATION, 0)

        def VALUE(self):
            return self.getToken(SqlParser.VALUE, 0)

        def VARIABLES(self):
            return self.getToken(SqlParser.VARIABLES, 0)

        def VIEW(self):
            return self.getToken(SqlParser.VIEW, 0)

        def WAIT(self):
            return self.getToken(SqlParser.WAIT, 0)

        def WARNINGS(self):
            return self.getToken(SqlParser.WARNINGS, 0)

        def WITHOUT(self):
            return self.getToken(SqlParser.WITHOUT, 0)

        def WORK(self):
            return self.getToken(SqlParser.WORK, 0)

        def WRAPPER(self):
            return self.getToken(SqlParser.WRAPPER, 0)

        def X509(self):
            return self.getToken(SqlParser.X509, 0)

        def XA(self):
            return self.getToken(SqlParser.XA, 0)

        def XML(self):
            return self.getToken(SqlParser.XML, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_keywordsCanBeId

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeywordsCanBeId" ):
                listener.enterKeywordsCanBeId(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeywordsCanBeId" ):
                listener.exitKeywordsCanBeId(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeywordsCanBeId" ):
                return visitor.visitKeywordsCanBeId(self)
            else:
                return visitor.visitChildren(self)




    def keywordsCanBeId(self):

        localctx = SqlParser.KeywordsCanBeIdContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_keywordsCanBeId)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1014
            _la = self._input.LA(1)
            if not(((((_la - 200)) & ~0x3f) == 0 and ((1 << (_la - 200)) & ((1 << (SqlParser.SERIAL - 200)) | (1 << (SqlParser.ACCOUNT - 200)) | (1 << (SqlParser.ACTION - 200)) | (1 << (SqlParser.AFTER - 200)) | (1 << (SqlParser.AGGREGATE - 200)) | (1 << (SqlParser.ALGORITHM - 200)) | (1 << (SqlParser.ANY - 200)) | (1 << (SqlParser.AT - 200)) | (1 << (SqlParser.AUTHORS - 200)) | (1 << (SqlParser.AUTOCOMMIT - 200)) | (1 << (SqlParser.AUTOEXTEND_SIZE - 200)) | (1 << (SqlParser.AUTO_INCREMENT - 200)) | (1 << (SqlParser.AVG_ROW_LENGTH - 200)) | (1 << (SqlParser.BEGIN - 200)) | (1 << (SqlParser.BINLOG - 200)) | (1 << (SqlParser.BIT - 200)) | (1 << (SqlParser.BLOCK - 200)) | (1 << (SqlParser.BOOL - 200)))) != 0) or ((((_la - 264)) & ~0x3f) == 0 and ((1 << (_la - 264)) & ((1 << (SqlParser.BOOLEAN - 264)) | (1 << (SqlParser.BTREE - 264)) | (1 << (SqlParser.CACHE - 264)) | (1 << (SqlParser.CASCADED - 264)) | (1 << (SqlParser.CHAIN - 264)) | (1 << (SqlParser.CHANGED - 264)) | (1 << (SqlParser.CHANNEL - 264)) | (1 << (SqlParser.CHECKSUM - 264)) | (1 << (SqlParser.CIPHER - 264)) | (1 << (SqlParser.CLIENT - 264)) | (1 << (SqlParser.CLOSE - 264)) | (1 << (SqlParser.COALESCE - 264)) | (1 << (SqlParser.CODE - 264)) | (1 << (SqlParser.COLUMNS - 264)) | (1 << (SqlParser.COLUMN_FORMAT - 264)) | (1 << (SqlParser.COMMENT - 264)) | (1 << (SqlParser.COMMIT - 264)) | (1 << (SqlParser.COMPACT - 264)) | (1 << (SqlParser.COMPLETION - 264)) | (1 << (SqlParser.COMPRESSED - 264)) | (1 << (SqlParser.COMPRESSION - 264)) | (1 << (SqlParser.CONCURRENT - 264)) | (1 << (SqlParser.CONNECTION - 264)) | (1 << (SqlParser.CONSISTENT - 264)) | (1 << (SqlParser.CONTAINS - 264)) | (1 << (SqlParser.CONTEXT - 264)) | (1 << (SqlParser.CONTRIBUTORS - 264)) | (1 << (SqlParser.COPY - 264)) | (1 << (SqlParser.CPU - 264)) | (1 << (SqlParser.DATA - 264)) | (1 << (SqlParser.DATAFILE - 264)) | (1 << (SqlParser.DEALLOCATE - 264)) | (1 << (SqlParser.DEFAULT_AUTH - 264)) | (1 << (SqlParser.DEFINER - 264)) | (1 << (SqlParser.DELAY_KEY_WRITE - 264)) | (1 << (SqlParser.DES_KEY_FILE - 264)) | (1 << (SqlParser.DIRECTORY - 264)) | (1 << (SqlParser.DISABLE - 264)) | (1 << (SqlParser.DISCARD - 264)) | (1 << (SqlParser.DISK - 264)) | (1 << (SqlParser.DO - 264)) | (1 << (SqlParser.DUMPFILE - 264)) | (1 << (SqlParser.DUPLICATE - 264)) | (1 << (SqlParser.DYNAMIC - 264)) | (1 << (SqlParser.ENABLE - 264)) | (1 << (SqlParser.ENCRYPTION - 264)) | (1 << (SqlParser.END - 264)) | (1 << (SqlParser.ENDS - 264)) | (1 << (SqlParser.ENGINE - 264)) | (1 << (SqlParser.ENGINES - 264)) | (1 << (SqlParser.ERROR - 264)) | (1 << (SqlParser.ERRORS - 264)) | (1 << (SqlParser.ESCAPE - 264)) | (1 << (SqlParser.EVEN - 264)) | (1 << (SqlParser.EVENT - 264)) | (1 << (SqlParser.EVENTS - 264)) | (1 << (SqlParser.EVERY - 264)) | (1 << (SqlParser.EXCHANGE - 264)) | (1 << (SqlParser.EXCLUSIVE - 264)) | (1 << (SqlParser.EXPIRE - 264)) | (1 << (SqlParser.EXPORT - 264)) | (1 << (SqlParser.EXTENDED - 264)) | (1 << (SqlParser.EXTENT_SIZE - 264)) | (1 << (SqlParser.FAST - 264)))) != 0) or ((((_la - 328)) & ~0x3f) == 0 and ((1 << (_la - 328)) & ((1 << (SqlParser.FAULTS - 328)) | (1 << (SqlParser.FIELDS - 328)) | (1 << (SqlParser.FILE_BLOCK_SIZE - 328)) | (1 << (SqlParser.FILTER - 328)) | (1 << (SqlParser.FIRST - 328)) | (1 << (SqlParser.FIXED - 328)) | (1 << (SqlParser.FLUSH - 328)) | (1 << (SqlParser.FOLLOWS - 328)) | (1 << (SqlParser.FOUND - 328)) | (1 << (SqlParser.FULL - 328)) | (1 << (SqlParser.FUNCTION - 328)) | (1 << (SqlParser.GENERAL - 328)) | (1 << (SqlParser.GLOBAL - 328)) | (1 << (SqlParser.GRANTS - 328)) | (1 << (SqlParser.GROUP_REPLICATION - 328)) | (1 << (SqlParser.HANDLER - 328)) | (1 << (SqlParser.HASH - 328)) | (1 << (SqlParser.HELP - 328)) | (1 << (SqlParser.HOST - 328)) | (1 << (SqlParser.HOSTS - 328)) | (1 << (SqlParser.IDENTIFIED - 328)) | (1 << (SqlParser.IGNORE_SERVER_IDS - 328)) | (1 << (SqlParser.IMPORT - 328)) | (1 << (SqlParser.INDEXES - 328)) | (1 << (SqlParser.INITIAL_SIZE - 328)) | (1 << (SqlParser.INPLACE - 328)) | (1 << (SqlParser.INSERT_METHOD - 328)) | (1 << (SqlParser.INSTALL - 328)) | (1 << (SqlParser.INSTANCE - 328)) | (1 << (SqlParser.INVOKER - 328)) | (1 << (SqlParser.IO - 328)) | (1 << (SqlParser.IO_THREAD - 328)) | (1 << (SqlParser.IPC - 328)) | (1 << (SqlParser.ISOLATION - 328)) | (1 << (SqlParser.ISSUER - 328)) | (1 << (SqlParser.JSON - 328)) | (1 << (SqlParser.KEY_BLOCK_SIZE - 328)) | (1 << (SqlParser.LANGUAGE - 328)) | (1 << (SqlParser.LAST - 328)) | (1 << (SqlParser.LEAVES - 328)) | (1 << (SqlParser.LESS - 328)) | (1 << (SqlParser.LEVEL - 328)) | (1 << (SqlParser.LIST - 328)) | (1 << (SqlParser.LOCAL - 328)) | (1 << (SqlParser.LOGFILE - 328)) | (1 << (SqlParser.LOGS - 328)) | (1 << (SqlParser.MASTER - 328)) | (1 << (SqlParser.MASTER_AUTO_POSITION - 328)) | (1 << (SqlParser.MASTER_CONNECT_RETRY - 328)) | (1 << (SqlParser.MASTER_DELAY - 328)) | (1 << (SqlParser.MASTER_HEARTBEAT_PERIOD - 328)) | (1 << (SqlParser.MASTER_HOST - 328)) | (1 << (SqlParser.MASTER_LOG_FILE - 328)) | (1 << (SqlParser.MASTER_LOG_POS - 328)) | (1 << (SqlParser.MASTER_PASSWORD - 328)) | (1 << (SqlParser.MASTER_PORT - 328)) | (1 << (SqlParser.MASTER_RETRY_COUNT - 328)) | (1 << (SqlParser.MASTER_SSL - 328)) | (1 << (SqlParser.MASTER_SSL_CA - 328)) | (1 << (SqlParser.MASTER_SSL_CAPATH - 328)) | (1 << (SqlParser.MASTER_SSL_CERT - 328)) | (1 << (SqlParser.MASTER_SSL_CIPHER - 328)) | (1 << (SqlParser.MASTER_SSL_CRL - 328)) | (1 << (SqlParser.MASTER_SSL_CRLPATH - 328)))) != 0) or ((((_la - 392)) & ~0x3f) == 0 and ((1 << (_la - 392)) & ((1 << (SqlParser.MASTER_SSL_KEY - 392)) | (1 << (SqlParser.MASTER_TLS_VERSION - 392)) | (1 << (SqlParser.MASTER_USER - 392)) | (1 << (SqlParser.MAX_CONNECTIONS_PER_HOUR - 392)) | (1 << (SqlParser.MAX_QUERIES_PER_HOUR - 392)) | (1 << (SqlParser.MAX_ROWS - 392)) | (1 << (SqlParser.MAX_SIZE - 392)) | (1 << (SqlParser.MAX_UPDATES_PER_HOUR - 392)) | (1 << (SqlParser.MAX_USER_CONNECTIONS - 392)) | (1 << (SqlParser.MEDIUM - 392)) | (1 << (SqlParser.MERGE - 392)) | (1 << (SqlParser.MID - 392)) | (1 << (SqlParser.MIGRATE - 392)) | (1 << (SqlParser.MIN_ROWS - 392)) | (1 << (SqlParser.MODE - 392)) | (1 << (SqlParser.MODIFY - 392)) | (1 << (SqlParser.MUTEX - 392)) | (1 << (SqlParser.MYSQL - 392)) | (1 << (SqlParser.NAME - 392)) | (1 << (SqlParser.NAMES - 392)) | (1 << (SqlParser.NCHAR - 392)) | (1 << (SqlParser.NEVER - 392)) | (1 << (SqlParser.NEXT - 392)) | (1 << (SqlParser.NO - 392)) | (1 << (SqlParser.NODEGROUP - 392)) | (1 << (SqlParser.NONE - 392)) | (1 << (SqlParser.OFFLINE - 392)) | (1 << (SqlParser.OFFSET - 392)) | (1 << (SqlParser.OJ - 392)) | (1 << (SqlParser.OLD_PASSWORD - 392)) | (1 << (SqlParser.ONE - 392)) | (1 << (SqlParser.ONLINE - 392)) | (1 << (SqlParser.ONLY - 392)) | (1 << (SqlParser.OPEN - 392)) | (1 << (SqlParser.OPTIMIZER_COSTS - 392)) | (1 << (SqlParser.OPTIONS - 392)) | (1 << (SqlParser.OWNER - 392)) | (1 << (SqlParser.PACK_KEYS - 392)) | (1 << (SqlParser.PAGE - 392)) | (1 << (SqlParser.PARSER - 392)) | (1 << (SqlParser.PARTIAL - 392)) | (1 << (SqlParser.PARTITIONING - 392)) | (1 << (SqlParser.PARTITIONS - 392)) | (1 << (SqlParser.PASSWORD - 392)) | (1 << (SqlParser.PHASE - 392)) | (1 << (SqlParser.PLUGIN - 392)) | (1 << (SqlParser.PLUGIN_DIR - 392)) | (1 << (SqlParser.PLUGINS - 392)) | (1 << (SqlParser.PORT - 392)) | (1 << (SqlParser.PRECEDES - 392)) | (1 << (SqlParser.PREPARE - 392)) | (1 << (SqlParser.PRESERVE - 392)) | (1 << (SqlParser.PREV - 392)) | (1 << (SqlParser.PROCESSLIST - 392)) | (1 << (SqlParser.PROFILE - 392)) | (1 << (SqlParser.PROFILES - 392)) | (1 << (SqlParser.PROXY - 392)) | (1 << (SqlParser.QUERY - 392)) | (1 << (SqlParser.QUICK - 392)) | (1 << (SqlParser.REBUILD - 392)) | (1 << (SqlParser.RECOVER - 392)) | (1 << (SqlParser.REDO_BUFFER_SIZE - 392)) | (1 << (SqlParser.REDUNDANT - 392)) | (1 << (SqlParser.RELAY - 392)))) != 0) or ((((_la - 456)) & ~0x3f) == 0 and ((1 << (_la - 456)) & ((1 << (SqlParser.RELAY_LOG_FILE - 456)) | (1 << (SqlParser.RELAY_LOG_POS - 456)) | (1 << (SqlParser.RELAYLOG - 456)) | (1 << (SqlParser.REMOVE - 456)) | (1 << (SqlParser.REORGANIZE - 456)) | (1 << (SqlParser.REPAIR - 456)) | (1 << (SqlParser.REPLICATE_DO_DB - 456)) | (1 << (SqlParser.REPLICATE_DO_TABLE - 456)) | (1 << (SqlParser.REPLICATE_IGNORE_DB - 456)) | (1 << (SqlParser.REPLICATE_IGNORE_TABLE - 456)) | (1 << (SqlParser.REPLICATE_REWRITE_DB - 456)) | (1 << (SqlParser.REPLICATE_WILD_DO_TABLE - 456)) | (1 << (SqlParser.REPLICATE_WILD_IGNORE_TABLE - 456)) | (1 << (SqlParser.REPLICATION - 456)) | (1 << (SqlParser.RESET - 456)) | (1 << (SqlParser.RESUME - 456)) | (1 << (SqlParser.RETURNS - 456)) | (1 << (SqlParser.ROLLBACK - 456)) | (1 << (SqlParser.ROLLUP - 456)) | (1 << (SqlParser.ROTATE - 456)) | (1 << (SqlParser.ROW - 456)) | (1 << (SqlParser.ROWS - 456)) | (1 << (SqlParser.ROW_FORMAT - 456)) | (1 << (SqlParser.SAVEPOINT - 456)) | (1 << (SqlParser.SCHEDULE - 456)) | (1 << (SqlParser.SECURITY - 456)) | (1 << (SqlParser.SERVER - 456)) | (1 << (SqlParser.SESSION - 456)) | (1 << (SqlParser.SHARE - 456)) | (1 << (SqlParser.SHARED - 456)) | (1 << (SqlParser.SIGNED - 456)) | (1 << (SqlParser.SIMPLE - 456)) | (1 << (SqlParser.SLAVE - 456)) | (1 << (SqlParser.SLOW - 456)) | (1 << (SqlParser.SNAPSHOT - 456)) | (1 << (SqlParser.SOCKET - 456)) | (1 << (SqlParser.SOME - 456)) | (1 << (SqlParser.SONAME - 456)) | (1 << (SqlParser.SOUNDS - 456)) | (1 << (SqlParser.SOURCE - 456)) | (1 << (SqlParser.SQL_AFTER_GTIDS - 456)) | (1 << (SqlParser.SQL_AFTER_MTS_GAPS - 456)) | (1 << (SqlParser.SQL_BEFORE_GTIDS - 456)) | (1 << (SqlParser.SQL_BUFFER_RESULT - 456)) | (1 << (SqlParser.SQL_CACHE - 456)) | (1 << (SqlParser.SQL_NO_CACHE - 456)) | (1 << (SqlParser.SQL_THREAD - 456)) | (1 << (SqlParser.START - 456)) | (1 << (SqlParser.STARTS - 456)) | (1 << (SqlParser.STATS_AUTO_RECALC - 456)) | (1 << (SqlParser.STATS_PERSISTENT - 456)) | (1 << (SqlParser.STATS_SAMPLE_PAGES - 456)) | (1 << (SqlParser.STATUS - 456)) | (1 << (SqlParser.STOP - 456)) | (1 << (SqlParser.STORAGE - 456)) | (1 << (SqlParser.STRING - 456)) | (1 << (SqlParser.SUBJECT - 456)) | (1 << (SqlParser.SUBPARTITION - 456)) | (1 << (SqlParser.SUBPARTITIONS - 456)) | (1 << (SqlParser.SUSPEND - 456)) | (1 << (SqlParser.SWAPS - 456)) | (1 << (SqlParser.SWITCHES - 456)) | (1 << (SqlParser.TABLESPACE - 456)))) != 0) or ((((_la - 520)) & ~0x3f) == 0 and ((1 << (_la - 520)) & ((1 << (SqlParser.TEMPORARY - 520)) | (1 << (SqlParser.TEMPTABLE - 520)) | (1 << (SqlParser.THAN - 520)) | (1 << (SqlParser.TRADITIONAL - 520)) | (1 << (SqlParser.TRANSACTION - 520)) | (1 << (SqlParser.TRIGGERS - 520)) | (1 << (SqlParser.TRUNCATE - 520)) | (1 << (SqlParser.UNDEFINED - 520)) | (1 << (SqlParser.UNDOFILE - 520)) | (1 << (SqlParser.UNDO_BUFFER_SIZE - 520)) | (1 << (SqlParser.UNINSTALL - 520)) | (1 << (SqlParser.UNKNOWN - 520)) | (1 << (SqlParser.UNTIL - 520)) | (1 << (SqlParser.UPGRADE - 520)) | (1 << (SqlParser.USER - 520)) | (1 << (SqlParser.USE_FRM - 520)) | (1 << (SqlParser.USER_RESOURCES - 520)) | (1 << (SqlParser.VALIDATION - 520)) | (1 << (SqlParser.VALUE - 520)) | (1 << (SqlParser.VARIABLES - 520)) | (1 << (SqlParser.VIEW - 520)) | (1 << (SqlParser.WAIT - 520)) | (1 << (SqlParser.WARNINGS - 520)) | (1 << (SqlParser.WITHOUT - 520)) | (1 << (SqlParser.WORK - 520)) | (1 << (SqlParser.WRAPPER - 520)) | (1 << (SqlParser.X509 - 520)) | (1 << (SqlParser.XA - 520)) | (1 << (SqlParser.XML - 520)))) != 0) or _la==SqlParser.MEMORY):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionNameBaseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABS(self):
            return self.getToken(SqlParser.ABS, 0)

        def ACOS(self):
            return self.getToken(SqlParser.ACOS, 0)

        def ADDDATE(self):
            return self.getToken(SqlParser.ADDDATE, 0)

        def ADDTIME(self):
            return self.getToken(SqlParser.ADDTIME, 0)

        def AES_DECRYPT(self):
            return self.getToken(SqlParser.AES_DECRYPT, 0)

        def AES_ENCRYPT(self):
            return self.getToken(SqlParser.AES_ENCRYPT, 0)

        def AREA(self):
            return self.getToken(SqlParser.AREA, 0)

        def ASBINARY(self):
            return self.getToken(SqlParser.ASBINARY, 0)

        def ASIN(self):
            return self.getToken(SqlParser.ASIN, 0)

        def ASTEXT(self):
            return self.getToken(SqlParser.ASTEXT, 0)

        def ASWKB(self):
            return self.getToken(SqlParser.ASWKB, 0)

        def ASWKT(self):
            return self.getToken(SqlParser.ASWKT, 0)

        def ASYMMETRIC_DECRYPT(self):
            return self.getToken(SqlParser.ASYMMETRIC_DECRYPT, 0)

        def ASYMMETRIC_DERIVE(self):
            return self.getToken(SqlParser.ASYMMETRIC_DERIVE, 0)

        def ASYMMETRIC_ENCRYPT(self):
            return self.getToken(SqlParser.ASYMMETRIC_ENCRYPT, 0)

        def ASYMMETRIC_SIGN(self):
            return self.getToken(SqlParser.ASYMMETRIC_SIGN, 0)

        def ASYMMETRIC_VERIFY(self):
            return self.getToken(SqlParser.ASYMMETRIC_VERIFY, 0)

        def ATAN(self):
            return self.getToken(SqlParser.ATAN, 0)

        def ATAN2(self):
            return self.getToken(SqlParser.ATAN2, 0)

        def BENCHMARK(self):
            return self.getToken(SqlParser.BENCHMARK, 0)

        def BIN(self):
            return self.getToken(SqlParser.BIN, 0)

        def BIT_COUNT(self):
            return self.getToken(SqlParser.BIT_COUNT, 0)

        def BIT_LENGTH(self):
            return self.getToken(SqlParser.BIT_LENGTH, 0)

        def BUFFER(self):
            return self.getToken(SqlParser.BUFFER, 0)

        def CEIL(self):
            return self.getToken(SqlParser.CEIL, 0)

        def CEILING(self):
            return self.getToken(SqlParser.CEILING, 0)

        def CENTROID(self):
            return self.getToken(SqlParser.CENTROID, 0)

        def CHARACTER_LENGTH(self):
            return self.getToken(SqlParser.CHARACTER_LENGTH, 0)

        def CHARSET(self):
            return self.getToken(SqlParser.CHARSET, 0)

        def CHAR_LENGTH(self):
            return self.getToken(SqlParser.CHAR_LENGTH, 0)

        def COERCIBILITY(self):
            return self.getToken(SqlParser.COERCIBILITY, 0)

        def COLLATION(self):
            return self.getToken(SqlParser.COLLATION, 0)

        def COMPRESS(self):
            return self.getToken(SqlParser.COMPRESS, 0)

        def CONCAT(self):
            return self.getToken(SqlParser.CONCAT, 0)

        def CONCAT_WS(self):
            return self.getToken(SqlParser.CONCAT_WS, 0)

        def CONNECTION_ID(self):
            return self.getToken(SqlParser.CONNECTION_ID, 0)

        def CONV(self):
            return self.getToken(SqlParser.CONV, 0)

        def CONVERT_TZ(self):
            return self.getToken(SqlParser.CONVERT_TZ, 0)

        def COS(self):
            return self.getToken(SqlParser.COS, 0)

        def COT(self):
            return self.getToken(SqlParser.COT, 0)

        def COUNT(self):
            return self.getToken(SqlParser.COUNT, 0)

        def CRC32(self):
            return self.getToken(SqlParser.CRC32, 0)

        def CREATE_ASYMMETRIC_PRIV_KEY(self):
            return self.getToken(SqlParser.CREATE_ASYMMETRIC_PRIV_KEY, 0)

        def CREATE_ASYMMETRIC_PUB_KEY(self):
            return self.getToken(SqlParser.CREATE_ASYMMETRIC_PUB_KEY, 0)

        def CREATE_DH_PARAMETERS(self):
            return self.getToken(SqlParser.CREATE_DH_PARAMETERS, 0)

        def CREATE_DIGEST(self):
            return self.getToken(SqlParser.CREATE_DIGEST, 0)

        def CROSSES(self):
            return self.getToken(SqlParser.CROSSES, 0)

        def DATABASE(self):
            return self.getToken(SqlParser.DATABASE, 0)

        def DATE(self):
            return self.getToken(SqlParser.DATE, 0)

        def DATEDIFF(self):
            return self.getToken(SqlParser.DATEDIFF, 0)

        def DATE_FORMAT(self):
            return self.getToken(SqlParser.DATE_FORMAT, 0)

        def DAY(self):
            return self.getToken(SqlParser.DAY, 0)

        def DAYNAME(self):
            return self.getToken(SqlParser.DAYNAME, 0)

        def DAYOFMONTH(self):
            return self.getToken(SqlParser.DAYOFMONTH, 0)

        def DAYOFWEEK(self):
            return self.getToken(SqlParser.DAYOFWEEK, 0)

        def DAYOFYEAR(self):
            return self.getToken(SqlParser.DAYOFYEAR, 0)

        def DECODE(self):
            return self.getToken(SqlParser.DECODE, 0)

        def DEGREES(self):
            return self.getToken(SqlParser.DEGREES, 0)

        def DES_DECRYPT(self):
            return self.getToken(SqlParser.DES_DECRYPT, 0)

        def DES_ENCRYPT(self):
            return self.getToken(SqlParser.DES_ENCRYPT, 0)

        def DIMENSION(self):
            return self.getToken(SqlParser.DIMENSION, 0)

        def DISJOINT(self):
            return self.getToken(SqlParser.DISJOINT, 0)

        def ELT(self):
            return self.getToken(SqlParser.ELT, 0)

        def ENCODE(self):
            return self.getToken(SqlParser.ENCODE, 0)

        def ENCRYPT(self):
            return self.getToken(SqlParser.ENCRYPT, 0)

        def ENDPOINT(self):
            return self.getToken(SqlParser.ENDPOINT, 0)

        def ENVELOPE(self):
            return self.getToken(SqlParser.ENVELOPE, 0)

        def EQUALS(self):
            return self.getToken(SqlParser.EQUALS, 0)

        def EXP(self):
            return self.getToken(SqlParser.EXP, 0)

        def EXPORT_SET(self):
            return self.getToken(SqlParser.EXPORT_SET, 0)

        def EXTERIORRING(self):
            return self.getToken(SqlParser.EXTERIORRING, 0)

        def EXTRACTVALUE(self):
            return self.getToken(SqlParser.EXTRACTVALUE, 0)

        def FIELD(self):
            return self.getToken(SqlParser.FIELD, 0)

        def FIND_IN_SET(self):
            return self.getToken(SqlParser.FIND_IN_SET, 0)

        def FLOOR(self):
            return self.getToken(SqlParser.FLOOR, 0)

        def FORMAT(self):
            return self.getToken(SqlParser.FORMAT, 0)

        def FOUND_ROWS(self):
            return self.getToken(SqlParser.FOUND_ROWS, 0)

        def FROM_BASE64(self):
            return self.getToken(SqlParser.FROM_BASE64, 0)

        def FROM_DAYS(self):
            return self.getToken(SqlParser.FROM_DAYS, 0)

        def FROM_UNIXTIME(self):
            return self.getToken(SqlParser.FROM_UNIXTIME, 0)

        def GEOMCOLLFROMTEXT(self):
            return self.getToken(SqlParser.GEOMCOLLFROMTEXT, 0)

        def GEOMCOLLFROMWKB(self):
            return self.getToken(SqlParser.GEOMCOLLFROMWKB, 0)

        def GEOMETRYCOLLECTION(self):
            return self.getToken(SqlParser.GEOMETRYCOLLECTION, 0)

        def GEOMETRYCOLLECTIONFROMTEXT(self):
            return self.getToken(SqlParser.GEOMETRYCOLLECTIONFROMTEXT, 0)

        def GEOMETRYCOLLECTIONFROMWKB(self):
            return self.getToken(SqlParser.GEOMETRYCOLLECTIONFROMWKB, 0)

        def GEOMETRYFROMTEXT(self):
            return self.getToken(SqlParser.GEOMETRYFROMTEXT, 0)

        def GEOMETRYFROMWKB(self):
            return self.getToken(SqlParser.GEOMETRYFROMWKB, 0)

        def GEOMETRYN(self):
            return self.getToken(SqlParser.GEOMETRYN, 0)

        def GEOMETRYTYPE(self):
            return self.getToken(SqlParser.GEOMETRYTYPE, 0)

        def GEOMFROMTEXT(self):
            return self.getToken(SqlParser.GEOMFROMTEXT, 0)

        def GEOMFROMWKB(self):
            return self.getToken(SqlParser.GEOMFROMWKB, 0)

        def GET_FORMAT(self):
            return self.getToken(SqlParser.GET_FORMAT, 0)

        def GET_LOCK(self):
            return self.getToken(SqlParser.GET_LOCK, 0)

        def GLENGTH(self):
            return self.getToken(SqlParser.GLENGTH, 0)

        def GREATEST(self):
            return self.getToken(SqlParser.GREATEST, 0)

        def GTID_SUBSET(self):
            return self.getToken(SqlParser.GTID_SUBSET, 0)

        def GTID_SUBTRACT(self):
            return self.getToken(SqlParser.GTID_SUBTRACT, 0)

        def HEX(self):
            return self.getToken(SqlParser.HEX, 0)

        def HOUR(self):
            return self.getToken(SqlParser.HOUR, 0)

        def IFNULL(self):
            return self.getToken(SqlParser.IFNULL, 0)

        def INET6_ATON(self):
            return self.getToken(SqlParser.INET6_ATON, 0)

        def INET6_NTOA(self):
            return self.getToken(SqlParser.INET6_NTOA, 0)

        def INET_ATON(self):
            return self.getToken(SqlParser.INET_ATON, 0)

        def INET_NTOA(self):
            return self.getToken(SqlParser.INET_NTOA, 0)

        def INSTR(self):
            return self.getToken(SqlParser.INSTR, 0)

        def INTERIORRINGN(self):
            return self.getToken(SqlParser.INTERIORRINGN, 0)

        def INTERSECTS(self):
            return self.getToken(SqlParser.INTERSECTS, 0)

        def ISCLOSED(self):
            return self.getToken(SqlParser.ISCLOSED, 0)

        def ISEMPTY(self):
            return self.getToken(SqlParser.ISEMPTY, 0)

        def ISNULL(self):
            return self.getToken(SqlParser.ISNULL, 0)

        def ISSIMPLE(self):
            return self.getToken(SqlParser.ISSIMPLE, 0)

        def IS_FREE_LOCK(self):
            return self.getToken(SqlParser.IS_FREE_LOCK, 0)

        def IS_IPV4(self):
            return self.getToken(SqlParser.IS_IPV4, 0)

        def IS_IPV4_COMPAT(self):
            return self.getToken(SqlParser.IS_IPV4_COMPAT, 0)

        def IS_IPV4_MAPPED(self):
            return self.getToken(SqlParser.IS_IPV4_MAPPED, 0)

        def IS_IPV6(self):
            return self.getToken(SqlParser.IS_IPV6, 0)

        def IS_USED_LOCK(self):
            return self.getToken(SqlParser.IS_USED_LOCK, 0)

        def LAST_INSERT_ID(self):
            return self.getToken(SqlParser.LAST_INSERT_ID, 0)

        def LCASE(self):
            return self.getToken(SqlParser.LCASE, 0)

        def LEAST(self):
            return self.getToken(SqlParser.LEAST, 0)

        def LEFT(self):
            return self.getToken(SqlParser.LEFT, 0)

        def LENGTH(self):
            return self.getToken(SqlParser.LENGTH, 0)

        def LINEFROMTEXT(self):
            return self.getToken(SqlParser.LINEFROMTEXT, 0)

        def LINEFROMWKB(self):
            return self.getToken(SqlParser.LINEFROMWKB, 0)

        def LINESTRING(self):
            return self.getToken(SqlParser.LINESTRING, 0)

        def LINESTRINGFROMTEXT(self):
            return self.getToken(SqlParser.LINESTRINGFROMTEXT, 0)

        def LINESTRINGFROMWKB(self):
            return self.getToken(SqlParser.LINESTRINGFROMWKB, 0)

        def LN(self):
            return self.getToken(SqlParser.LN, 0)

        def LOAD_FILE(self):
            return self.getToken(SqlParser.LOAD_FILE, 0)

        def LOCATE(self):
            return self.getToken(SqlParser.LOCATE, 0)

        def LOG(self):
            return self.getToken(SqlParser.LOG, 0)

        def LOG10(self):
            return self.getToken(SqlParser.LOG10, 0)

        def LOG2(self):
            return self.getToken(SqlParser.LOG2, 0)

        def LOWER(self):
            return self.getToken(SqlParser.LOWER, 0)

        def LPAD(self):
            return self.getToken(SqlParser.LPAD, 0)

        def LTRIM(self):
            return self.getToken(SqlParser.LTRIM, 0)

        def MAKEDATE(self):
            return self.getToken(SqlParser.MAKEDATE, 0)

        def MAKETIME(self):
            return self.getToken(SqlParser.MAKETIME, 0)

        def MAKE_SET(self):
            return self.getToken(SqlParser.MAKE_SET, 0)

        def MASTER_POS_WAIT(self):
            return self.getToken(SqlParser.MASTER_POS_WAIT, 0)

        def MBRCONTAINS(self):
            return self.getToken(SqlParser.MBRCONTAINS, 0)

        def MBRDISJOINT(self):
            return self.getToken(SqlParser.MBRDISJOINT, 0)

        def MBREQUAL(self):
            return self.getToken(SqlParser.MBREQUAL, 0)

        def MBRINTERSECTS(self):
            return self.getToken(SqlParser.MBRINTERSECTS, 0)

        def MBROVERLAPS(self):
            return self.getToken(SqlParser.MBROVERLAPS, 0)

        def MBRTOUCHES(self):
            return self.getToken(SqlParser.MBRTOUCHES, 0)

        def MBRWITHIN(self):
            return self.getToken(SqlParser.MBRWITHIN, 0)

        def MD5(self):
            return self.getToken(SqlParser.MD5, 0)

        def MICROSECOND(self):
            return self.getToken(SqlParser.MICROSECOND, 0)

        def MINUTE(self):
            return self.getToken(SqlParser.MINUTE, 0)

        def MLINEFROMTEXT(self):
            return self.getToken(SqlParser.MLINEFROMTEXT, 0)

        def MLINEFROMWKB(self):
            return self.getToken(SqlParser.MLINEFROMWKB, 0)

        def MONTH(self):
            return self.getToken(SqlParser.MONTH, 0)

        def MONTHNAME(self):
            return self.getToken(SqlParser.MONTHNAME, 0)

        def MPOINTFROMTEXT(self):
            return self.getToken(SqlParser.MPOINTFROMTEXT, 0)

        def MPOINTFROMWKB(self):
            return self.getToken(SqlParser.MPOINTFROMWKB, 0)

        def MPOLYFROMTEXT(self):
            return self.getToken(SqlParser.MPOLYFROMTEXT, 0)

        def MPOLYFROMWKB(self):
            return self.getToken(SqlParser.MPOLYFROMWKB, 0)

        def MULTILINESTRING(self):
            return self.getToken(SqlParser.MULTILINESTRING, 0)

        def MULTILINESTRINGFROMTEXT(self):
            return self.getToken(SqlParser.MULTILINESTRINGFROMTEXT, 0)

        def MULTILINESTRINGFROMWKB(self):
            return self.getToken(SqlParser.MULTILINESTRINGFROMWKB, 0)

        def MULTIPOINT(self):
            return self.getToken(SqlParser.MULTIPOINT, 0)

        def MULTIPOINTFROMTEXT(self):
            return self.getToken(SqlParser.MULTIPOINTFROMTEXT, 0)

        def MULTIPOINTFROMWKB(self):
            return self.getToken(SqlParser.MULTIPOINTFROMWKB, 0)

        def MULTIPOLYGON(self):
            return self.getToken(SqlParser.MULTIPOLYGON, 0)

        def MULTIPOLYGONFROMTEXT(self):
            return self.getToken(SqlParser.MULTIPOLYGONFROMTEXT, 0)

        def MULTIPOLYGONFROMWKB(self):
            return self.getToken(SqlParser.MULTIPOLYGONFROMWKB, 0)

        def NAME_CONST(self):
            return self.getToken(SqlParser.NAME_CONST, 0)

        def NULLIF(self):
            return self.getToken(SqlParser.NULLIF, 0)

        def NUMGEOMETRIES(self):
            return self.getToken(SqlParser.NUMGEOMETRIES, 0)

        def NUMINTERIORRINGS(self):
            return self.getToken(SqlParser.NUMINTERIORRINGS, 0)

        def NUMPOINTS(self):
            return self.getToken(SqlParser.NUMPOINTS, 0)

        def OCT(self):
            return self.getToken(SqlParser.OCT, 0)

        def OCTET_LENGTH(self):
            return self.getToken(SqlParser.OCTET_LENGTH, 0)

        def ORD(self):
            return self.getToken(SqlParser.ORD, 0)

        def OVERLAPS(self):
            return self.getToken(SqlParser.OVERLAPS, 0)

        def PERIOD_ADD(self):
            return self.getToken(SqlParser.PERIOD_ADD, 0)

        def PERIOD_DIFF(self):
            return self.getToken(SqlParser.PERIOD_DIFF, 0)

        def PI(self):
            return self.getToken(SqlParser.PI, 0)

        def POINT(self):
            return self.getToken(SqlParser.POINT, 0)

        def POINTFROMTEXT(self):
            return self.getToken(SqlParser.POINTFROMTEXT, 0)

        def POINTFROMWKB(self):
            return self.getToken(SqlParser.POINTFROMWKB, 0)

        def POINTN(self):
            return self.getToken(SqlParser.POINTN, 0)

        def POLYFROMTEXT(self):
            return self.getToken(SqlParser.POLYFROMTEXT, 0)

        def POLYFROMWKB(self):
            return self.getToken(SqlParser.POLYFROMWKB, 0)

        def POLYGON(self):
            return self.getToken(SqlParser.POLYGON, 0)

        def POLYGONFROMTEXT(self):
            return self.getToken(SqlParser.POLYGONFROMTEXT, 0)

        def POLYGONFROMWKB(self):
            return self.getToken(SqlParser.POLYGONFROMWKB, 0)

        def POSITION(self):
            return self.getToken(SqlParser.POSITION, 0)

        def POW(self):
            return self.getToken(SqlParser.POW, 0)

        def POWER(self):
            return self.getToken(SqlParser.POWER, 0)

        def QUARTER(self):
            return self.getToken(SqlParser.QUARTER, 0)

        def QUOTE(self):
            return self.getToken(SqlParser.QUOTE, 0)

        def RADIANS(self):
            return self.getToken(SqlParser.RADIANS, 0)

        def RAND(self):
            return self.getToken(SqlParser.RAND, 0)

        def RANDOM_BYTES(self):
            return self.getToken(SqlParser.RANDOM_BYTES, 0)

        def RELEASE_LOCK(self):
            return self.getToken(SqlParser.RELEASE_LOCK, 0)

        def REVERSE(self):
            return self.getToken(SqlParser.REVERSE, 0)

        def RIGHT(self):
            return self.getToken(SqlParser.RIGHT, 0)

        def ROUND(self):
            return self.getToken(SqlParser.ROUND, 0)

        def ROW_COUNT(self):
            return self.getToken(SqlParser.ROW_COUNT, 0)

        def RPAD(self):
            return self.getToken(SqlParser.RPAD, 0)

        def RTRIM(self):
            return self.getToken(SqlParser.RTRIM, 0)

        def SECOND(self):
            return self.getToken(SqlParser.SECOND, 0)

        def SEC_TO_TIME(self):
            return self.getToken(SqlParser.SEC_TO_TIME, 0)

        def SESSION_USER(self):
            return self.getToken(SqlParser.SESSION_USER, 0)

        def SHA(self):
            return self.getToken(SqlParser.SHA, 0)

        def SHA1(self):
            return self.getToken(SqlParser.SHA1, 0)

        def SHA2(self):
            return self.getToken(SqlParser.SHA2, 0)

        def SIGN(self):
            return self.getToken(SqlParser.SIGN, 0)

        def SIN(self):
            return self.getToken(SqlParser.SIN, 0)

        def SLEEP(self):
            return self.getToken(SqlParser.SLEEP, 0)

        def SOUNDEX(self):
            return self.getToken(SqlParser.SOUNDEX, 0)

        def SQL_THREAD_WAIT_AFTER_GTIDS(self):
            return self.getToken(SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS, 0)

        def SQRT(self):
            return self.getToken(SqlParser.SQRT, 0)

        def SRID(self):
            return self.getToken(SqlParser.SRID, 0)

        def STARTPOINT(self):
            return self.getToken(SqlParser.STARTPOINT, 0)

        def STRCMP(self):
            return self.getToken(SqlParser.STRCMP, 0)

        def STR_TO_DATE(self):
            return self.getToken(SqlParser.STR_TO_DATE, 0)

        def ST_AREA(self):
            return self.getToken(SqlParser.ST_AREA, 0)

        def ST_ASBINARY(self):
            return self.getToken(SqlParser.ST_ASBINARY, 0)

        def ST_ASTEXT(self):
            return self.getToken(SqlParser.ST_ASTEXT, 0)

        def ST_ASWKB(self):
            return self.getToken(SqlParser.ST_ASWKB, 0)

        def ST_ASWKT(self):
            return self.getToken(SqlParser.ST_ASWKT, 0)

        def ST_BUFFER(self):
            return self.getToken(SqlParser.ST_BUFFER, 0)

        def ST_CENTROID(self):
            return self.getToken(SqlParser.ST_CENTROID, 0)

        def ST_CONTAINS(self):
            return self.getToken(SqlParser.ST_CONTAINS, 0)

        def ST_CROSSES(self):
            return self.getToken(SqlParser.ST_CROSSES, 0)

        def ST_DIFFERENCE(self):
            return self.getToken(SqlParser.ST_DIFFERENCE, 0)

        def ST_DIMENSION(self):
            return self.getToken(SqlParser.ST_DIMENSION, 0)

        def ST_DISJOINT(self):
            return self.getToken(SqlParser.ST_DISJOINT, 0)

        def ST_DISTANCE(self):
            return self.getToken(SqlParser.ST_DISTANCE, 0)

        def ST_ENDPOINT(self):
            return self.getToken(SqlParser.ST_ENDPOINT, 0)

        def ST_ENVELOPE(self):
            return self.getToken(SqlParser.ST_ENVELOPE, 0)

        def ST_EQUALS(self):
            return self.getToken(SqlParser.ST_EQUALS, 0)

        def ST_EXTERIORRING(self):
            return self.getToken(SqlParser.ST_EXTERIORRING, 0)

        def ST_GEOMCOLLFROMTEXT(self):
            return self.getToken(SqlParser.ST_GEOMCOLLFROMTEXT, 0)

        def ST_GEOMCOLLFROMTXT(self):
            return self.getToken(SqlParser.ST_GEOMCOLLFROMTXT, 0)

        def ST_GEOMCOLLFROMWKB(self):
            return self.getToken(SqlParser.ST_GEOMCOLLFROMWKB, 0)

        def ST_GEOMETRYCOLLECTIONFROMTEXT(self):
            return self.getToken(SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT, 0)

        def ST_GEOMETRYCOLLECTIONFROMWKB(self):
            return self.getToken(SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB, 0)

        def ST_GEOMETRYFROMTEXT(self):
            return self.getToken(SqlParser.ST_GEOMETRYFROMTEXT, 0)

        def ST_GEOMETRYFROMWKB(self):
            return self.getToken(SqlParser.ST_GEOMETRYFROMWKB, 0)

        def ST_GEOMETRYN(self):
            return self.getToken(SqlParser.ST_GEOMETRYN, 0)

        def ST_GEOMETRYTYPE(self):
            return self.getToken(SqlParser.ST_GEOMETRYTYPE, 0)

        def ST_GEOMFROMTEXT(self):
            return self.getToken(SqlParser.ST_GEOMFROMTEXT, 0)

        def ST_GEOMFROMWKB(self):
            return self.getToken(SqlParser.ST_GEOMFROMWKB, 0)

        def ST_INTERIORRINGN(self):
            return self.getToken(SqlParser.ST_INTERIORRINGN, 0)

        def ST_INTERSECTION(self):
            return self.getToken(SqlParser.ST_INTERSECTION, 0)

        def ST_INTERSECTS(self):
            return self.getToken(SqlParser.ST_INTERSECTS, 0)

        def ST_ISCLOSED(self):
            return self.getToken(SqlParser.ST_ISCLOSED, 0)

        def ST_ISEMPTY(self):
            return self.getToken(SqlParser.ST_ISEMPTY, 0)

        def ST_ISSIMPLE(self):
            return self.getToken(SqlParser.ST_ISSIMPLE, 0)

        def ST_LINEFROMTEXT(self):
            return self.getToken(SqlParser.ST_LINEFROMTEXT, 0)

        def ST_LINEFROMWKB(self):
            return self.getToken(SqlParser.ST_LINEFROMWKB, 0)

        def ST_LINESTRINGFROMTEXT(self):
            return self.getToken(SqlParser.ST_LINESTRINGFROMTEXT, 0)

        def ST_LINESTRINGFROMWKB(self):
            return self.getToken(SqlParser.ST_LINESTRINGFROMWKB, 0)

        def ST_NUMGEOMETRIES(self):
            return self.getToken(SqlParser.ST_NUMGEOMETRIES, 0)

        def ST_NUMINTERIORRING(self):
            return self.getToken(SqlParser.ST_NUMINTERIORRING, 0)

        def ST_NUMINTERIORRINGS(self):
            return self.getToken(SqlParser.ST_NUMINTERIORRINGS, 0)

        def ST_NUMPOINTS(self):
            return self.getToken(SqlParser.ST_NUMPOINTS, 0)

        def ST_OVERLAPS(self):
            return self.getToken(SqlParser.ST_OVERLAPS, 0)

        def ST_POINTFROMTEXT(self):
            return self.getToken(SqlParser.ST_POINTFROMTEXT, 0)

        def ST_POINTFROMWKB(self):
            return self.getToken(SqlParser.ST_POINTFROMWKB, 0)

        def ST_POINTN(self):
            return self.getToken(SqlParser.ST_POINTN, 0)

        def ST_POLYFROMTEXT(self):
            return self.getToken(SqlParser.ST_POLYFROMTEXT, 0)

        def ST_POLYFROMWKB(self):
            return self.getToken(SqlParser.ST_POLYFROMWKB, 0)

        def ST_POLYGONFROMTEXT(self):
            return self.getToken(SqlParser.ST_POLYGONFROMTEXT, 0)

        def ST_POLYGONFROMWKB(self):
            return self.getToken(SqlParser.ST_POLYGONFROMWKB, 0)

        def ST_SRID(self):
            return self.getToken(SqlParser.ST_SRID, 0)

        def ST_STARTPOINT(self):
            return self.getToken(SqlParser.ST_STARTPOINT, 0)

        def ST_SYMDIFFERENCE(self):
            return self.getToken(SqlParser.ST_SYMDIFFERENCE, 0)

        def ST_TOUCHES(self):
            return self.getToken(SqlParser.ST_TOUCHES, 0)

        def ST_UNION(self):
            return self.getToken(SqlParser.ST_UNION, 0)

        def ST_WITHIN(self):
            return self.getToken(SqlParser.ST_WITHIN, 0)

        def ST_X(self):
            return self.getToken(SqlParser.ST_X, 0)

        def ST_Y(self):
            return self.getToken(SqlParser.ST_Y, 0)

        def SUBDATE(self):
            return self.getToken(SqlParser.SUBDATE, 0)

        def SUBSTRING_INDEX(self):
            return self.getToken(SqlParser.SUBSTRING_INDEX, 0)

        def SUBTIME(self):
            return self.getToken(SqlParser.SUBTIME, 0)

        def SYSTEM_USER(self):
            return self.getToken(SqlParser.SYSTEM_USER, 0)

        def TAN(self):
            return self.getToken(SqlParser.TAN, 0)

        def TIME(self):
            return self.getToken(SqlParser.TIME, 0)

        def TIMEDIFF(self):
            return self.getToken(SqlParser.TIMEDIFF, 0)

        def TIMESTAMP(self):
            return self.getToken(SqlParser.TIMESTAMP, 0)

        def TIMESTAMPADD(self):
            return self.getToken(SqlParser.TIMESTAMPADD, 0)

        def TIMESTAMPDIFF(self):
            return self.getToken(SqlParser.TIMESTAMPDIFF, 0)

        def TIME_FORMAT(self):
            return self.getToken(SqlParser.TIME_FORMAT, 0)

        def TIME_TO_SEC(self):
            return self.getToken(SqlParser.TIME_TO_SEC, 0)

        def TOUCHES(self):
            return self.getToken(SqlParser.TOUCHES, 0)

        def TO_BASE64(self):
            return self.getToken(SqlParser.TO_BASE64, 0)

        def TO_DAYS(self):
            return self.getToken(SqlParser.TO_DAYS, 0)

        def TO_SECONDS(self):
            return self.getToken(SqlParser.TO_SECONDS, 0)

        def UCASE(self):
            return self.getToken(SqlParser.UCASE, 0)

        def UNCOMPRESS(self):
            return self.getToken(SqlParser.UNCOMPRESS, 0)

        def UNCOMPRESSED_LENGTH(self):
            return self.getToken(SqlParser.UNCOMPRESSED_LENGTH, 0)

        def UNHEX(self):
            return self.getToken(SqlParser.UNHEX, 0)

        def UNIX_TIMESTAMP(self):
            return self.getToken(SqlParser.UNIX_TIMESTAMP, 0)

        def UPDATEXML(self):
            return self.getToken(SqlParser.UPDATEXML, 0)

        def UPPER(self):
            return self.getToken(SqlParser.UPPER, 0)

        def UUID(self):
            return self.getToken(SqlParser.UUID, 0)

        def UUID_SHORT(self):
            return self.getToken(SqlParser.UUID_SHORT, 0)

        def VALIDATE_PASSWORD_STRENGTH(self):
            return self.getToken(SqlParser.VALIDATE_PASSWORD_STRENGTH, 0)

        def VERSION(self):
            return self.getToken(SqlParser.VERSION, 0)

        def WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(self):
            return self.getToken(SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0)

        def WEEK(self):
            return self.getToken(SqlParser.WEEK, 0)

        def WEEKDAY(self):
            return self.getToken(SqlParser.WEEKDAY, 0)

        def WEEKOFYEAR(self):
            return self.getToken(SqlParser.WEEKOFYEAR, 0)

        def WEIGHT_STRING(self):
            return self.getToken(SqlParser.WEIGHT_STRING, 0)

        def WITHIN(self):
            return self.getToken(SqlParser.WITHIN, 0)

        def YEAR(self):
            return self.getToken(SqlParser.YEAR, 0)

        def YEARWEEK(self):
            return self.getToken(SqlParser.YEARWEEK, 0)

        def Y_FUNCTION(self):
            return self.getToken(SqlParser.Y_FUNCTION, 0)

        def X_FUNCTION(self):
            return self.getToken(SqlParser.X_FUNCTION, 0)

        def getRuleIndex(self):
            return SqlParser.RULE_functionNameBase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionNameBase" ):
                listener.enterFunctionNameBase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionNameBase" ):
                listener.exitFunctionNameBase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionNameBase" ):
                return visitor.visitFunctionNameBase(self)
            else:
                return visitor.visitChildren(self)




    def functionNameBase(self):

        localctx = SqlParser.FunctionNameBaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_functionNameBase)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1016
            _la = self._input.LA(1)
            if not(_la==SqlParser.DATABASE or _la==SqlParser.LEFT or _la==SqlParser.RIGHT or ((((_la - 182)) & ~0x3f) == 0 and ((1 << (_la - 182)) & ((1 << (SqlParser.DATE - 182)) | (1 << (SqlParser.TIME - 182)) | (1 << (SqlParser.TIMESTAMP - 182)) | (1 << (SqlParser.YEAR - 182)) | (1 << (SqlParser.COUNT - 182)) | (1 << (SqlParser.POSITION - 182)))) != 0) or ((((_la - 555)) & ~0x3f) == 0 and ((1 << (_la - 555)) & ((1 << (SqlParser.QUARTER - 555)) | (1 << (SqlParser.MONTH - 555)) | (1 << (SqlParser.DAY - 555)) | (1 << (SqlParser.HOUR - 555)) | (1 << (SqlParser.MINUTE - 555)) | (1 << (SqlParser.WEEK - 555)) | (1 << (SqlParser.SECOND - 555)) | (1 << (SqlParser.MICROSECOND - 555)))) != 0) or ((((_la - 627)) & ~0x3f) == 0 and ((1 << (_la - 627)) & ((1 << (SqlParser.GEOMETRYCOLLECTION - 627)) | (1 << (SqlParser.LINESTRING - 627)) | (1 << (SqlParser.MULTILINESTRING - 627)) | (1 << (SqlParser.MULTIPOINT - 627)) | (1 << (SqlParser.MULTIPOLYGON - 627)) | (1 << (SqlParser.POINT - 627)) | (1 << (SqlParser.POLYGON - 627)) | (1 << (SqlParser.ABS - 627)) | (1 << (SqlParser.ACOS - 627)) | (1 << (SqlParser.ADDDATE - 627)) | (1 << (SqlParser.ADDTIME - 627)) | (1 << (SqlParser.AES_DECRYPT - 627)) | (1 << (SqlParser.AES_ENCRYPT - 627)) | (1 << (SqlParser.AREA - 627)) | (1 << (SqlParser.ASBINARY - 627)) | (1 << (SqlParser.ASIN - 627)) | (1 << (SqlParser.ASTEXT - 627)) | (1 << (SqlParser.ASWKB - 627)) | (1 << (SqlParser.ASWKT - 627)) | (1 << (SqlParser.ASYMMETRIC_DECRYPT - 627)) | (1 << (SqlParser.ASYMMETRIC_DERIVE - 627)) | (1 << (SqlParser.ASYMMETRIC_ENCRYPT - 627)) | (1 << (SqlParser.ASYMMETRIC_SIGN - 627)) | (1 << (SqlParser.ASYMMETRIC_VERIFY - 627)) | (1 << (SqlParser.ATAN - 627)) | (1 << (SqlParser.ATAN2 - 627)) | (1 << (SqlParser.BENCHMARK - 627)) | (1 << (SqlParser.BIN - 627)) | (1 << (SqlParser.BIT_COUNT - 627)) | (1 << (SqlParser.BIT_LENGTH - 627)) | (1 << (SqlParser.BUFFER - 627)) | (1 << (SqlParser.CEIL - 627)) | (1 << (SqlParser.CEILING - 627)) | (1 << (SqlParser.CENTROID - 627)) | (1 << (SqlParser.CHARACTER_LENGTH - 627)) | (1 << (SqlParser.CHARSET - 627)) | (1 << (SqlParser.CHAR_LENGTH - 627)) | (1 << (SqlParser.COERCIBILITY - 627)) | (1 << (SqlParser.COLLATION - 627)) | (1 << (SqlParser.COMPRESS - 627)) | (1 << (SqlParser.CONCAT - 627)) | (1 << (SqlParser.CONCAT_WS - 627)) | (1 << (SqlParser.CONNECTION_ID - 627)) | (1 << (SqlParser.CONV - 627)) | (1 << (SqlParser.CONVERT_TZ - 627)) | (1 << (SqlParser.COS - 627)) | (1 << (SqlParser.COT - 627)) | (1 << (SqlParser.CRC32 - 627)) | (1 << (SqlParser.CREATE_ASYMMETRIC_PRIV_KEY - 627)) | (1 << (SqlParser.CREATE_ASYMMETRIC_PUB_KEY - 627)) | (1 << (SqlParser.CREATE_DH_PARAMETERS - 627)) | (1 << (SqlParser.CREATE_DIGEST - 627)) | (1 << (SqlParser.CROSSES - 627)) | (1 << (SqlParser.DATEDIFF - 627)) | (1 << (SqlParser.DATE_FORMAT - 627)) | (1 << (SqlParser.DAYNAME - 627)) | (1 << (SqlParser.DAYOFMONTH - 627)) | (1 << (SqlParser.DAYOFWEEK - 627)) | (1 << (SqlParser.DAYOFYEAR - 627)) | (1 << (SqlParser.DECODE - 627)) | (1 << (SqlParser.DEGREES - 627)) | (1 << (SqlParser.DES_DECRYPT - 627)) | (1 << (SqlParser.DES_ENCRYPT - 627)) | (1 << (SqlParser.DIMENSION - 627)))) != 0) or ((((_la - 691)) & ~0x3f) == 0 and ((1 << (_la - 691)) & ((1 << (SqlParser.DISJOINT - 691)) | (1 << (SqlParser.ELT - 691)) | (1 << (SqlParser.ENCODE - 691)) | (1 << (SqlParser.ENCRYPT - 691)) | (1 << (SqlParser.ENDPOINT - 691)) | (1 << (SqlParser.ENVELOPE - 691)) | (1 << (SqlParser.EQUALS - 691)) | (1 << (SqlParser.EXP - 691)) | (1 << (SqlParser.EXPORT_SET - 691)) | (1 << (SqlParser.EXTERIORRING - 691)) | (1 << (SqlParser.EXTRACTVALUE - 691)) | (1 << (SqlParser.FIELD - 691)) | (1 << (SqlParser.FIND_IN_SET - 691)) | (1 << (SqlParser.FLOOR - 691)) | (1 << (SqlParser.FORMAT - 691)) | (1 << (SqlParser.FOUND_ROWS - 691)) | (1 << (SqlParser.FROM_BASE64 - 691)) | (1 << (SqlParser.FROM_DAYS - 691)) | (1 << (SqlParser.FROM_UNIXTIME - 691)) | (1 << (SqlParser.GEOMCOLLFROMTEXT - 691)) | (1 << (SqlParser.GEOMCOLLFROMWKB - 691)) | (1 << (SqlParser.GEOMETRYCOLLECTIONFROMTEXT - 691)) | (1 << (SqlParser.GEOMETRYCOLLECTIONFROMWKB - 691)) | (1 << (SqlParser.GEOMETRYFROMTEXT - 691)) | (1 << (SqlParser.GEOMETRYFROMWKB - 691)) | (1 << (SqlParser.GEOMETRYN - 691)) | (1 << (SqlParser.GEOMETRYTYPE - 691)) | (1 << (SqlParser.GEOMFROMTEXT - 691)) | (1 << (SqlParser.GEOMFROMWKB - 691)) | (1 << (SqlParser.GET_FORMAT - 691)) | (1 << (SqlParser.GET_LOCK - 691)) | (1 << (SqlParser.GLENGTH - 691)) | (1 << (SqlParser.GREATEST - 691)) | (1 << (SqlParser.GTID_SUBSET - 691)) | (1 << (SqlParser.GTID_SUBTRACT - 691)) | (1 << (SqlParser.HEX - 691)) | (1 << (SqlParser.IFNULL - 691)) | (1 << (SqlParser.INET6_ATON - 691)) | (1 << (SqlParser.INET6_NTOA - 691)) | (1 << (SqlParser.INET_ATON - 691)) | (1 << (SqlParser.INET_NTOA - 691)) | (1 << (SqlParser.INSTR - 691)) | (1 << (SqlParser.INTERIORRINGN - 691)) | (1 << (SqlParser.INTERSECTS - 691)) | (1 << (SqlParser.ISCLOSED - 691)) | (1 << (SqlParser.ISEMPTY - 691)) | (1 << (SqlParser.ISNULL - 691)) | (1 << (SqlParser.ISSIMPLE - 691)) | (1 << (SqlParser.IS_FREE_LOCK - 691)) | (1 << (SqlParser.IS_IPV4 - 691)) | (1 << (SqlParser.IS_IPV4_COMPAT - 691)) | (1 << (SqlParser.IS_IPV4_MAPPED - 691)) | (1 << (SqlParser.IS_IPV6 - 691)) | (1 << (SqlParser.IS_USED_LOCK - 691)) | (1 << (SqlParser.LAST_INSERT_ID - 691)) | (1 << (SqlParser.LCASE - 691)) | (1 << (SqlParser.LEAST - 691)) | (1 << (SqlParser.LENGTH - 691)) | (1 << (SqlParser.LINEFROMTEXT - 691)) | (1 << (SqlParser.LINEFROMWKB - 691)) | (1 << (SqlParser.LINESTRINGFROMTEXT - 691)) | (1 << (SqlParser.LINESTRINGFROMWKB - 691)) | (1 << (SqlParser.LN - 691)) | (1 << (SqlParser.LOAD_FILE - 691)))) != 0) or ((((_la - 755)) & ~0x3f) == 0 and ((1 << (_la - 755)) & ((1 << (SqlParser.LOCATE - 755)) | (1 << (SqlParser.LOG - 755)) | (1 << (SqlParser.LOG10 - 755)) | (1 << (SqlParser.LOG2 - 755)) | (1 << (SqlParser.LOWER - 755)) | (1 << (SqlParser.LPAD - 755)) | (1 << (SqlParser.LTRIM - 755)) | (1 << (SqlParser.MAKEDATE - 755)) | (1 << (SqlParser.MAKETIME - 755)) | (1 << (SqlParser.MAKE_SET - 755)) | (1 << (SqlParser.MASTER_POS_WAIT - 755)) | (1 << (SqlParser.MBRCONTAINS - 755)) | (1 << (SqlParser.MBRDISJOINT - 755)) | (1 << (SqlParser.MBREQUAL - 755)) | (1 << (SqlParser.MBRINTERSECTS - 755)) | (1 << (SqlParser.MBROVERLAPS - 755)) | (1 << (SqlParser.MBRTOUCHES - 755)) | (1 << (SqlParser.MBRWITHIN - 755)) | (1 << (SqlParser.MD5 - 755)) | (1 << (SqlParser.MLINEFROMTEXT - 755)) | (1 << (SqlParser.MLINEFROMWKB - 755)) | (1 << (SqlParser.MONTHNAME - 755)) | (1 << (SqlParser.MPOINTFROMTEXT - 755)) | (1 << (SqlParser.MPOINTFROMWKB - 755)) | (1 << (SqlParser.MPOLYFROMTEXT - 755)) | (1 << (SqlParser.MPOLYFROMWKB - 755)) | (1 << (SqlParser.MULTILINESTRINGFROMTEXT - 755)) | (1 << (SqlParser.MULTILINESTRINGFROMWKB - 755)) | (1 << (SqlParser.MULTIPOINTFROMTEXT - 755)) | (1 << (SqlParser.MULTIPOINTFROMWKB - 755)) | (1 << (SqlParser.MULTIPOLYGONFROMTEXT - 755)) | (1 << (SqlParser.MULTIPOLYGONFROMWKB - 755)) | (1 << (SqlParser.NAME_CONST - 755)) | (1 << (SqlParser.NULLIF - 755)) | (1 << (SqlParser.NUMGEOMETRIES - 755)) | (1 << (SqlParser.NUMINTERIORRINGS - 755)) | (1 << (SqlParser.NUMPOINTS - 755)) | (1 << (SqlParser.OCT - 755)) | (1 << (SqlParser.OCTET_LENGTH - 755)) | (1 << (SqlParser.ORD - 755)) | (1 << (SqlParser.OVERLAPS - 755)) | (1 << (SqlParser.PERIOD_ADD - 755)) | (1 << (SqlParser.PERIOD_DIFF - 755)) | (1 << (SqlParser.PI - 755)) | (1 << (SqlParser.POINTFROMTEXT - 755)) | (1 << (SqlParser.POINTFROMWKB - 755)) | (1 << (SqlParser.POINTN - 755)) | (1 << (SqlParser.POLYFROMTEXT - 755)) | (1 << (SqlParser.POLYFROMWKB - 755)) | (1 << (SqlParser.POLYGONFROMTEXT - 755)) | (1 << (SqlParser.POLYGONFROMWKB - 755)) | (1 << (SqlParser.POW - 755)) | (1 << (SqlParser.POWER - 755)) | (1 << (SqlParser.QUOTE - 755)) | (1 << (SqlParser.RADIANS - 755)) | (1 << (SqlParser.RAND - 755)) | (1 << (SqlParser.RANDOM_BYTES - 755)) | (1 << (SqlParser.RELEASE_LOCK - 755)) | (1 << (SqlParser.REVERSE - 755)) | (1 << (SqlParser.ROUND - 755)) | (1 << (SqlParser.ROW_COUNT - 755)) | (1 << (SqlParser.RPAD - 755)) | (1 << (SqlParser.RTRIM - 755)) | (1 << (SqlParser.SEC_TO_TIME - 755)))) != 0) or ((((_la - 819)) & ~0x3f) == 0 and ((1 << (_la - 819)) & ((1 << (SqlParser.SESSION_USER - 819)) | (1 << (SqlParser.SHA - 819)) | (1 << (SqlParser.SHA1 - 819)) | (1 << (SqlParser.SHA2 - 819)) | (1 << (SqlParser.SIGN - 819)) | (1 << (SqlParser.SIN - 819)) | (1 << (SqlParser.SLEEP - 819)) | (1 << (SqlParser.SOUNDEX - 819)) | (1 << (SqlParser.SQL_THREAD_WAIT_AFTER_GTIDS - 819)) | (1 << (SqlParser.SQRT - 819)) | (1 << (SqlParser.SRID - 819)) | (1 << (SqlParser.STARTPOINT - 819)) | (1 << (SqlParser.STRCMP - 819)) | (1 << (SqlParser.STR_TO_DATE - 819)) | (1 << (SqlParser.ST_AREA - 819)) | (1 << (SqlParser.ST_ASBINARY - 819)) | (1 << (SqlParser.ST_ASTEXT - 819)) | (1 << (SqlParser.ST_ASWKB - 819)) | (1 << (SqlParser.ST_ASWKT - 819)) | (1 << (SqlParser.ST_BUFFER - 819)) | (1 << (SqlParser.ST_CENTROID - 819)) | (1 << (SqlParser.ST_CONTAINS - 819)) | (1 << (SqlParser.ST_CROSSES - 819)) | (1 << (SqlParser.ST_DIFFERENCE - 819)) | (1 << (SqlParser.ST_DIMENSION - 819)) | (1 << (SqlParser.ST_DISJOINT - 819)) | (1 << (SqlParser.ST_DISTANCE - 819)) | (1 << (SqlParser.ST_ENDPOINT - 819)) | (1 << (SqlParser.ST_ENVELOPE - 819)) | (1 << (SqlParser.ST_EQUALS - 819)) | (1 << (SqlParser.ST_EXTERIORRING - 819)) | (1 << (SqlParser.ST_GEOMCOLLFROMTEXT - 819)) | (1 << (SqlParser.ST_GEOMCOLLFROMTXT - 819)) | (1 << (SqlParser.ST_GEOMCOLLFROMWKB - 819)) | (1 << (SqlParser.ST_GEOMETRYCOLLECTIONFROMTEXT - 819)) | (1 << (SqlParser.ST_GEOMETRYCOLLECTIONFROMWKB - 819)) | (1 << (SqlParser.ST_GEOMETRYFROMTEXT - 819)) | (1 << (SqlParser.ST_GEOMETRYFROMWKB - 819)) | (1 << (SqlParser.ST_GEOMETRYN - 819)) | (1 << (SqlParser.ST_GEOMETRYTYPE - 819)) | (1 << (SqlParser.ST_GEOMFROMTEXT - 819)) | (1 << (SqlParser.ST_GEOMFROMWKB - 819)) | (1 << (SqlParser.ST_INTERIORRINGN - 819)) | (1 << (SqlParser.ST_INTERSECTION - 819)) | (1 << (SqlParser.ST_INTERSECTS - 819)) | (1 << (SqlParser.ST_ISCLOSED - 819)) | (1 << (SqlParser.ST_ISEMPTY - 819)) | (1 << (SqlParser.ST_ISSIMPLE - 819)) | (1 << (SqlParser.ST_LINEFROMTEXT - 819)) | (1 << (SqlParser.ST_LINEFROMWKB - 819)) | (1 << (SqlParser.ST_LINESTRINGFROMTEXT - 819)) | (1 << (SqlParser.ST_LINESTRINGFROMWKB - 819)) | (1 << (SqlParser.ST_NUMGEOMETRIES - 819)) | (1 << (SqlParser.ST_NUMINTERIORRING - 819)) | (1 << (SqlParser.ST_NUMINTERIORRINGS - 819)) | (1 << (SqlParser.ST_NUMPOINTS - 819)) | (1 << (SqlParser.ST_OVERLAPS - 819)) | (1 << (SqlParser.ST_POINTFROMTEXT - 819)) | (1 << (SqlParser.ST_POINTFROMWKB - 819)) | (1 << (SqlParser.ST_POINTN - 819)) | (1 << (SqlParser.ST_POLYFROMTEXT - 819)) | (1 << (SqlParser.ST_POLYFROMWKB - 819)) | (1 << (SqlParser.ST_POLYGONFROMTEXT - 819)) | (1 << (SqlParser.ST_POLYGONFROMWKB - 819)))) != 0) or ((((_la - 883)) & ~0x3f) == 0 and ((1 << (_la - 883)) & ((1 << (SqlParser.ST_SRID - 883)) | (1 << (SqlParser.ST_STARTPOINT - 883)) | (1 << (SqlParser.ST_SYMDIFFERENCE - 883)) | (1 << (SqlParser.ST_TOUCHES - 883)) | (1 << (SqlParser.ST_UNION - 883)) | (1 << (SqlParser.ST_WITHIN - 883)) | (1 << (SqlParser.ST_X - 883)) | (1 << (SqlParser.ST_Y - 883)) | (1 << (SqlParser.SUBDATE - 883)) | (1 << (SqlParser.SUBSTRING_INDEX - 883)) | (1 << (SqlParser.SUBTIME - 883)) | (1 << (SqlParser.SYSTEM_USER - 883)) | (1 << (SqlParser.TAN - 883)) | (1 << (SqlParser.TIMEDIFF - 883)) | (1 << (SqlParser.TIMESTAMPADD - 883)) | (1 << (SqlParser.TIMESTAMPDIFF - 883)) | (1 << (SqlParser.TIME_FORMAT - 883)) | (1 << (SqlParser.TIME_TO_SEC - 883)) | (1 << (SqlParser.TOUCHES - 883)) | (1 << (SqlParser.TO_BASE64 - 883)) | (1 << (SqlParser.TO_DAYS - 883)) | (1 << (SqlParser.TO_SECONDS - 883)) | (1 << (SqlParser.UCASE - 883)) | (1 << (SqlParser.UNCOMPRESS - 883)) | (1 << (SqlParser.UNCOMPRESSED_LENGTH - 883)) | (1 << (SqlParser.UNHEX - 883)) | (1 << (SqlParser.UNIX_TIMESTAMP - 883)) | (1 << (SqlParser.UPDATEXML - 883)) | (1 << (SqlParser.UPPER - 883)) | (1 << (SqlParser.UUID - 883)) | (1 << (SqlParser.UUID_SHORT - 883)) | (1 << (SqlParser.VALIDATE_PASSWORD_STRENGTH - 883)) | (1 << (SqlParser.VERSION - 883)) | (1 << (SqlParser.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS - 883)) | (1 << (SqlParser.WEEKDAY - 883)) | (1 << (SqlParser.WEEKOFYEAR - 883)) | (1 << (SqlParser.WEIGHT_STRING - 883)) | (1 << (SqlParser.WITHIN - 883)) | (1 << (SqlParser.YEARWEEK - 883)) | (1 << (SqlParser.Y_FUNCTION - 883)) | (1 << (SqlParser.X_FUNCTION - 883)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[58] = self.expression_sempred
        self._predicates[59] = self.predicate_sempred
        self._predicates[60] = self.expressionAtom_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

    def predicate_sempred(self, localctx:PredicateContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 3)
         

    def expressionAtom_sempred(self, localctx:ExpressionAtomContext, predIndex:int):
            if predIndex == 9:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 1)
         




